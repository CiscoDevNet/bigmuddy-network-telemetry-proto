// Code generated by protoc-gen-go.
// source: ospf_sh_summary.proto
// DO NOT EDIT!

/*
Package cisco_ios_xr_ipv4_ospf_oper_ospf_processes_process_vrfs_vrf_process_information_process_summary is a generated protocol buffer package.

It is generated from these files:
	ospf_sh_summary.proto

It has these top-level messages:
	OspfShSummary_KEYS
	OspfShSummary
	OspfShTime
	StringType
	OspfShRedistProto
	OspfShRedist
	OspfShDomainIdEntry
	OspfShDomainId
	OspfShMaxMetric
*/
package cisco_ios_xr_ipv4_ospf_oper_ospf_processes_process_vrfs_vrf_process_information_process_summary

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// OSPF Summary
type OspfShSummary_KEYS struct {
	ProcessName string `protobuf:"bytes,1,opt,name=process_name,json=processName" json:"process_name,omitempty"`
	VrfName     string `protobuf:"bytes,2,opt,name=vrf_name,json=vrfName" json:"vrf_name,omitempty"`
}

func (m *OspfShSummary_KEYS) Reset()                    { *m = OspfShSummary_KEYS{} }
func (m *OspfShSummary_KEYS) String() string            { return proto.CompactTextString(m) }
func (*OspfShSummary_KEYS) ProtoMessage()               {}
func (*OspfShSummary_KEYS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *OspfShSummary_KEYS) GetProcessName() string {
	if m != nil {
		return m.ProcessName
	}
	return ""
}

func (m *OspfShSummary_KEYS) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

type OspfShSummary struct {
	// If true, Role is Standby, Active otherwise
	RoleStandby bool `protobuf:"varint,50,opt,name=role_standby,json=roleStandby" json:"role_standby,omitempty"`
	// Role, V1/V2 Active/Standby
	Role uint32 `protobuf:"varint,51,opt,name=role" json:"role,omitempty"`
	// If true, NSR is enabled
	NsrEnabled bool `protobuf:"varint,52,opt,name=nsr_enabled,json=nsrEnabled" json:"nsr_enabled,omitempty"`
	// Trigger RP Switchover on detectable process restart
	NsrSwitchoverOnRestart bool `protobuf:"varint,53,opt,name=nsr_switchover_on_restart,json=nsrSwitchoverOnRestart" json:"nsr_switchover_on_restart,omitempty"`
	// If true, running in IGP-Intact mode
	IgpIntactOn bool `protobuf:"varint,54,opt,name=igp_intact_on,json=igpIntactOn" json:"igp_intact_on,omitempty"`
	// Router ID
	RouterId string `protobuf:"bytes,55,opt,name=router_id,json=routerId" json:"router_id,omitempty"`
	// Type of Service supported
	TosOptions uint32 `protobuf:"varint,56,opt,name=tos_options,json=tosOptions" json:"tos_options,omitempty"`
	// Opaque LSA capable
	OpaqueCapable bool `protobuf:"varint,57,opt,name=opaque_capable,json=opaqueCapable" json:"opaque_capable,omitempty"`
	// If true, is an Area Border Router
	AreaBorderRouter bool `protobuf:"varint,58,opt,name=area_border_router,json=areaBorderRouter" json:"area_border_router,omitempty"`
	// If true, is an AS Border Router
	AsBorderRouter bool `protobuf:"varint,59,opt,name=as_border_router,json=asBorderRouter" json:"as_border_router,omitempty"`
	// If true, vrf lite is enabled
	VrfLiteEnabled bool `protobuf:"varint,60,opt,name=vrf_lite_enabled,json=vrfLiteEnabled" json:"vrf_lite_enabled,omitempty"`
	// If true, originate Router LSA with maximum metric
	MaximumMetricStart bool `protobuf:"varint,61,opt,name=maximum_metric_start,json=maximumMetricStart" json:"maximum_metric_start,omitempty"`
	// Time remaining for hold down timer (s)
	MaximumMetricStartTimer uint32 `protobuf:"varint,62,opt,name=maximum_metric_start_timer,json=maximumMetricStartTimer" json:"maximum_metric_start_timer,omitempty"`
	// Max-metric set reason
	MaximumMetricSetReason string `protobuf:"bytes,63,opt,name=maximum_metric_set_reason,json=maximumMetricSetReason" json:"maximum_metric_set_reason,omitempty"`
	// If true, ABR duties temporarily disabled
	MaximumMetricAbrOffMode bool `protobuf:"varint,64,opt,name=maximum_metric_abr_off_mode,json=maximumMetricAbrOffMode" json:"maximum_metric_abr_off_mode,omitempty"`
	// Reasons for ABR duties being temporarily disabled
	MaximumMetricAbrOffReasons string `protobuf:"bytes,65,opt,name=maximum_metric_abr_off_reasons,json=maximumMetricAbrOffReasons" json:"maximum_metric_abr_off_reasons,omitempty"`
	// Buffer time in seconds since last neighbor activity, to remain in max-metric ABR off state
	MaximumMetricAbrOffBufferTime uint32 `protobuf:"varint,66,opt,name=maximum_metric_abr_off_buffer_time,json=maximumMetricAbrOffBufferTime" json:"maximum_metric_abr_off_buffer_time,omitempty"`
	// Max-metric list
	MaximumMetricList []*OspfShMaxMetric `protobuf:"bytes,67,rep,name=maximum_metric_list,json=maximumMetricList" json:"maximum_metric_list,omitempty"`
	// Redistribution list
	RedistributionList []*OspfShRedist `protobuf:"bytes,68,rep,name=redistribution_list,json=redistributionList" json:"redistribution_list,omitempty"`
	// Scheduling delay for SPF (ms) This is valid if configured below 64k Deprecated by SPFStartTimeU32]
	SpfStartTime uint32 `protobuf:"varint,69,opt,name=spf_start_time,json=spfStartTime" json:"spf_start_time,omitempty"`
	// Minimum delay time between SPF runs (ms) This is valid if configured below 64k Deprecated by SPFHoldTimeU32]
	SpfHoldTime uint32 `protobuf:"varint,70,opt,name=spf_hold_time,json=spfHoldTime" json:"spf_hold_time,omitempty"`
	// Maximum delay time between SPF runs (ms) This is valid if configured below 64k Deprecated by SPFMaximumTimeU32]
	SpfMaximumTime uint32 `protobuf:"varint,71,opt,name=spf_maximum_time,json=spfMaximumTime" json:"spf_maximum_time,omitempty"`
	// Scheduling delay for SPF (ms)
	SpfStartTimeU32 uint32 `protobuf:"varint,72,opt,name=spf_start_time_u32,json=spfStartTimeU32" json:"spf_start_time_u32,omitempty"`
	// Minimum delay time between SPF runs (ms)
	SpfHoldTimeU32 uint32 `protobuf:"varint,73,opt,name=spf_hold_time_u32,json=spfHoldTimeU32" json:"spf_hold_time_u32,omitempty"`
	// Maximum delay time between SPF runs (ms)
	SpfMaximumTimeU32 uint32 `protobuf:"varint,74,opt,name=spf_maximum_time_u32,json=spfMaximumTimeU32" json:"spf_maximum_time_u32,omitempty"`
	// If true, prefix-priority policy is configured
	SpfPrefixPriority bool `protobuf:"varint,75,opt,name=spf_prefix_priority,json=spfPrefixPriority" json:"spf_prefix_priority,omitempty"`
	// SPF Prefix-priority route policy
	SpfPrefixPriorityRoutePolicy string `protobuf:"bytes,76,opt,name=spf_prefix_priority_route_policy,json=spfPrefixPriorityRoutePolicy" json:"spf_prefix_priority_route_policy,omitempty"`
	// Inital LSA throttle delay (ms)
	LsaStartTime int32 `protobuf:"zigzag32,77,opt,name=lsa_start_time,json=lsaStartTime" json:"lsa_start_time,omitempty"`
	// Second delay before generating next LSA (ms)
	LsaHoldTime uint32 `protobuf:"varint,78,opt,name=lsa_hold_time,json=lsaHoldTime" json:"lsa_hold_time,omitempty"`
	// Maximum delay before generating an LSA (ms)
	LsaMaximumTime uint32 `protobuf:"varint,79,opt,name=lsa_maximum_time,json=lsaMaximumTime" json:"lsa_maximum_time,omitempty"`
	// Minimum time between LSA regeneration (ms) Rel 4.0.1, deprecated by MinimumLSAIntervalU32]
	MinimumLsaInterval uint32 `protobuf:"varint,80,opt,name=minimum_lsa_interval,json=minimumLsaInterval" json:"minimum_lsa_interval,omitempty"`
	// Minimum time between LSA regeneration (ms)
	MinimumLsaIntervalU32 uint32 `protobuf:"varint,81,opt,name=minimum_lsa_interval_u32,json=minimumLsaIntervalU32" json:"minimum_lsa_interval_u32,omitempty"`
	// LSA refresh interval (sec)
	LsaRefreshInterval uint32 `protobuf:"varint,82,opt,name=lsa_refresh_interval,json=lsaRefreshInterval" json:"lsa_refresh_interval,omitempty"`
	// Minimum time between accepting LSAs (ms) Rel 4.0.1, deprecated by MinimumLSAArrivalIntervalU32]
	MinimumLsaArrivalInterval uint32 `protobuf:"varint,83,opt,name=minimum_lsa_arrival_interval,json=minimumLsaArrivalInterval" json:"minimum_lsa_arrival_interval,omitempty"`
	// Minimum time between accepting LSAs (ms)
	MinimumLsaArrivalIntervalU32 uint32 `protobuf:"varint,84,opt,name=minimum_lsa_arrival_interval_u32,json=minimumLsaArrivalIntervalU32" json:"minimum_lsa_arrival_interval_u32,omitempty"`
	// Flood pacing timer (ms)
	IfFloodPacingInterval uint32 `protobuf:"varint,85,opt,name=if_flood_pacing_interval,json=ifFloodPacingInterval" json:"if_flood_pacing_interval,omitempty"`
	// Retransmission pacing timer (ms)
	IfRetransPacingInterval uint32 `protobuf:"varint,86,opt,name=if_retrans_pacing_interval,json=ifRetransPacingInterval" json:"if_retrans_pacing_interval,omitempty"`
	// Num of nbrs brought up initially per area
	AdjStagInitNumNbr uint32 `protobuf:"varint,87,opt,name=adj_stag_init_num_nbr,json=adjStagInitNumNbr" json:"adj_stag_init_num_nbr,omitempty"`
	// Max num of nbrs brought up simultaneously per OSPF instance
	AdjStagMaxNumNbr uint32 `protobuf:"varint,88,opt,name=adj_stag_max_num_nbr,json=adjStagMaxNumNbr" json:"adj_stag_max_num_nbr,omitempty"`
	// If true, OSPF Adjacency Staggering is configured
	AdjStaggerEnabled bool `protobuf:"varint,89,opt,name=adj_stagger_enabled,json=adjStaggerEnabled" json:"adj_stagger_enabled,omitempty"`
	// Num of nbrs currently forming for OSPF instance
	AdjStagNumNbrForming uint32 `protobuf:"varint,90,opt,name=adj_stag_num_nbr_forming,json=adjStagNumNbrForming" json:"adj_stag_num_nbr_forming,omitempty"`
	// Num of full nbrs
	NumberNbrsFull uint32 `protobuf:"varint,91,opt,name=number_nbrs_full,json=numberNbrsFull" json:"number_nbrs_full,omitempty"`
	// Number of AS scope LSAs
	AsLsaCount uint32 `protobuf:"varint,92,opt,name=as_lsa_count,json=asLsaCount" json:"as_lsa_count,omitempty"`
	// Sum of AS scope LSA checksum
	AsLsaChecksum uint32 `protobuf:"varint,93,opt,name=as_lsa_checksum,json=asLsaChecksum" json:"as_lsa_checksum,omitempty"`
	// Number of Opaque LSAs
	OpaqueLsaCount uint32 `protobuf:"varint,94,opt,name=opaque_lsa_count,json=opaqueLsaCount" json:"opaque_lsa_count,omitempty"`
	// Sum of opaque LSA checksum
	OpaqueLsaChecksum uint32 `protobuf:"varint,95,opt,name=opaque_lsa_checksum,json=opaqueLsaChecksum" json:"opaque_lsa_checksum,omitempty"`
	// Number of External and AS Opaque LSAs with demand circut bit not set
	AsDcBitlessLsaCount uint32 `protobuf:"varint,96,opt,name=as_dc_bitless_lsa_count,json=asDcBitlessLsaCount" json:"as_dc_bitless_lsa_count,omitempty"`
	// Number of External and AS Opaque LSAs with DoNotAge set
	AsDnaLsaCount uint32 `protobuf:"varint,97,opt,name=as_dna_lsa_count,json=asDnaLsaCount" json:"as_dna_lsa_count,omitempty"`
	// Number of areas
	AreaCount uint32 `protobuf:"varint,98,opt,name=area_count,json=areaCount" json:"area_count,omitempty"`
	// Number of normal Areas
	NormalAreaCount uint32 `protobuf:"varint,99,opt,name=normal_area_count,json=normalAreaCount" json:"normal_area_count,omitempty"`
	// Number of Stub and Total Stub Areas
	StubAreaCount uint32 `protobuf:"varint,100,opt,name=stub_area_count,json=stubAreaCount" json:"stub_area_count,omitempty"`
	// Number of NSSA Areas
	NssaAreaCount uint32 `protobuf:"varint,101,opt,name=nssa_area_count,json=nssaAreaCount" json:"nssa_area_count,omitempty"`
	// Maximum number of interfaces
	MaximumInterfaces uint32 `protobuf:"varint,102,opt,name=maximum_interfaces,json=maximumInterfaces" json:"maximum_interfaces,omitempty"`
	// Length of AS LSAs flood list
	AsLsaFloodListLength uint32 `protobuf:"varint,103,opt,name=as_lsa_flood_list_length,json=asLsaFloodListLength" json:"as_lsa_flood_list_length,omitempty"`
	// If true, NSF enabled
	NsfEnabled bool `protobuf:"varint,104,opt,name=nsf_enabled,json=nsfEnabled" json:"nsf_enabled,omitempty"`
	//  Length of time since the last NSF (s)
	LastNsfTime uint32 `protobuf:"varint,105,opt,name=last_nsf_time,json=lastNsfTime" json:"last_nsf_time,omitempty"`
	// Total time to complete NSF (s)
	NsfTime uint32 `protobuf:"varint,106,opt,name=nsf_time,json=nsfTime" json:"nsf_time,omitempty"`
	// The number of redistributed prefixes allowed
	RedistributionLimit uint32 `protobuf:"varint,107,opt,name=redistribution_limit,json=redistributionLimit" json:"redistribution_limit,omitempty"`
	// When the number of redistributed prefixes reaches this threshold, a warning message is issued
	RedistributionThreshold uint32 `protobuf:"varint,108,opt,name=redistribution_threshold,json=redistributionThreshold" json:"redistribution_threshold,omitempty"`
	// If true, only a syslog message is printed when redistribution prefix limit is reached
	RedistributionLimitWarn bool `protobuf:"varint,109,opt,name=redistribution_limit_warn,json=redistributionLimitWarn" json:"redistribution_limit_warn,omitempty"`
	// Amount of time routes are retained after graceful shutdown (s)
	GracefulShutdownRetentionTime uint32 `protobuf:"varint,110,opt,name=graceful_shutdown_retention_time,json=gracefulShutdownRetentionTime" json:"graceful_shutdown_retention_time,omitempty"`
	// State of graceful shutdown
	GracefulShutdownState string `protobuf:"bytes,111,opt,name=graceful_shutdown_state,json=gracefulShutdownState" json:"graceful_shutdown_state,omitempty"`
	// Domain ID information
	DomainId *OspfShDomainId `protobuf:"bytes,112,opt,name=domain_id,json=domainId" json:"domain_id,omitempty"`
	// If true, prefix limit for table has been  reached
	TablePrefixLimitReached bool `protobuf:"varint,113,opt,name=table_prefix_limit_reached,json=tablePrefixLimitReached" json:"table_prefix_limit_reached,omitempty"`
	// Non self-generated LSA count
	NonSelfLsaCount uint32 `protobuf:"varint,114,opt,name=non_self_lsa_count,json=nonSelfLsaCount" json:"non_self_lsa_count,omitempty"`
	// If true, max-lsa protection enabled
	MaxLsaEnabled bool `protobuf:"varint,115,opt,name=max_lsa_enabled,json=maxLsaEnabled" json:"max_lsa_enabled,omitempty"`
	// Maximum allowed number of non self-generated LSAs
	MaxLsaLimit uint32 `protobuf:"varint,116,opt,name=max_lsa_limit,json=maxLsaLimit" json:"max_lsa_limit,omitempty"`
	// max-lsa protection warning threshold
	MaxLsaTreshold uint32 `protobuf:"varint,117,opt,name=max_lsa_treshold,json=maxLsaTreshold" json:"max_lsa_treshold,omitempty"`
	// Warning only when max-lsa reached
	MaxLsaWarningOnly bool `protobuf:"varint,118,opt,name=max_lsa_warning_only,json=maxLsaWarningOnly" json:"max_lsa_warning_only,omitempty"`
	// Time ignoring new LSAs after max-lsa reached
	MaxLsaIgnoreTime uint32 `protobuf:"varint,119,opt,name=max_lsa_ignore_time,json=maxLsaIgnoreTime" json:"max_lsa_ignore_time,omitempty"`
	// Time after which LSA protection counter is reset
	MaxLsaResetTime uint32 `protobuf:"varint,120,opt,name=max_lsa_reset_time,json=maxLsaResetTime" json:"max_lsa_reset_time,omitempty"`
	// Max allowed number of entering ignore state
	MaxLsaIgnoreLimit uint32 `protobuf:"varint,121,opt,name=max_lsa_ignore_limit,json=maxLsaIgnoreLimit" json:"max_lsa_ignore_limit,omitempty"`
	// How many times ignore state has been entered
	MaxLsaIgnoreCount uint32 `protobuf:"varint,122,opt,name=max_lsa_ignore_count,json=maxLsaIgnoreCount" json:"max_lsa_ignore_count,omitempty"`
	// Remaining time when ignore timer is running
	MaxLsaIgnoreTimer uint32 `protobuf:"varint,123,opt,name=max_lsa_ignore_timer,json=maxLsaIgnoreTimer" json:"max_lsa_ignore_timer,omitempty"`
	// Remaining time when reset timer is running
	MaxLsaResetTimer uint32 `protobuf:"varint,124,opt,name=max_lsa_reset_timer,json=maxLsaResetTimer" json:"max_lsa_reset_timer,omitempty"`
	// Context name
	ContextName string `protobuf:"bytes,125,opt,name=context_name,json=contextName" json:"context_name,omitempty"`
	// If true, snmp trap is enabled
	SnmpTrapEnabled bool `protobuf:"varint,126,opt,name=snmp_trap_enabled,json=snmpTrapEnabled" json:"snmp_trap_enabled,omitempty"`
	// If true, UCMP is enabled
	Ucmp bool `protobuf:"varint,127,opt,name=ucmp" json:"ucmp,omitempty"`
	// UCMP Prefix-list
	UcmpPrefixList string `protobuf:"bytes,128,opt,name=ucmp_prefix_list,json=ucmpPrefixList" json:"ucmp_prefix_list,omitempty"`
	// UCMP Variance
	UcmpVariance int32 `protobuf:"zigzag32,129,opt,name=ucmp_variance,json=ucmpVariance" json:"ucmp_variance,omitempty"`
	// Delay between end of SPF and start of UCMP calculation (ms)
	UcmpDelay uint32 `protobuf:"varint,130,opt,name=ucmp_delay,json=ucmpDelay" json:"ucmp_delay,omitempty"`
	// Microloop avoidance type configured
	MicroloopAvoidanceType string `protobuf:"bytes,131,opt,name=microloop_avoidance_type,json=microloopAvoidanceType" json:"microloop_avoidance_type,omitempty"`
	// Microloop delay time after which actual post convergence paths are given to RIB (s)
	MicroloopAvoidanceDelay uint32 `protobuf:"varint,132,opt,name=microloop_avoidance_delay,json=microloopAvoidanceDelay" json:"microloop_avoidance_delay,omitempty"`
	// If true, Uloop is active
	MicroloopAvoidanceActive bool `protobuf:"varint,133,opt,name=microloop_avoidance_active,json=microloopAvoidanceActive" json:"microloop_avoidance_active,omitempty"`
	// Remaining time for uloop delay timer to expire (s)
	MicroloopAvoidanceDelayExpiry uint32 `protobuf:"varint,134,opt,name=microloop_avoidance_delay_expiry,json=microloopAvoidanceDelayExpiry" json:"microloop_avoidance_delay_expiry,omitempty"`
	// True if connected to LSD
	LsdConnected bool `protobuf:"varint,135,opt,name=lsd_connected,json=lsdConnected" json:"lsd_connected,omitempty"`
	// True if registered with LSD
	LsdRegistered bool `protobuf:"varint,136,opt,name=lsd_registered,json=lsdRegistered" json:"lsd_registered,omitempty"`
	// True if bound to LSD
	LsdBound bool `protobuf:"varint,137,opt,name=lsd_bound,json=lsdBound" json:"lsd_bound,omitempty"`
	// LSD Connection Revision
	LsdConnectionRevision uint32 `protobuf:"varint,138,opt,name=lsd_connection_revision,json=lsdConnectionRevision" json:"lsd_connection_revision,omitempty"`
	// True if Segment Routing Global Block configured
	SrgbConfigured bool `protobuf:"varint,139,opt,name=srgb_configured,json=srgbConfigured" json:"srgb_configured,omitempty"`
	// Segment Routing Global Block start label value
	SrgbStart uint32 `protobuf:"varint,140,opt,name=srgb_start,json=srgbStart" json:"srgb_start,omitempty"`
	// Segment Routing Global Block end label value
	SrgbEnd uint32 `protobuf:"varint,141,opt,name=srgb_end,json=srgbEnd" json:"srgb_end,omitempty"`
	// Segment Routing Global Block allocation status
	SrgbStatus string `protobuf:"bytes,142,opt,name=srgb_status,json=srgbStatus" json:"srgb_status,omitempty"`
	// True if Segment Routing Strict-SPF capable
	SrStrictSpfCap bool `protobuf:"varint,143,opt,name=sr_strict_spf_cap,json=srStrictSpfCap" json:"sr_strict_spf_cap,omitempty"`
}

func (m *OspfShSummary) Reset()                    { *m = OspfShSummary{} }
func (m *OspfShSummary) String() string            { return proto.CompactTextString(m) }
func (*OspfShSummary) ProtoMessage()               {}
func (*OspfShSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *OspfShSummary) GetRoleStandby() bool {
	if m != nil {
		return m.RoleStandby
	}
	return false
}

func (m *OspfShSummary) GetRole() uint32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *OspfShSummary) GetNsrEnabled() bool {
	if m != nil {
		return m.NsrEnabled
	}
	return false
}

func (m *OspfShSummary) GetNsrSwitchoverOnRestart() bool {
	if m != nil {
		return m.NsrSwitchoverOnRestart
	}
	return false
}

func (m *OspfShSummary) GetIgpIntactOn() bool {
	if m != nil {
		return m.IgpIntactOn
	}
	return false
}

func (m *OspfShSummary) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *OspfShSummary) GetTosOptions() uint32 {
	if m != nil {
		return m.TosOptions
	}
	return 0
}

func (m *OspfShSummary) GetOpaqueCapable() bool {
	if m != nil {
		return m.OpaqueCapable
	}
	return false
}

func (m *OspfShSummary) GetAreaBorderRouter() bool {
	if m != nil {
		return m.AreaBorderRouter
	}
	return false
}

func (m *OspfShSummary) GetAsBorderRouter() bool {
	if m != nil {
		return m.AsBorderRouter
	}
	return false
}

func (m *OspfShSummary) GetVrfLiteEnabled() bool {
	if m != nil {
		return m.VrfLiteEnabled
	}
	return false
}

func (m *OspfShSummary) GetMaximumMetricStart() bool {
	if m != nil {
		return m.MaximumMetricStart
	}
	return false
}

func (m *OspfShSummary) GetMaximumMetricStartTimer() uint32 {
	if m != nil {
		return m.MaximumMetricStartTimer
	}
	return 0
}

func (m *OspfShSummary) GetMaximumMetricSetReason() string {
	if m != nil {
		return m.MaximumMetricSetReason
	}
	return ""
}

func (m *OspfShSummary) GetMaximumMetricAbrOffMode() bool {
	if m != nil {
		return m.MaximumMetricAbrOffMode
	}
	return false
}

func (m *OspfShSummary) GetMaximumMetricAbrOffReasons() string {
	if m != nil {
		return m.MaximumMetricAbrOffReasons
	}
	return ""
}

func (m *OspfShSummary) GetMaximumMetricAbrOffBufferTime() uint32 {
	if m != nil {
		return m.MaximumMetricAbrOffBufferTime
	}
	return 0
}

func (m *OspfShSummary) GetMaximumMetricList() []*OspfShMaxMetric {
	if m != nil {
		return m.MaximumMetricList
	}
	return nil
}

func (m *OspfShSummary) GetRedistributionList() []*OspfShRedist {
	if m != nil {
		return m.RedistributionList
	}
	return nil
}

func (m *OspfShSummary) GetSpfStartTime() uint32 {
	if m != nil {
		return m.SpfStartTime
	}
	return 0
}

func (m *OspfShSummary) GetSpfHoldTime() uint32 {
	if m != nil {
		return m.SpfHoldTime
	}
	return 0
}

func (m *OspfShSummary) GetSpfMaximumTime() uint32 {
	if m != nil {
		return m.SpfMaximumTime
	}
	return 0
}

func (m *OspfShSummary) GetSpfStartTimeU32() uint32 {
	if m != nil {
		return m.SpfStartTimeU32
	}
	return 0
}

func (m *OspfShSummary) GetSpfHoldTimeU32() uint32 {
	if m != nil {
		return m.SpfHoldTimeU32
	}
	return 0
}

func (m *OspfShSummary) GetSpfMaximumTimeU32() uint32 {
	if m != nil {
		return m.SpfMaximumTimeU32
	}
	return 0
}

func (m *OspfShSummary) GetSpfPrefixPriority() bool {
	if m != nil {
		return m.SpfPrefixPriority
	}
	return false
}

func (m *OspfShSummary) GetSpfPrefixPriorityRoutePolicy() string {
	if m != nil {
		return m.SpfPrefixPriorityRoutePolicy
	}
	return ""
}

func (m *OspfShSummary) GetLsaStartTime() int32 {
	if m != nil {
		return m.LsaStartTime
	}
	return 0
}

func (m *OspfShSummary) GetLsaHoldTime() uint32 {
	if m != nil {
		return m.LsaHoldTime
	}
	return 0
}

func (m *OspfShSummary) GetLsaMaximumTime() uint32 {
	if m != nil {
		return m.LsaMaximumTime
	}
	return 0
}

func (m *OspfShSummary) GetMinimumLsaInterval() uint32 {
	if m != nil {
		return m.MinimumLsaInterval
	}
	return 0
}

func (m *OspfShSummary) GetMinimumLsaIntervalU32() uint32 {
	if m != nil {
		return m.MinimumLsaIntervalU32
	}
	return 0
}

func (m *OspfShSummary) GetLsaRefreshInterval() uint32 {
	if m != nil {
		return m.LsaRefreshInterval
	}
	return 0
}

func (m *OspfShSummary) GetMinimumLsaArrivalInterval() uint32 {
	if m != nil {
		return m.MinimumLsaArrivalInterval
	}
	return 0
}

func (m *OspfShSummary) GetMinimumLsaArrivalIntervalU32() uint32 {
	if m != nil {
		return m.MinimumLsaArrivalIntervalU32
	}
	return 0
}

func (m *OspfShSummary) GetIfFloodPacingInterval() uint32 {
	if m != nil {
		return m.IfFloodPacingInterval
	}
	return 0
}

func (m *OspfShSummary) GetIfRetransPacingInterval() uint32 {
	if m != nil {
		return m.IfRetransPacingInterval
	}
	return 0
}

func (m *OspfShSummary) GetAdjStagInitNumNbr() uint32 {
	if m != nil {
		return m.AdjStagInitNumNbr
	}
	return 0
}

func (m *OspfShSummary) GetAdjStagMaxNumNbr() uint32 {
	if m != nil {
		return m.AdjStagMaxNumNbr
	}
	return 0
}

func (m *OspfShSummary) GetAdjStaggerEnabled() bool {
	if m != nil {
		return m.AdjStaggerEnabled
	}
	return false
}

func (m *OspfShSummary) GetAdjStagNumNbrForming() uint32 {
	if m != nil {
		return m.AdjStagNumNbrForming
	}
	return 0
}

func (m *OspfShSummary) GetNumberNbrsFull() uint32 {
	if m != nil {
		return m.NumberNbrsFull
	}
	return 0
}

func (m *OspfShSummary) GetAsLsaCount() uint32 {
	if m != nil {
		return m.AsLsaCount
	}
	return 0
}

func (m *OspfShSummary) GetAsLsaChecksum() uint32 {
	if m != nil {
		return m.AsLsaChecksum
	}
	return 0
}

func (m *OspfShSummary) GetOpaqueLsaCount() uint32 {
	if m != nil {
		return m.OpaqueLsaCount
	}
	return 0
}

func (m *OspfShSummary) GetOpaqueLsaChecksum() uint32 {
	if m != nil {
		return m.OpaqueLsaChecksum
	}
	return 0
}

func (m *OspfShSummary) GetAsDcBitlessLsaCount() uint32 {
	if m != nil {
		return m.AsDcBitlessLsaCount
	}
	return 0
}

func (m *OspfShSummary) GetAsDnaLsaCount() uint32 {
	if m != nil {
		return m.AsDnaLsaCount
	}
	return 0
}

func (m *OspfShSummary) GetAreaCount() uint32 {
	if m != nil {
		return m.AreaCount
	}
	return 0
}

func (m *OspfShSummary) GetNormalAreaCount() uint32 {
	if m != nil {
		return m.NormalAreaCount
	}
	return 0
}

func (m *OspfShSummary) GetStubAreaCount() uint32 {
	if m != nil {
		return m.StubAreaCount
	}
	return 0
}

func (m *OspfShSummary) GetNssaAreaCount() uint32 {
	if m != nil {
		return m.NssaAreaCount
	}
	return 0
}

func (m *OspfShSummary) GetMaximumInterfaces() uint32 {
	if m != nil {
		return m.MaximumInterfaces
	}
	return 0
}

func (m *OspfShSummary) GetAsLsaFloodListLength() uint32 {
	if m != nil {
		return m.AsLsaFloodListLength
	}
	return 0
}

func (m *OspfShSummary) GetNsfEnabled() bool {
	if m != nil {
		return m.NsfEnabled
	}
	return false
}

func (m *OspfShSummary) GetLastNsfTime() uint32 {
	if m != nil {
		return m.LastNsfTime
	}
	return 0
}

func (m *OspfShSummary) GetNsfTime() uint32 {
	if m != nil {
		return m.NsfTime
	}
	return 0
}

func (m *OspfShSummary) GetRedistributionLimit() uint32 {
	if m != nil {
		return m.RedistributionLimit
	}
	return 0
}

func (m *OspfShSummary) GetRedistributionThreshold() uint32 {
	if m != nil {
		return m.RedistributionThreshold
	}
	return 0
}

func (m *OspfShSummary) GetRedistributionLimitWarn() bool {
	if m != nil {
		return m.RedistributionLimitWarn
	}
	return false
}

func (m *OspfShSummary) GetGracefulShutdownRetentionTime() uint32 {
	if m != nil {
		return m.GracefulShutdownRetentionTime
	}
	return 0
}

func (m *OspfShSummary) GetGracefulShutdownState() string {
	if m != nil {
		return m.GracefulShutdownState
	}
	return ""
}

func (m *OspfShSummary) GetDomainId() *OspfShDomainId {
	if m != nil {
		return m.DomainId
	}
	return nil
}

func (m *OspfShSummary) GetTablePrefixLimitReached() bool {
	if m != nil {
		return m.TablePrefixLimitReached
	}
	return false
}

func (m *OspfShSummary) GetNonSelfLsaCount() uint32 {
	if m != nil {
		return m.NonSelfLsaCount
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaEnabled() bool {
	if m != nil {
		return m.MaxLsaEnabled
	}
	return false
}

func (m *OspfShSummary) GetMaxLsaLimit() uint32 {
	if m != nil {
		return m.MaxLsaLimit
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaTreshold() uint32 {
	if m != nil {
		return m.MaxLsaTreshold
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaWarningOnly() bool {
	if m != nil {
		return m.MaxLsaWarningOnly
	}
	return false
}

func (m *OspfShSummary) GetMaxLsaIgnoreTime() uint32 {
	if m != nil {
		return m.MaxLsaIgnoreTime
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaResetTime() uint32 {
	if m != nil {
		return m.MaxLsaResetTime
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaIgnoreLimit() uint32 {
	if m != nil {
		return m.MaxLsaIgnoreLimit
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaIgnoreCount() uint32 {
	if m != nil {
		return m.MaxLsaIgnoreCount
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaIgnoreTimer() uint32 {
	if m != nil {
		return m.MaxLsaIgnoreTimer
	}
	return 0
}

func (m *OspfShSummary) GetMaxLsaResetTimer() uint32 {
	if m != nil {
		return m.MaxLsaResetTimer
	}
	return 0
}

func (m *OspfShSummary) GetContextName() string {
	if m != nil {
		return m.ContextName
	}
	return ""
}

func (m *OspfShSummary) GetSnmpTrapEnabled() bool {
	if m != nil {
		return m.SnmpTrapEnabled
	}
	return false
}

func (m *OspfShSummary) GetUcmp() bool {
	if m != nil {
		return m.Ucmp
	}
	return false
}

func (m *OspfShSummary) GetUcmpPrefixList() string {
	if m != nil {
		return m.UcmpPrefixList
	}
	return ""
}

func (m *OspfShSummary) GetUcmpVariance() int32 {
	if m != nil {
		return m.UcmpVariance
	}
	return 0
}

func (m *OspfShSummary) GetUcmpDelay() uint32 {
	if m != nil {
		return m.UcmpDelay
	}
	return 0
}

func (m *OspfShSummary) GetMicroloopAvoidanceType() string {
	if m != nil {
		return m.MicroloopAvoidanceType
	}
	return ""
}

func (m *OspfShSummary) GetMicroloopAvoidanceDelay() uint32 {
	if m != nil {
		return m.MicroloopAvoidanceDelay
	}
	return 0
}

func (m *OspfShSummary) GetMicroloopAvoidanceActive() bool {
	if m != nil {
		return m.MicroloopAvoidanceActive
	}
	return false
}

func (m *OspfShSummary) GetMicroloopAvoidanceDelayExpiry() uint32 {
	if m != nil {
		return m.MicroloopAvoidanceDelayExpiry
	}
	return 0
}

func (m *OspfShSummary) GetLsdConnected() bool {
	if m != nil {
		return m.LsdConnected
	}
	return false
}

func (m *OspfShSummary) GetLsdRegistered() bool {
	if m != nil {
		return m.LsdRegistered
	}
	return false
}

func (m *OspfShSummary) GetLsdBound() bool {
	if m != nil {
		return m.LsdBound
	}
	return false
}

func (m *OspfShSummary) GetLsdConnectionRevision() uint32 {
	if m != nil {
		return m.LsdConnectionRevision
	}
	return 0
}

func (m *OspfShSummary) GetSrgbConfigured() bool {
	if m != nil {
		return m.SrgbConfigured
	}
	return false
}

func (m *OspfShSummary) GetSrgbStart() uint32 {
	if m != nil {
		return m.SrgbStart
	}
	return 0
}

func (m *OspfShSummary) GetSrgbEnd() uint32 {
	if m != nil {
		return m.SrgbEnd
	}
	return 0
}

func (m *OspfShSummary) GetSrgbStatus() string {
	if m != nil {
		return m.SrgbStatus
	}
	return ""
}

func (m *OspfShSummary) GetSrStrictSpfCap() bool {
	if m != nil {
		return m.SrStrictSpfCap
	}
	return false
}

type OspfShTime struct {
	Second     uint32 `protobuf:"varint,1,opt,name=second" json:"second,omitempty"`
	Nanosecond uint32 `protobuf:"varint,2,opt,name=nanosecond" json:"nanosecond,omitempty"`
}

func (m *OspfShTime) Reset()                    { *m = OspfShTime{} }
func (m *OspfShTime) String() string            { return proto.CompactTextString(m) }
func (*OspfShTime) ProtoMessage()               {}
func (*OspfShTime) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *OspfShTime) GetSecond() uint32 {
	if m != nil {
		return m.Second
	}
	return 0
}

func (m *OspfShTime) GetNanosecond() uint32 {
	if m != nil {
		return m.Nanosecond
	}
	return 0
}

type StringType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *StringType) Reset()                    { *m = StringType{} }
func (m *StringType) String() string            { return proto.CompactTextString(m) }
func (*StringType) ProtoMessage()               {}
func (*StringType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StringType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Redistributed protocol instance
type OspfShRedistProto struct {
	ProtocolType string `protobuf:"bytes,1,opt,name=protocol_type,json=protocolType" json:"protocol_type,omitempty"`
	// ISIS instance identifier
	IsisInstanceId *StringType `protobuf:"bytes,2,opt,name=isis_instance_id,json=isisInstanceId" json:"isis_instance_id,omitempty"`
	// OSPF process identifier
	OspfProcessId *StringType `protobuf:"bytes,3,opt,name=ospf_process_id,json=ospfProcessId" json:"ospf_process_id,omitempty"`
	// BGP Autonomous System Number
	BgpAsNumber *StringType `protobuf:"bytes,4,opt,name=bgp_as_number,json=bgpAsNumber" json:"bgp_as_number,omitempty"`
	// Autonomous System Number
	EigrpAsNumber *StringType `protobuf:"bytes,5,opt,name=eigrp_as_number,json=eigrpAsNumber" json:"eigrp_as_number,omitempty"`
	// Connected instance name
	ConnectedInstance *StringType `protobuf:"bytes,6,opt,name=connected_instance,json=connectedInstance" json:"connected_instance,omitempty"`
}

func (m *OspfShRedistProto) Reset()                    { *m = OspfShRedistProto{} }
func (m *OspfShRedistProto) String() string            { return proto.CompactTextString(m) }
func (*OspfShRedistProto) ProtoMessage()               {}
func (*OspfShRedistProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *OspfShRedistProto) GetProtocolType() string {
	if m != nil {
		return m.ProtocolType
	}
	return ""
}

func (m *OspfShRedistProto) GetIsisInstanceId() *StringType {
	if m != nil {
		return m.IsisInstanceId
	}
	return nil
}

func (m *OspfShRedistProto) GetOspfProcessId() *StringType {
	if m != nil {
		return m.OspfProcessId
	}
	return nil
}

func (m *OspfShRedistProto) GetBgpAsNumber() *StringType {
	if m != nil {
		return m.BgpAsNumber
	}
	return nil
}

func (m *OspfShRedistProto) GetEigrpAsNumber() *StringType {
	if m != nil {
		return m.EigrpAsNumber
	}
	return nil
}

func (m *OspfShRedistProto) GetConnectedInstance() *StringType {
	if m != nil {
		return m.ConnectedInstance
	}
	return nil
}

// OSPF Redistribution Information
type OspfShRedist struct {
	// Protocol Information
	RedistributionProtocol *OspfShRedistProto `protobuf:"bytes,1,opt,name=redistribution_protocol,json=redistributionProtocol" json:"redistribution_protocol,omitempty"`
	// If true, Metric configured
	MetricFlag bool `protobuf:"varint,2,opt,name=metric_flag,json=metricFlag" json:"metric_flag,omitempty"`
	// Route metric
	Metric uint32 `protobuf:"varint,3,opt,name=metric" json:"metric,omitempty"`
	// Whether to use CIDR
	Classless bool `protobuf:"varint,4,opt,name=classless" json:"classless,omitempty"`
	// To NSSA areas only
	NssaOnly bool `protobuf:"varint,5,opt,name=nssa_only,json=nssaOnly" json:"nssa_only,omitempty"`
}

func (m *OspfShRedist) Reset()                    { *m = OspfShRedist{} }
func (m *OspfShRedist) String() string            { return proto.CompactTextString(m) }
func (*OspfShRedist) ProtoMessage()               {}
func (*OspfShRedist) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *OspfShRedist) GetRedistributionProtocol() *OspfShRedistProto {
	if m != nil {
		return m.RedistributionProtocol
	}
	return nil
}

func (m *OspfShRedist) GetMetricFlag() bool {
	if m != nil {
		return m.MetricFlag
	}
	return false
}

func (m *OspfShRedist) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *OspfShRedist) GetClassless() bool {
	if m != nil {
		return m.Classless
	}
	return false
}

func (m *OspfShRedist) GetNssaOnly() bool {
	if m != nil {
		return m.NssaOnly
	}
	return false
}

// OSPF Domain ID
type OspfShDomainIdEntry struct {
	// Domain ID Type
	DomainIdType uint32 `protobuf:"varint,1,opt,name=domain_id_type,json=domainIdType" json:"domain_id_type,omitempty"`
	// Domain ID value
	DomainIdValue []byte `protobuf:"bytes,2,opt,name=domain_id_value,json=domainIdValue,proto3" json:"domain_id_value,omitempty"`
}

func (m *OspfShDomainIdEntry) Reset()                    { *m = OspfShDomainIdEntry{} }
func (m *OspfShDomainIdEntry) String() string            { return proto.CompactTextString(m) }
func (*OspfShDomainIdEntry) ProtoMessage()               {}
func (*OspfShDomainIdEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *OspfShDomainIdEntry) GetDomainIdType() uint32 {
	if m != nil {
		return m.DomainIdType
	}
	return 0
}

func (m *OspfShDomainIdEntry) GetDomainIdValue() []byte {
	if m != nil {
		return m.DomainIdValue
	}
	return nil
}

// OSPF Domain ID entries
type OspfShDomainId struct {
	// Primary Domain ID
	PrimaryDomainId *OspfShDomainIdEntry `protobuf:"bytes,1,opt,name=primary_domain_id,json=primaryDomainId" json:"primary_domain_id,omitempty"`
	// List of secondary domain IDs
	SecondaryDomainIdList []*OspfShDomainIdEntry `protobuf:"bytes,2,rep,name=secondary_domain_id_list,json=secondaryDomainIdList" json:"secondary_domain_id_list,omitempty"`
}

func (m *OspfShDomainId) Reset()                    { *m = OspfShDomainId{} }
func (m *OspfShDomainId) String() string            { return proto.CompactTextString(m) }
func (*OspfShDomainId) ProtoMessage()               {}
func (*OspfShDomainId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *OspfShDomainId) GetPrimaryDomainId() *OspfShDomainIdEntry {
	if m != nil {
		return m.PrimaryDomainId
	}
	return nil
}

func (m *OspfShDomainId) GetSecondaryDomainIdList() []*OspfShDomainIdEntry {
	if m != nil {
		return m.SecondaryDomainIdList
	}
	return nil
}

// OSPF Max-metric Information
type OspfShMaxMetric struct {
	// Max-metric reason
	MaxMetricReason uint32 `protobuf:"varint,1,opt,name=max_metric_reason,json=maxMetricReason" json:"max_metric_reason,omitempty"`
	// Max-metric enabled
	MaxMetricEnabled bool `protobuf:"varint,2,opt,name=max_metric_enabled,json=maxMetricEnabled" json:"max_metric_enabled,omitempty"`
	// If true, BGP is up, no maximum metric Router LSA
	UnsetMaximumMetric bool `protobuf:"varint,3,opt,name=unset_maximum_metric,json=unsetMaximumMetric" json:"unset_maximum_metric,omitempty"`
	// Saved UnsetMaximumMetric
	SavedUnsetMaximumMetric bool `protobuf:"varint,4,opt,name=saved_unset_maximum_metric,json=savedUnsetMaximumMetric" json:"saved_unset_maximum_metric,omitempty"`
	// Time remaining until we will start using normal metrics (s)
	MaximumMetricStartTime uint32 `protobuf:"varint,5,opt,name=maximum_metric_start_time,json=maximumMetricStartTime" json:"maximum_metric_start_time,omitempty"`
	// Hold time configured (s)
	SavedStartupTime uint32 `protobuf:"varint,6,opt,name=saved_startup_time,json=savedStartupTime" json:"saved_startup_time,omitempty"`
	// If true, set max-metric in stub links
	MaximumMetricIncludeStubs bool `protobuf:"varint,7,opt,name=maximum_metric_include_stubs,json=maximumMetricIncludeStubs" json:"maximum_metric_include_stubs,omitempty"`
	// If true, advertise max-metric in summary-LSAs
	MaximumMetricSummaryLsa bool `protobuf:"varint,8,opt,name=maximum_metric_summary_lsa,json=maximumMetricSummaryLsa" json:"maximum_metric_summary_lsa,omitempty"`
	// Max-metric value to advertise in summary-LSAs
	MaximumMetricSummaryLsaMetric uint32 `protobuf:"varint,9,opt,name=maximum_metric_summary_lsa_metric,json=maximumMetricSummaryLsaMetric" json:"maximum_metric_summary_lsa_metric,omitempty"`
	// If true, advertise max-metric in external-LSAs
	MaximumMetricExternalLsa bool `protobuf:"varint,10,opt,name=maximum_metric_external_lsa,json=maximumMetricExternalLsa" json:"maximum_metric_external_lsa,omitempty"`
	// Max-metric value to advertise in external-LSAs
	MaximumMetricExternalLsaMetric uint32 `protobuf:"varint,11,opt,name=maximum_metric_external_lsa_metric,json=maximumMetricExternalLsaMetric" json:"maximum_metric_external_lsa_metric,omitempty"`
	// Time max-metric was used for
	MaximumMetricOriginatedFor uint32 `protobuf:"varint,12,opt,name=maximum_metric_originated_for,json=maximumMetricOriginatedFor" json:"maximum_metric_originated_for,omitempty"`
	// Time max-metric condition was cleared
	MaximumMetricTimeUnset *OspfShTime `protobuf:"bytes,13,opt,name=maximum_metric_time_unset,json=maximumMetricTimeUnset" json:"maximum_metric_time_unset,omitempty"`
	// Max-metric unset reason
	MaximumMetricUnsetReason string `protobuf:"bytes,14,opt,name=maximum_metric_unset_reason,json=maximumMetricUnsetReason" json:"maximum_metric_unset_reason,omitempty"`
}

func (m *OspfShMaxMetric) Reset()                    { *m = OspfShMaxMetric{} }
func (m *OspfShMaxMetric) String() string            { return proto.CompactTextString(m) }
func (*OspfShMaxMetric) ProtoMessage()               {}
func (*OspfShMaxMetric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *OspfShMaxMetric) GetMaxMetricReason() uint32 {
	if m != nil {
		return m.MaxMetricReason
	}
	return 0
}

func (m *OspfShMaxMetric) GetMaxMetricEnabled() bool {
	if m != nil {
		return m.MaxMetricEnabled
	}
	return false
}

func (m *OspfShMaxMetric) GetUnsetMaximumMetric() bool {
	if m != nil {
		return m.UnsetMaximumMetric
	}
	return false
}

func (m *OspfShMaxMetric) GetSavedUnsetMaximumMetric() bool {
	if m != nil {
		return m.SavedUnsetMaximumMetric
	}
	return false
}

func (m *OspfShMaxMetric) GetMaximumMetricStartTime() uint32 {
	if m != nil {
		return m.MaximumMetricStartTime
	}
	return 0
}

func (m *OspfShMaxMetric) GetSavedStartupTime() uint32 {
	if m != nil {
		return m.SavedStartupTime
	}
	return 0
}

func (m *OspfShMaxMetric) GetMaximumMetricIncludeStubs() bool {
	if m != nil {
		return m.MaximumMetricIncludeStubs
	}
	return false
}

func (m *OspfShMaxMetric) GetMaximumMetricSummaryLsa() bool {
	if m != nil {
		return m.MaximumMetricSummaryLsa
	}
	return false
}

func (m *OspfShMaxMetric) GetMaximumMetricSummaryLsaMetric() uint32 {
	if m != nil {
		return m.MaximumMetricSummaryLsaMetric
	}
	return 0
}

func (m *OspfShMaxMetric) GetMaximumMetricExternalLsa() bool {
	if m != nil {
		return m.MaximumMetricExternalLsa
	}
	return false
}

func (m *OspfShMaxMetric) GetMaximumMetricExternalLsaMetric() uint32 {
	if m != nil {
		return m.MaximumMetricExternalLsaMetric
	}
	return 0
}

func (m *OspfShMaxMetric) GetMaximumMetricOriginatedFor() uint32 {
	if m != nil {
		return m.MaximumMetricOriginatedFor
	}
	return 0
}

func (m *OspfShMaxMetric) GetMaximumMetricTimeUnset() *OspfShTime {
	if m != nil {
		return m.MaximumMetricTimeUnset
	}
	return nil
}

func (m *OspfShMaxMetric) GetMaximumMetricUnsetReason() string {
	if m != nil {
		return m.MaximumMetricUnsetReason
	}
	return ""
}

func init() {
	proto.RegisterType((*OspfShSummary_KEYS)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_summary_KEYS")
	proto.RegisterType((*OspfShSummary)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_summary")
	proto.RegisterType((*OspfShTime)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_time")
	proto.RegisterType((*StringType)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.string_type")
	proto.RegisterType((*OspfShRedistProto)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_redist_proto")
	proto.RegisterType((*OspfShRedist)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_redist")
	proto.RegisterType((*OspfShDomainIdEntry)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_domain_id_entry")
	proto.RegisterType((*OspfShDomainId)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_domain_id")
	proto.RegisterType((*OspfShMaxMetric)(nil), "cisco_ios_xr_ipv4_ospf_oper.ospf.processes.process.vrfs.vrf.process_information.process_summary.ospf_sh_max_metric")
}

func init() { proto.RegisterFile("ospf_sh_summary.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2649 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x5b, 0x73, 0x1d, 0xc5,
	0xf1, 0xaf, 0x63, 0xb0, 0x2d, 0x8f, 0xee, 0x63, 0xd9, 0x1e, 0x1b, 0xc3, 0x5f, 0x08, 0xfe, 0x8e,
	0x20, 0x20, 0x88, 0x4d, 0x70, 0xc0, 0x10, 0x22, 0x5f, 0x84, 0x05, 0xb2, 0xe4, 0xec, 0x11, 0x10,
	0x72, 0x9b, 0xcc, 0xd9, 0x9d, 0x3d, 0x1a, 0xd8, 0x33, 0xbb, 0xcc, 0xcc, 0x1e, 0x4b, 0xb9, 0xdf,
	0xef, 0x09, 0x79, 0x48, 0xe5, 0x25, 0x2f, 0xa9, 0x4a, 0x1e, 0xf2, 0x94, 0xaa, 0x54, 0x2a, 0x5f,
	0x21, 0x5f, 0x25, 0x6f, 0xf9, 0x0c, 0xa9, 0xee, 0xde, 0xdd, 0x73, 0x75, 0xde, 0xb0, 0x5f, 0x6c,
	0x9d, 0xee, 0x5f, 0x77, 0xff, 0xb6, 0xb7, 0xa7, 0xa7, 0x67, 0x96, 0x9d, 0xc9, 0x7d, 0x91, 0x4a,
	0x7f, 0x20, 0x7d, 0xd9, 0xeb, 0x29, 0x77, 0xb4, 0x51, 0xb8, 0x3c, 0xe4, 0x5c, 0xc6, 0xc6, 0xc7,
	0xb9, 0x34, 0xb9, 0x97, 0x87, 0x4e, 0x9a, 0xa2, 0xff, 0x92, 0x44, 0x60, 0x5e, 0x68, 0xb7, 0x01,
	0x7f, 0x01, 0x2e, 0xd6, 0xde, 0x6b, 0x5f, 0xff, 0xb5, 0xd1, 0x77, 0x29, 0xfe, 0x53, 0x0b, 0xa4,
	0xb1, 0x69, 0xee, 0x7a, 0x2a, 0x98, 0xdc, 0x36, 0xb2, 0x2a, 0xcc, 0xda, 0x3e, 0x5b, 0x19, 0x8b,
	0x2c, 0xdf, 0xbe, 0xf5, 0x7e, 0x9b, 0x3f, 0xc9, 0xe6, 0x6a, 0xa8, 0x55, 0x3d, 0x2d, 0x5a, 0xab,
	0xad, 0xf5, 0x53, 0xd1, 0x6c, 0x25, 0xdb, 0x55, 0x3d, 0xcd, 0xcf, 0xb3, 0x99, 0xbe, 0x4b, 0x49,
	0x7d, 0x0c, 0xd5, 0x27, 0xfb, 0x2e, 0x05, 0xd5, 0xda, 0xbf, 0x9f, 0x66, 0x8b, 0x63, 0x6e, 0xc1,
	0xa3, 0xcb, 0x33, 0x2d, 0x7d, 0x50, 0x36, 0xe9, 0x1c, 0x89, 0xcb, 0xab, 0xad, 0xf5, 0x99, 0x68,
	0x16, 0x64, 0x6d, 0x12, 0x71, 0xce, 0x1e, 0x85, 0x9f, 0xe2, 0xca, 0x6a, 0x6b, 0x7d, 0x3e, 0xc2,
	0xbf, 0xf9, 0xff, 0xb1, 0x59, 0xeb, 0x9d, 0xd4, 0x56, 0x75, 0x32, 0x9d, 0x88, 0x97, 0xd0, 0x8a,
	0x59, 0xef, 0x6e, 0x91, 0x84, 0xbf, 0xc2, 0xce, 0x03, 0xc0, 0xdf, 0x33, 0x21, 0x3e, 0xc8, 0xfb,
	0xda, 0xc9, 0xdc, 0x4a, 0xa7, 0x7d, 0x50, 0x2e, 0x88, 0xcf, 0x22, 0xfc, 0xac, 0xf5, 0xae, 0xdd,
	0xe8, 0xf7, 0x6c, 0x44, 0x5a, 0xbe, 0xc6, 0xe6, 0x4d, 0xb7, 0x90, 0xc6, 0x06, 0x15, 0x07, 0x99,
	0x5b, 0xf1, 0x32, 0x71, 0x32, 0xdd, 0x62, 0x1b, 0x65, 0x7b, 0x96, 0x3f, 0xc6, 0x4e, 0xb9, 0xbc,
	0x0c, 0xda, 0x49, 0x93, 0x88, 0xab, 0xf8, 0x98, 0x33, 0x24, 0xd8, 0x4e, 0x80, 0x5c, 0xc8, 0xbd,
	0xcc, 0x0b, 0xc8, 0xad, 0x17, 0x9f, 0x43, 0xde, 0x2c, 0xe4, 0x7e, 0x8f, 0x24, 0xfc, 0xff, 0xd9,
	0x42, 0x5e, 0xa8, 0x8f, 0x4a, 0x2d, 0x63, 0x55, 0x00, 0x5f, 0xf1, 0x0a, 0x86, 0x98, 0x27, 0xe9,
	0x0d, 0x12, 0xf2, 0xe7, 0x18, 0x57, 0x4e, 0x2b, 0xd9, 0xc9, 0x5d, 0xa2, 0x9d, 0x24, 0xff, 0xe2,
	0x55, 0x84, 0x2e, 0x81, 0xe6, 0x3a, 0x2a, 0x22, 0x94, 0xf3, 0x75, 0xb6, 0xa4, 0xfc, 0x18, 0xf6,
	0x1a, 0x62, 0x17, 0x94, 0x1f, 0x47, 0xc2, 0x2b, 0xca, 0x4c, 0xd0, 0x4d, 0x06, 0x5f, 0x23, 0x64,
	0xdf, 0xa5, 0x3b, 0x26, 0xe8, 0x3a, 0x8b, 0x2f, 0xb2, 0x95, 0x9e, 0x3a, 0x34, 0xbd, 0xb2, 0x27,
	0x7b, 0x3a, 0x38, 0x13, 0x4b, 0x4a, 0xe0, 0xeb, 0x88, 0xe6, 0x95, 0xee, 0x0e, 0xaa, 0xda, 0x98,
	0xbc, 0x6b, 0xec, 0xc2, 0x34, 0x0b, 0x19, 0x4c, 0x4f, 0x3b, 0xf1, 0x79, 0x4c, 0xc5, 0xb9, 0x49,
	0xbb, 0x7d, 0x50, 0xc3, 0x4b, 0x1b, 0x37, 0xd6, 0x41, 0x3a, 0xad, 0x7c, 0x6e, 0xc5, 0x1b, 0x98,
	0xe5, 0xb3, 0xa3, 0xb6, 0x3a, 0x44, 0xa8, 0xe5, 0xaf, 0xb1, 0xc7, 0xc6, 0x4c, 0x55, 0xc7, 0xc9,
	0x3c, 0x4d, 0x65, 0x2f, 0x4f, 0xb4, 0xf8, 0x02, 0x12, 0x1e, 0x0d, 0xbc, 0xd9, 0x71, 0x7b, 0x69,
	0x7a, 0x27, 0x4f, 0x34, 0xbf, 0xce, 0x9e, 0xb8, 0x8f, 0x35, 0x05, 0xf7, 0x62, 0x13, 0xa3, 0x5f,
	0x98, 0xe2, 0x80, 0x08, 0x78, 0xbe, 0xcd, 0xd6, 0xee, 0xe3, 0xa3, 0x53, 0xa6, 0xa9, 0x76, 0x98,
	0x02, 0x71, 0x1d, 0x33, 0xf0, 0xf8, 0x14, 0x3f, 0xd7, 0x11, 0x05, 0x89, 0xe0, 0x7f, 0x6e, 0xb1,
	0xd3, 0x63, 0xbe, 0x32, 0xe3, 0x83, 0xb8, 0xb1, 0xfa, 0xc8, 0xfa, 0xec, 0x65, 0xbf, 0xf1, 0x09,
	0x2f, 0xff, 0x8d, 0x7a, 0x91, 0xf6, 0xd4, 0x61, 0x15, 0x3f, 0x5a, 0x1e, 0x61, 0xbc, 0x63, 0x7c,
	0xe0, 0x7f, 0x6a, 0xb1, 0xd3, 0x4e, 0x27, 0xc6, 0x07, 0x67, 0x3a, 0x25, 0x38, 0x22, 0x96, 0x37,
	0x91, 0x65, 0xfe, 0xc0, 0x58, 0x12, 0x87, 0x88, 0x8f, 0x72, 0x41, 0x8a, 0x4f, 0xb3, 0x05, 0x04,
	0x35, 0x25, 0x28, 0x6e, 0x61, 0xfe, 0xe7, 0x7c, 0x91, 0x36, 0x75, 0x07, 0x0b, 0x1e, 0x50, 0x07,
	0x79, 0x96, 0x10, 0x68, 0x0b, 0x41, 0xb3, 0xbe, 0x48, 0x6f, 0xe7, 0x59, 0x82, 0x98, 0x75, 0xb6,
	0x04, 0x98, 0xfa, 0xad, 0x20, 0xec, 0x4d, 0x84, 0x41, 0x84, 0x3b, 0x24, 0x46, 0xe4, 0xa7, 0x19,
	0x1f, 0x8d, 0x29, 0xcb, 0x2b, 0x97, 0xc5, 0x6d, 0xc4, 0x2e, 0x0e, 0xc7, 0x7d, 0xe7, 0xca, 0x65,
	0xfe, 0x0c, 0x5b, 0x1e, 0x09, 0x8d, 0xd8, 0xed, 0xc6, 0x6f, 0x1d, 0x1e, 0xa0, 0x2f, 0xb0, 0x95,
	0x71, 0x06, 0x88, 0x7e, 0x0b, 0xd1, 0xcb, 0xa3, 0x2c, 0xc0, 0x60, 0x83, 0x9d, 0x06, 0x83, 0xc2,
	0xe9, 0xd4, 0x1c, 0xca, 0xc2, 0x99, 0xdc, 0x99, 0x70, 0x24, 0xde, 0xc6, 0xa5, 0x00, 0xf8, 0xbb,
	0xa8, 0xb9, 0x5b, 0x29, 0xf8, 0x16, 0x5b, 0x9d, 0x82, 0xa7, 0x56, 0x22, 0x8b, 0x3c, 0x33, 0xf1,
	0x91, 0xd8, 0xc1, 0x65, 0x70, 0x71, 0xc2, 0x18, 0x3b, 0xcb, 0x5d, 0xc4, 0x40, 0xd2, 0x33, 0xaf,
	0x86, 0x93, 0x7e, 0x67, 0xb5, 0xb5, 0xbe, 0x1c, 0xcd, 0x65, 0x5e, 0x8d, 0x24, 0x1d, 0x50, 0x83,
	0xa4, 0xef, 0x52, 0xd2, 0x33, 0xaf, 0x86, 0x93, 0x0e, 0x98, 0x91, 0xa4, 0xef, 0x51, 0x72, 0x32,
	0xaf, 0x86, 0x93, 0x0e, 0x8d, 0xca, 0x58, 0x44, 0x81, 0x85, 0xb1, 0x41, 0xbb, 0xbe, 0xca, 0xc4,
	0x5d, 0x44, 0xf3, 0x4a, 0xb7, 0xe3, 0xd5, 0x76, 0xa5, 0xe1, 0x57, 0x99, 0x98, 0x66, 0x81, 0x29,
	0xfd, 0x22, 0x5a, 0x9d, 0x99, 0xb4, 0x82, 0xb4, 0xbe, 0xc8, 0x56, 0xc0, 0xc0, 0xe9, 0xd4, 0x69,
	0x7f, 0x30, 0x08, 0x15, 0x51, 0xa8, 0xcc, 0xab, 0x88, 0x54, 0x4d, 0xa8, 0x37, 0xd8, 0xc5, 0xe1,
	0x50, 0xca, 0x39, 0x03, 0x91, 0x1a, 0xcb, 0x36, 0x5a, 0x9e, 0x1f, 0x84, 0xdb, 0x24, 0x44, 0xe3,
	0x60, 0x8b, 0xad, 0xfe, 0x2f, 0x07, 0xc8, 0x79, 0x1f, 0x9d, 0x5c, 0xbc, 0xaf, 0x13, 0xa0, 0x7e,
	0x95, 0x09, 0x93, 0xca, 0x34, 0xcb, 0xf3, 0x44, 0x16, 0x2a, 0x36, 0xb6, 0x3b, 0x20, 0xf1, 0x0e,
	0x3d, 0xb3, 0x49, 0xb7, 0x40, 0x7d, 0x17, 0xb5, 0x0d, 0x81, 0x6b, 0xec, 0x82, 0x81, 0x5e, 0x18,
	0x9c, 0xb2, 0x7e, 0xc2, 0xf4, 0x5d, 0xea, 0xea, 0x26, 0x8d, 0x08, 0x30, 0x66, 0xfc, 0x22, 0x3b,
	0xa3, 0x92, 0x0f, 0xa0, 0x1e, 0xc0, 0xc6, 0x04, 0x69, 0xcb, 0x9e, 0xb4, 0x1d, 0x27, 0xde, 0xa3,
	0xca, 0x55, 0xc9, 0x07, 0xed, 0xa0, 0xba, 0xdb, 0xd6, 0x84, 0xdd, 0xb2, 0xb7, 0xdb, 0x71, 0x7c,
	0x83, 0xad, 0x34, 0x16, 0xd0, 0x83, 0x6a, 0x83, 0x2f, 0xa1, 0xc1, 0x52, 0x65, 0x70, 0x47, 0x1d,
	0x36, 0xf8, 0xd3, 0x35, 0xbe, 0xab, 0x07, 0x53, 0xc1, 0xfb, 0x54, 0xe9, 0x15, 0xbc, 0xab, 0x9b,
	0xe1, 0xe0, 0x65, 0x26, 0x1a, 0xff, 0x95, 0x6f, 0x09, 0x7d, 0xc6, 0xd8, 0xae, 0xf8, 0x32, 0xc6,
	0x58, 0xa9, 0x8c, 0x28, 0xc0, 0x16, 0xe9, 0xa0, 0x1e, 0x6d, 0xd9, 0xeb, 0x68, 0x07, 0x16, 0x5e,
	0xa6, 0x65, 0x96, 0x89, 0xaf, 0x50, 0x3d, 0x92, 0x7c, 0xb7, 0xe3, 0xfc, 0x56, 0x99, 0x65, 0x7c,
	0x95, 0xcd, 0x29, 0x8f, 0x2f, 0x2b, 0xce, 0x4b, 0x1b, 0xc4, 0x57, 0x69, 0x06, 0x50, 0x7e, 0xc7,
	0xab, 0x1b, 0x20, 0xe1, 0x97, 0xd8, 0x62, 0x8d, 0x38, 0xd0, 0xf1, 0x87, 0xbe, 0xec, 0x89, 0xaf,
	0x21, 0x68, 0x9e, 0x40, 0x95, 0x10, 0x62, 0x56, 0xb3, 0xc2, 0xc0, 0xdb, 0xd7, 0x29, 0x26, 0xc9,
	0x1b, 0x8f, 0x1b, 0xec, 0xf4, 0x30, 0xb2, 0xf6, 0x2a, 0x29, 0xcb, 0x03, 0x70, 0xed, 0xf9, 0x25,
	0x76, 0x4e, 0x79, 0x99, 0xc4, 0xb2, 0x63, 0x42, 0x06, 0x8d, 0x75, 0x10, 0xe0, 0x1b, 0x68, 0x73,
	0x5a, 0xf9, 0x9b, 0xf1, 0x75, 0x52, 0x36, 0x51, 0x3e, 0x85, 0x63, 0x46, 0x62, 0xd5, 0x10, 0x5c,
	0xd5, 0xc4, 0x6f, 0x5a, 0xd5, 0x00, 0x1f, 0x67, 0x0c, 0xa7, 0x17, 0x82, 0x74, 0x10, 0x72, 0x0a,
	0x24, 0xa4, 0x7e, 0x96, 0x2d, 0x5b, 0x68, 0xed, 0x99, 0x1c, 0x42, 0xc5, 0xd4, 0x25, 0x49, 0xb1,
	0xd9, 0x60, 0x2f, 0xb1, 0x45, 0x1f, 0xca, 0xce, 0x30, 0x32, 0xa1, 0x90, 0x20, 0x1e, 0xc1, 0x59,
	0x8f, 0x0b, 0xa4, 0xc1, 0x69, 0xc2, 0x81, 0x78, 0x80, 0x7b, 0x9e, 0xd5, 0xa3, 0x0b, 0x15, 0x71,
	0xaa, 0x62, 0xed, 0x45, 0x4a, 0x89, 0xaa, 0x34, 0xdb, 0x8d, 0x02, 0xcb, 0x85, 0xb2, 0x43, 0x4b,
	0x07, 0x76, 0x39, 0x99, 0x69, 0xdb, 0x0d, 0x07, 0xa2, 0x5b, 0x95, 0x0b, 0x24, 0x08, 0x57, 0x0e,
	0xec, 0x3b, 0x3b, 0xa8, 0xa3, 0x21, 0x35, 0x6d, 0xca, 0xf1, 0xa0, 0x1e, 0x52, 0xd3, 0xba, 0x0e,
	0xa1, 0x07, 0x2a, 0x1f, 0x24, 0xa0, 0xb0, 0xb9, 0x99, 0xaa, 0x07, 0x2a, 0x1f, 0x76, 0x7d, 0x8a,
	0x9d, 0xed, 0x3c, 0x9b, 0x69, 0xd4, 0x1f, 0xa0, 0xfa, 0xa4, 0xad, 0x54, 0x9f, 0x61, 0x2b, 0x13,
	0xfb, 0x6f, 0xcf, 0x04, 0xf1, 0x21, 0xbd, 0xbd, 0xf1, 0xfd, 0xb0, 0x67, 0x02, 0x7f, 0x85, 0x89,
	0x31, 0x93, 0x70, 0x00, 0xbd, 0x2a, 0xcf, 0x12, 0x91, 0xd1, 0x32, 0x1e, 0xd5, 0xef, 0xd7, 0x6a,
	0xfe, 0x2a, 0x3b, 0x3f, 0x2d, 0x9a, 0xbc, 0xa7, 0x9c, 0x15, 0x3d, 0x9a, 0xaf, 0xa6, 0x84, 0x7c,
	0x4f, 0x39, 0xcb, 0xdf, 0x64, 0xab, 0x5d, 0xa7, 0x62, 0x9d, 0x96, 0x99, 0xf4, 0x07, 0x65, 0x48,
	0xf2, 0x7b, 0x30, 0x8d, 0x07, 0x6d, 0x89, 0x03, 0x3c, 0x9c, 0xa5, 0xc9, 0xa8, 0xc6, 0xb5, 0x2b,
	0x58, 0x54, 0xa3, 0xf0, 0x91, 0x5f, 0x66, 0xe7, 0x26, 0x1d, 0xf9, 0xa0, 0x82, 0x16, 0x39, 0x6e,
	0x4d, 0x67, 0xc6, 0xed, 0xdb, 0xa0, 0xe4, 0x1f, 0xb7, 0xd8, 0xa9, 0x24, 0xef, 0x29, 0x63, 0x61,
	0x60, 0x2f, 0x56, 0x5b, 0xeb, 0xb3, 0x97, 0xdd, 0x03, 0x9b, 0x50, 0x9a, 0xc8, 0xd1, 0x0c, 0xfd,
	0xb9, 0x9d, 0x40, 0x4b, 0x0d, 0x50, 0x05, 0xf5, 0x7e, 0x4b, 0xc9, 0x74, 0x5a, 0xc5, 0x07, 0x3a,
	0x11, 0x1f, 0x51, 0x3e, 0x11, 0x41, 0x3b, 0x2d, 0x26, 0x33, 0x22, 0x35, 0xcc, 0x18, 0x36, 0xb7,
	0xd2, 0xeb, 0x2c, 0x1d, 0x5a, 0x86, 0xae, 0x5e, 0x3d, 0xb6, 0xad, 0xb3, 0x74, 0xb8, 0xd3, 0x40,
	0x13, 0x05, 0x5c, 0x5d, 0x8a, 0x9e, 0x8e, 0x1b, 0x3d, 0x75, 0xb8, 0xe3, 0xd5, 0x50, 0x35, 0xd6,
	0x38, 0xaa, 0xa3, 0x40, 0xd5, 0x48, 0x28, 0xaa, 0x9f, 0x75, 0xb6, 0x54, 0x63, 0x42, 0x5d, 0x37,
	0x25, 0x75, 0x23, 0x82, 0xed, 0xd7, 0xe5, 0xf2, 0x02, 0x1e, 0x1d, 0x10, 0x09, 0x15, 0x02, 0x1b,
	0x46, 0x6e, 0xb3, 0x23, 0xd1, 0xa7, 0xa6, 0x4c, 0xe8, 0xf7, 0x48, 0xb3, 0x67, 0xb3, 0x23, 0xfe,
	0x3c, 0xce, 0xbc, 0xb4, 0x19, 0x77, 0x6d, 0xee, 0x34, 0x95, 0xc5, 0x3d, 0xea, 0xf9, 0x84, 0xdf,
	0x46, 0x45, 0x3d, 0x66, 0xd5, 0x70, 0xa7, 0xe1, 0x98, 0x80, 0xe8, 0x43, 0x4a, 0x01, 0xa1, 0x23,
	0x90, 0x23, 0x78, 0x88, 0x4c, 0xe5, 0x9b, 0x9e, 0xf0, 0xa8, 0x59, 0xf2, 0x8d, 0x73, 0x7a, 0xce,
	0x49, 0x03, 0x4a, 0xf1, 0x37, 0x27, 0x0d, 0x28, 0xc9, 0x93, 0x06, 0x74, 0xe2, 0xf9, 0xd6, 0xa4,
	0x01, 0x9d, 0x75, 0x86, 0x1e, 0x77, 0xc0, 0xdf, 0x89, 0x6f, 0x0f, 0x3f, 0x6e, 0xf3, 0x00, 0x0e,
	0xce, 0xc9, 0x71, 0x6e, 0x83, 0x3e, 0x0c, 0x74, 0xb4, 0xfe, 0x0e, 0x9d, 0xbc, 0x2b, 0x19, 0x9e,
	0xbc, 0x9f, 0x65, 0xcb, 0xde, 0xf6, 0x0a, 0x19, 0x9c, 0x2a, 0x9a, 0x37, 0xfd, 0x5d, 0x4c, 0xf7,
	0x22, 0x28, 0xf6, 0x9d, 0x2a, 0xea, 0x77, 0xcd, 0xd9, 0xa3, 0x65, 0xdc, 0x2b, 0xc4, 0xf7, 0x50,
	0x8d, 0x7f, 0xf3, 0x67, 0xd8, 0x12, 0xfc, 0x3f, 0x28, 0x48, 0x1f, 0xc4, 0xf7, 0xe9, 0x84, 0xbf,
	0x00, 0x8a, 0xba, 0x0e, 0x71, 0xae, 0x9e, 0x47, 0x68, 0x5f, 0x39, 0xa3, 0x6c, 0xac, 0xc5, 0x0f,
	0x5a, 0x34, 0xe2, 0x81, 0xf4, 0xdd, 0x4a, 0xc8, 0x9f, 0x60, 0x0c, 0x51, 0x89, 0xce, 0xd4, 0x91,
	0xf8, 0x61, 0x8b, 0xb6, 0x00, 0x10, 0xdd, 0x04, 0x09, 0x34, 0xa3, 0x9e, 0x89, 0x5d, 0x9e, 0xe5,
	0x79, 0x21, 0x55, 0x3f, 0x37, 0x09, 0x98, 0xc9, 0x70, 0x54, 0x68, 0xf1, 0xa3, 0x56, 0x75, 0xdc,
	0xab, 0x01, 0x9b, 0xb5, 0x7e, 0xff, 0xa8, 0xd0, 0xfc, 0x1a, 0x3b, 0x3f, 0xcd, 0x94, 0x22, 0xfd,
	0xb8, 0x55, 0x1d, 0x33, 0x27, 0x6c, 0x29, 0xee, 0xeb, 0xec, 0xc2, 0x34, 0x63, 0x15, 0x07, 0xd3,
	0xd7, 0xe2, 0x27, 0x2d, 0xcc, 0x89, 0x98, 0xb4, 0xde, 0x44, 0x00, 0xbf, 0x0d, 0xd3, 0xd8, 0x7d,
	0x62, 0x4b, 0x7d, 0x58, 0x18, 0x77, 0x24, 0x7e, 0xda, 0xaa, 0xce, 0x79, 0xd3, 0x29, 0xdc, 0x42,
	0x14, 0xa4, 0x31, 0xf3, 0x89, 0x8c, 0x73, 0x6b, 0x75, 0x1c, 0x74, 0x22, 0x7e, 0x46, 0xb1, 0xe7,
	0x32, 0x9f, 0xdc, 0xa8, 0x85, 0xfc, 0x12, 0xcc, 0xd3, 0x89, 0x74, 0xba, 0x6b, 0x7c, 0xd0, 0x4e,
	0x27, 0xe2, 0xe7, 0x04, 0x03, 0xe3, 0xa8, 0x91, 0xf2, 0x8b, 0xec, 0x14, 0xe0, 0x3a, 0x79, 0x69,
	0x13, 0xf1, 0x0b, 0x82, 0xcc, 0x64, 0x3e, 0xb9, 0x0e, 0x02, 0x7e, 0x95, 0x9d, 0x1b, 0x8a, 0x65,
	0xf0, 0x36, 0xa4, 0x6f, 0xbc, 0xc9, 0xad, 0xf8, 0x25, 0x91, 0x3d, 0x33, 0x88, 0x6a, 0x72, 0x1b,
	0x55, 0x5a, 0xbe, 0xce, 0x16, 0xbd, 0xeb, 0x76, 0xc0, 0x32, 0x35, 0xdd, 0x12, 0xe2, 0xff, 0x8a,
	0x9c, 0x2f, 0x80, 0xfc, 0x46, 0x23, 0x86, 0xf7, 0x8d, 0x48, 0xba, 0x23, 0xf8, 0x75, 0xf5, 0xbe,
	0x41, 0x44, 0x77, 0x03, 0x17, 0xd8, 0x0c, 0xea, 0xb5, 0x4d, 0xc4, 0x6f, 0x48, 0x7b, 0x12, 0x04,
	0xb7, 0x6c, 0xc2, 0x57, 0xd9, 0x6c, 0x6d, 0x1b, 0x4a, 0x2f, 0x7e, 0x4b, 0xaf, 0x9f, 0x55, 0xc6,
	0xa1, 0xf4, 0x58, 0xde, 0x4e, 0xc2, 0xee, 0x12, 0x07, 0x09, 0x8d, 0x35, 0x56, 0x85, 0xf8, 0xb8,
	0x61, 0xd2, 0x46, 0x45, 0xbb, 0x48, 0x6f, 0xa8, 0x62, 0x6d, 0x8b, 0xcd, 0xd5, 0xbd, 0x17, 0x96,
	0x15, 0x3f, 0xcb, 0x4e, 0x78, 0x1d, 0xe7, 0x36, 0x11, 0x14, 0xb6, 0xfa, 0x05, 0x8c, 0xad, 0xb2,
	0x79, 0xa5, 0x3b, 0x46, 0x43, 0xda, 0x40, 0xb2, 0xf6, 0x14, 0x9b, 0x85, 0x80, 0xb6, 0x8b, 0x45,
	0xc9, 0x57, 0xd8, 0xf1, 0xbe, 0xca, 0xca, 0xfa, 0xde, 0x8b, 0x7e, 0xac, 0xfd, 0xe3, 0xc4, 0xe0,
	0xb6, 0x8c, 0x36, 0x40, 0x49, 0xd7, 0x74, 0x4f, 0xb1, 0x79, 0xfc, 0x23, 0xce, 0x33, 0x2a, 0x6a,
	0x32, 0x9b, 0xab, 0x85, 0x58, 0xc9, 0x7f, 0x68, 0xb1, 0x25, 0xe3, 0x0d, 0x6c, 0x24, 0x3e, 0x60,
	0x21, 0x19, 0x62, 0x32, 0x7b, 0x39, 0xfb, 0xc4, 0x37, 0xa8, 0xa1, 0x87, 0x8b, 0x16, 0x80, 0xc5,
	0x76, 0x45, 0x62, 0x3b, 0xe1, 0xbf, 0x6f, 0x55, 0xb7, 0x75, 0x8d, 0xa3, 0x44, 0x3c, 0xf2, 0x10,
	0x78, 0xcd, 0xe7, 0x78, 0xda, 0x44, 0xc0, 0x76, 0xc2, 0x7f, 0xd7, 0x62, 0xf3, 0x9d, 0x6e, 0x21,
	0x95, 0x97, 0x34, 0x73, 0x8b, 0x47, 0x1f, 0x02, 0xa9, 0xd9, 0x4e, 0xb7, 0xd8, 0xf4, 0xbb, 0x48,
	0x00, 0x33, 0xa5, 0x4d, 0xd7, 0x0d, 0x93, 0x3a, 0xfe, 0x30, 0x32, 0x85, 0x24, 0x1a, 0x5a, 0x7f,
	0x6c, 0x31, 0xde, 0xb4, 0x96, 0xa6, 0xbc, 0xc4, 0x89, 0x87, 0xc0, 0x6c, 0xb9, 0xe1, 0x51, 0x17,
	0xd8, 0xda, 0x3f, 0x8f, 0xb1, 0x85, 0xd1, 0x55, 0xc3, 0xff, 0xd6, 0x62, 0x63, 0x13, 0xa4, 0xac,
	0x97, 0x0a, 0x2e, 0x9d, 0xd9, 0xcb, 0xe5, 0x03, 0xbe, 0x54, 0xa2, 0xf8, 0xd1, 0xd9, 0x51, 0x56,
	0x77, 0x2b, 0x52, 0x30, 0xe0, 0x57, 0xd7, 0x73, 0x69, 0xa6, 0xba, 0xb8, 0x6a, 0x67, 0x22, 0x46,
	0xa2, 0xad, 0x4c, 0x75, 0xa1, 0xef, 0xd0, 0x2f, 0x5c, 0x39, 0xf3, 0x51, 0xf5, 0x0b, 0x5a, 0x75,
	0x9c, 0x29, 0xef, 0xe1, 0x64, 0x85, 0xf5, 0x3b, 0x13, 0x0d, 0x04, 0xfc, 0x31, 0x76, 0x0a, 0x8f,
	0x31, 0x38, 0x2f, 0x1d, 0xa7, 0x3e, 0x0e, 0x02, 0x18, 0x93, 0xd6, 0xba, 0xec, 0xdc, 0xc4, 0x58,
	0x29, 0xb5, 0x0d, 0xb8, 0x9d, 0x2c, 0x0c, 0x44, 0x4d, 0xc3, 0x99, 0x8f, 0xe6, 0xea, 0xa1, 0x13,
	0x1b, 0xce, 0x25, 0xb6, 0x38, 0x40, 0x51, 0x3b, 0x03, 0xe2, 0x73, 0xd1, 0x7c, 0x0d, 0x7b, 0x17,
	0xdb, 0xda, 0x7f, 0x8e, 0xb1, 0xe5, 0x89, 0x48, 0xfc, 0x2f, 0x2d, 0xb6, 0x5c, 0x38, 0x83, 0x9f,
	0x04, 0x06, 0x03, 0x35, 0xbd, 0x9d, 0xc3, 0x07, 0x3f, 0x50, 0xd3, 0x93, 0x47, 0x8b, 0x15, 0xa5,
	0x9b, 0xf5, 0x74, 0xfd, 0xf7, 0x16, 0x13, 0xd4, 0xc3, 0x47, 0x88, 0xd2, 0x50, 0x73, 0x0c, 0x2f,
	0x28, 0x1f, 0x1e, 0xdb, 0x33, 0x0d, 0xb3, 0x9a, 0x2f, 0x0c, 0x55, 0x6b, 0xff, 0x3a, 0xc9, 0xf8,
	0xe4, 0xcd, 0x2b, 0xec, 0x7b, 0x83, 0x5f, 0xf5, 0x65, 0x78, 0xab, 0x99, 0x73, 0xe9, 0x42, 0xb6,
	0xba, 0x05, 0x7f, 0x8e, 0x86, 0xe2, 0x0a, 0x5b, 0xcf, 0x80, 0x54, 0x97, 0x4b, 0x0d, 0x78, 0xe8,
	0x76, 0xbf, 0xb4, 0x30, 0x7a, 0x8e, 0xde, 0x35, 0x63, 0xad, 0xce, 0x44, 0x1c, 0x75, 0x77, 0x86,
	0xaf, 0x7d, 0xe1, 0xd0, 0xe2, 0x55, 0x5f, 0x27, 0x72, 0xaa, 0x1d, 0x15, 0xf2, 0x39, 0x44, 0xbc,
	0x33, 0x69, 0x3c, 0xe5, 0x76, 0x7f, 0x70, 0x45, 0x78, 0x1c, 0x1f, 0xe8, 0xec, 0xf4, 0x2f, 0x03,
	0xf0, 0x5c, 0x14, 0x17, 0x2d, 0xca, 0x82, 0x6c, 0x4e, 0xd0, 0xac, 0x8c, 0x9a, 0x36, 0x29, 0x10,
	0xfd, 0x06, 0xbb, 0x38, 0x16, 0xc8, 0xd8, 0x38, 0x2b, 0x13, 0x2d, 0x7d, 0x28, 0x3b, 0x5e, 0x9c,
	0x44, 0x9e, 0xe7, 0x47, 0x62, 0x6d, 0x13, 0xa2, 0x0d, 0x80, 0x69, 0x1f, 0x31, 0xaa, 0xaf, 0x60,
	0x99, 0x57, 0x62, 0x66, 0xca, 0xb7, 0x84, 0x36, 0xe9, 0x77, 0xbc, 0xe2, 0xb7, 0xd9, 0x93, 0xf7,
	0x37, 0xae, 0x53, 0x75, 0x6a, 0xca, 0x67, 0x80, 0x81, 0x8f, 0x2a, 0x61, 0xaf, 0x4f, 0x7c, 0xd3,
	0xd0, 0x87, 0x41, 0x3b, 0xab, 0x32, 0xe4, 0xc1, 0xaa, 0x39, 0x75, 0xd8, 0xc7, 0xad, 0x0a, 0x00,
	0x44, 0xde, 0x9a, 0xf8, 0x20, 0x31, 0x6c, 0x5e, 0x33, 0x99, 0x45, 0x26, 0x4f, 0xdc, 0xcf, 0x4b,
	0x45, 0x65, 0x93, 0x3d, 0x3e, 0xe6, 0x2b, 0x77, 0xa6, 0x6b, 0xac, 0x82, 0xad, 0x25, 0xcd, 0x9d,
	0x98, 0x43, 0x37, 0xa3, 0xdf, 0x47, 0xf6, 0x1a, 0xc8, 0x56, 0xee, 0xf8, 0x5f, 0x5b, 0x13, 0xef,
	0x9f, 0xee, 0xb0, 0xa1, 0x52, 0xc4, 0x3c, 0x76, 0x90, 0xde, 0x03, 0x5b, 0x93, 0x10, 0x7a, 0xac,
	0xdc, 0xf0, 0xde, 0x1c, 0xc8, 0x4c, 0x49, 0x3c, 0xd5, 0x7b, 0xb5, 0xf8, 0x16, 0x70, 0x8c, 0x1b,
	0x4d, 0x3c, 0x1a, 0xd2, 0x2a, 0xec, 0x9c, 0xc0, 0x5d, 0xe3, 0xca, 0x7f, 0x03, 0x00, 0x00, 0xff,
	0xff, 0xd1, 0x43, 0xe5, 0x93, 0xbe, 0x1d, 0x00, 0x00,
}
