// Code generated by protoc-gen-go.
// source: bgp_nexthop_bag.proto
// DO NOT EDIT!

/*
Package cisco_ios_xr_ipv4_bgp_oper_bgp_instances_instance_instance_active_vrfs_vrf_afs_af_next_hop_address_families_next_hop_address_family_next_hop_afs_next_hop_af is a generated protocol buffer package.

It is generated from these files:
	bgp_nexthop_bag.proto

It has these top-level messages:
	BgpNexthopBag_KEYS
	BgpNexthopBag
	IPV4TunnelAddressType
	IPV4MDTAddressType
	RTConstraintAddressType
	IPV6AddressType
	BgpIpv4SrpolicyAddrT
	BgpIpv6SrpolicyAddrT
	BgpL2VpnAddrT
	L2VPNEVPNAddressType
	BgpL2VpnMspwAddrT
	IPV6MVPNAddressType
	IPV4MVPNAddressType
	LS_LSAddressType
	IPv4FlowspecAddressType
	IPv6FlowspecAddressType
	BgpAddrtype
	BgpTeTunnel
	BgpIntNhGw_
	BgpIntNh_
	BgpNexthopGwInfo_
*/
package cisco_ios_xr_ipv4_bgp_oper_bgp_instances_instance_instance_active_vrfs_vrf_afs_af_next_hop_address_families_next_hop_address_family_next_hop_afs_next_hop_af

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// BGP Nexthop info
type BgpNexthopBag_KEYS struct {
	InstanceName   string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName" json:"instance_name,omitempty"`
	VrfName        string `protobuf:"bytes,2,opt,name=vrf_name,json=vrfName" json:"vrf_name,omitempty"`
	AfName         string `protobuf:"bytes,3,opt,name=af_name,json=afName" json:"af_name,omitempty"`
	NextHopAfName  string `protobuf:"bytes,4,opt,name=next_hop_af_name,json=nextHopAfName" json:"next_hop_af_name,omitempty"`
	NextHopAddress string `protobuf:"bytes,5,opt,name=next_hop_address,json=nextHopAddress" json:"next_hop_address,omitempty"`
	AttributeSet   string `protobuf:"bytes,6,opt,name=attribute_set,json=attributeSet" json:"attribute_set,omitempty"`
}

func (m *BgpNexthopBag_KEYS) Reset()                    { *m = BgpNexthopBag_KEYS{} }
func (m *BgpNexthopBag_KEYS) String() string            { return proto.CompactTextString(m) }
func (*BgpNexthopBag_KEYS) ProtoMessage()               {}
func (*BgpNexthopBag_KEYS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BgpNexthopBag_KEYS) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *BgpNexthopBag_KEYS) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *BgpNexthopBag_KEYS) GetAfName() string {
	if m != nil {
		return m.AfName
	}
	return ""
}

func (m *BgpNexthopBag_KEYS) GetNextHopAfName() string {
	if m != nil {
		return m.NextHopAfName
	}
	return ""
}

func (m *BgpNexthopBag_KEYS) GetNextHopAddress() string {
	if m != nil {
		return m.NextHopAddress
	}
	return ""
}

func (m *BgpNexthopBag_KEYS) GetAttributeSet() string {
	if m != nil {
		return m.AttributeSet
	}
	return ""
}

type BgpNexthopBag struct {
	// Address family identifier
	AfName string `protobuf:"bytes,50,opt,name=af_name,json=afName" json:"af_name,omitempty"`
	// Nexthop address
	NexthopAddress *BgpAddrtype `protobuf:"bytes,51,opt,name=nexthop_address,json=nexthopAddress" json:"nexthop_address,omitempty"`
	// NH tunnel information
	NhTunnel *BgpTeTunnel `protobuf:"bytes,52,opt,name=nh_tunnel,json=nhTunnel" json:"nh_tunnel,omitempty"`
	// RIB Nexthop Id
	RibNexthopId uint32 `protobuf:"varint,53,opt,name=rib_nexthop_id,json=ribNexthopId" json:"rib_nexthop_id,omitempty"`
	// Nexthop registration is pending
	NexthopPendingRegistration uint32 `protobuf:"varint,54,opt,name=nexthop_pending_registration,json=nexthopPendingRegistration" json:"nexthop_pending_registration,omitempty"`
	// Number of neighbors/prefixes referencing this nexthop
	NexthopReferenceCount uint32 `protobuf:"varint,55,opt,name=nexthop_reference_count,json=nexthopReferenceCount" json:"nexthop_reference_count,omitempty"`
	// Number of neighbors/prefixes referencing this nexthop (AFs)
	NhReferenceCountTotal uint32 `protobuf:"varint,56,opt,name=nh_reference_count_total,json=nhReferenceCountTotal" json:"nh_reference_count_total,omitempty"`
	// First-hop interface handle
	NhFirstHopIfHandle string `protobuf:"bytes,57,opt,name=nh_first_hop_if_handle,json=nhFirstHopIfHandle" json:"nh_first_hop_if_handle,omitempty"`
	// Gateway related info, includingOptimal Route Reflector Gateways
	NexthopGatewayInfo []*BgpNexthopGwInfo_ `protobuf:"bytes,58,rep,name=nexthop_gateway_info,json=nexthopGatewayInfo" json:"nexthop_gateway_info,omitempty"`
	// AIGP metrice of nexthop
	NexthopAigpMetric uint32 `protobuf:"varint,59,opt,name=nexthop_aigp_metric,json=nexthopAigpMetric" json:"nexthop_aigp_metric,omitempty"`
	// Internal nexthop info
	NexthopInternalInfo *BgpIntNh_ `protobuf:"bytes,60,opt,name=nexthop_internal_info,json=nexthopInternalInfo" json:"nexthop_internal_info,omitempty"`
	// Neighbor Address List
	NeighborAddressList []*BgpAddrtype `protobuf:"bytes,61,rep,name=neighbor_address_list,json=neighborAddressList" json:"neighbor_address_list,omitempty"`
	// Is Gateway reachable ?
	NexthopGatewayReachable bool `protobuf:"varint,62,opt,name=nexthop_gateway_reachable,json=nexthopGatewayReachable" json:"nexthop_gateway_reachable,omitempty"`
	// Is Gateway resolved through Connected route ?
	NexthopGatewayPrefixConnected bool `protobuf:"varint,63,opt,name=nexthop_gateway_prefix_connected,json=nexthopGatewayPrefixConnected" json:"nexthop_gateway_prefix_connected,omitempty"`
	// Gateway prefix length
	NexthopGatewayPrefixLength uint32 `protobuf:"varint,64,opt,name=nexthop_gateway_prefix_length,json=nexthopGatewayPrefixLength" json:"nexthop_gateway_prefix_length,omitempty"`
}

func (m *BgpNexthopBag) Reset()                    { *m = BgpNexthopBag{} }
func (m *BgpNexthopBag) String() string            { return proto.CompactTextString(m) }
func (*BgpNexthopBag) ProtoMessage()               {}
func (*BgpNexthopBag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *BgpNexthopBag) GetAfName() string {
	if m != nil {
		return m.AfName
	}
	return ""
}

func (m *BgpNexthopBag) GetNexthopAddress() *BgpAddrtype {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *BgpNexthopBag) GetNhTunnel() *BgpTeTunnel {
	if m != nil {
		return m.NhTunnel
	}
	return nil
}

func (m *BgpNexthopBag) GetRibNexthopId() uint32 {
	if m != nil {
		return m.RibNexthopId
	}
	return 0
}

func (m *BgpNexthopBag) GetNexthopPendingRegistration() uint32 {
	if m != nil {
		return m.NexthopPendingRegistration
	}
	return 0
}

func (m *BgpNexthopBag) GetNexthopReferenceCount() uint32 {
	if m != nil {
		return m.NexthopReferenceCount
	}
	return 0
}

func (m *BgpNexthopBag) GetNhReferenceCountTotal() uint32 {
	if m != nil {
		return m.NhReferenceCountTotal
	}
	return 0
}

func (m *BgpNexthopBag) GetNhFirstHopIfHandle() string {
	if m != nil {
		return m.NhFirstHopIfHandle
	}
	return ""
}

func (m *BgpNexthopBag) GetNexthopGatewayInfo() []*BgpNexthopGwInfo_ {
	if m != nil {
		return m.NexthopGatewayInfo
	}
	return nil
}

func (m *BgpNexthopBag) GetNexthopAigpMetric() uint32 {
	if m != nil {
		return m.NexthopAigpMetric
	}
	return 0
}

func (m *BgpNexthopBag) GetNexthopInternalInfo() *BgpIntNh_ {
	if m != nil {
		return m.NexthopInternalInfo
	}
	return nil
}

func (m *BgpNexthopBag) GetNeighborAddressList() []*BgpAddrtype {
	if m != nil {
		return m.NeighborAddressList
	}
	return nil
}

func (m *BgpNexthopBag) GetNexthopGatewayReachable() bool {
	if m != nil {
		return m.NexthopGatewayReachable
	}
	return false
}

func (m *BgpNexthopBag) GetNexthopGatewayPrefixConnected() bool {
	if m != nil {
		return m.NexthopGatewayPrefixConnected
	}
	return false
}

func (m *BgpNexthopBag) GetNexthopGatewayPrefixLength() uint32 {
	if m != nil {
		return m.NexthopGatewayPrefixLength
	}
	return 0
}

// IPV4Tunnel Address type
type IPV4TunnelAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPV4TunnelAddressType) Reset()                    { *m = IPV4TunnelAddressType{} }
func (m *IPV4TunnelAddressType) String() string            { return proto.CompactTextString(m) }
func (*IPV4TunnelAddressType) ProtoMessage()               {}
func (*IPV4TunnelAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *IPV4TunnelAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPV4MDT Address type
type IPV4MDTAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPV4MDTAddressType) Reset()                    { *m = IPV4MDTAddressType{} }
func (m *IPV4MDTAddressType) String() string            { return proto.CompactTextString(m) }
func (*IPV4MDTAddressType) ProtoMessage()               {}
func (*IPV4MDTAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IPV4MDTAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPV4 RTConstraint Address type
type RTConstraintAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *RTConstraintAddressType) Reset()                    { *m = RTConstraintAddressType{} }
func (m *RTConstraintAddressType) String() string            { return proto.CompactTextString(m) }
func (*RTConstraintAddressType) ProtoMessage()               {}
func (*RTConstraintAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RTConstraintAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPV6 Address type
type IPV6AddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPV6AddressType) Reset()                    { *m = IPV6AddressType{} }
func (m *IPV6AddressType) String() string            { return proto.CompactTextString(m) }
func (*IPV6AddressType) ProtoMessage()               {}
func (*IPV6AddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *IPV6AddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type BgpIpv4SrpolicyAddrT struct {
	Ipv4SrpolicyAddress []byte `protobuf:"bytes,1,opt,name=ipv4_srpolicy_address,json=ipv4SrpolicyAddress,proto3" json:"ipv4_srpolicy_address,omitempty"`
}

func (m *BgpIpv4SrpolicyAddrT) Reset()                    { *m = BgpIpv4SrpolicyAddrT{} }
func (m *BgpIpv4SrpolicyAddrT) String() string            { return proto.CompactTextString(m) }
func (*BgpIpv4SrpolicyAddrT) ProtoMessage()               {}
func (*BgpIpv4SrpolicyAddrT) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *BgpIpv4SrpolicyAddrT) GetIpv4SrpolicyAddress() []byte {
	if m != nil {
		return m.Ipv4SrpolicyAddress
	}
	return nil
}

type BgpIpv6SrpolicyAddrT struct {
	Ipv6SrpolicyAddress []byte `protobuf:"bytes,1,opt,name=ipv6_srpolicy_address,json=ipv6SrpolicyAddress,proto3" json:"ipv6_srpolicy_address,omitempty"`
}

func (m *BgpIpv6SrpolicyAddrT) Reset()                    { *m = BgpIpv6SrpolicyAddrT{} }
func (m *BgpIpv6SrpolicyAddrT) String() string            { return proto.CompactTextString(m) }
func (*BgpIpv6SrpolicyAddrT) ProtoMessage()               {}
func (*BgpIpv6SrpolicyAddrT) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *BgpIpv6SrpolicyAddrT) GetIpv6SrpolicyAddress() []byte {
	if m != nil {
		return m.Ipv6SrpolicyAddress
	}
	return nil
}

type BgpL2VpnAddrT struct {
	L2VpnAddress []byte `protobuf:"bytes,1,opt,name=l2vpn_address,json=l2vpnAddress,proto3" json:"l2vpn_address,omitempty"`
}

func (m *BgpL2VpnAddrT) Reset()                    { *m = BgpL2VpnAddrT{} }
func (m *BgpL2VpnAddrT) String() string            { return proto.CompactTextString(m) }
func (*BgpL2VpnAddrT) ProtoMessage()               {}
func (*BgpL2VpnAddrT) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BgpL2VpnAddrT) GetL2VpnAddress() []byte {
	if m != nil {
		return m.L2VpnAddress
	}
	return nil
}

// L2VPN EVPN Address type
type L2VPNEVPNAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *L2VPNEVPNAddressType) Reset()                    { *m = L2VPNEVPNAddressType{} }
func (m *L2VPNEVPNAddressType) String() string            { return proto.CompactTextString(m) }
func (*L2VPNEVPNAddressType) ProtoMessage()               {}
func (*L2VPNEVPNAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *L2VPNEVPNAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type BgpL2VpnMspwAddrT struct {
	L2VpnAddress []byte `protobuf:"bytes,1,opt,name=l2vpn_address,json=l2vpnAddress,proto3" json:"l2vpn_address,omitempty"`
}

func (m *BgpL2VpnMspwAddrT) Reset()                    { *m = BgpL2VpnMspwAddrT{} }
func (m *BgpL2VpnMspwAddrT) String() string            { return proto.CompactTextString(m) }
func (*BgpL2VpnMspwAddrT) ProtoMessage()               {}
func (*BgpL2VpnMspwAddrT) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *BgpL2VpnMspwAddrT) GetL2VpnAddress() []byte {
	if m != nil {
		return m.L2VpnAddress
	}
	return nil
}

// IPV6 MVPN Address type
type IPV6MVPNAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPV6MVPNAddressType) Reset()                    { *m = IPV6MVPNAddressType{} }
func (m *IPV6MVPNAddressType) String() string            { return proto.CompactTextString(m) }
func (*IPV6MVPNAddressType) ProtoMessage()               {}
func (*IPV6MVPNAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *IPV6MVPNAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPV4 MVPN Address type
type IPV4MVPNAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPV4MVPNAddressType) Reset()                    { *m = IPV4MVPNAddressType{} }
func (m *IPV4MVPNAddressType) String() string            { return proto.CompactTextString(m) }
func (*IPV4MVPNAddressType) ProtoMessage()               {}
func (*IPV4MVPNAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *IPV4MVPNAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// LINKSTATE LINKSTATE Address type
type LS_LSAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *LS_LSAddressType) Reset()                    { *m = LS_LSAddressType{} }
func (m *LS_LSAddressType) String() string            { return proto.CompactTextString(m) }
func (*LS_LSAddressType) ProtoMessage()               {}
func (*LS_LSAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *LS_LSAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPv4 Flowspec Address type
type IPv4FlowspecAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPv4FlowspecAddressType) Reset()                    { *m = IPv4FlowspecAddressType{} }
func (m *IPv4FlowspecAddressType) String() string            { return proto.CompactTextString(m) }
func (*IPv4FlowspecAddressType) ProtoMessage()               {}
func (*IPv4FlowspecAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *IPv4FlowspecAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPv6 Flowspec Address type
type IPv6FlowspecAddressType struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *IPv6FlowspecAddressType) Reset()                    { *m = IPv6FlowspecAddressType{} }
func (m *IPv6FlowspecAddressType) String() string            { return proto.CompactTextString(m) }
func (*IPv6FlowspecAddressType) ProtoMessage()               {}
func (*IPv6FlowspecAddressType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *IPv6FlowspecAddressType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type BgpAddrtype struct {
	Afi string `protobuf:"bytes,1,opt,name=afi" json:"afi,omitempty"`
	// IPv4 Addr
	Ipv4Address string `protobuf:"bytes,2,opt,name=ipv4_address,json=ipv4Address" json:"ipv4_address,omitempty"`
	// IPv4 Mcast Addr
	Ipv4McastAddress string `protobuf:"bytes,3,opt,name=ipv4_mcast_address,json=ipv4McastAddress" json:"ipv4_mcast_address,omitempty"`
	// IPv4 Label Addr
	Ipv4LabelAddress string `protobuf:"bytes,4,opt,name=ipv4_label_address,json=ipv4LabelAddress" json:"ipv4_label_address,omitempty"`
	// IPv4 Tunnel
	Ipv4TunnelAddress *IPV4TunnelAddressType `protobuf:"bytes,5,opt,name=ipv4_tunnel_address,json=ipv4TunnelAddress" json:"ipv4_tunnel_address,omitempty"`
	// IPv4 MDT Addr
	Ipv4MdtAddress *IPV4MDTAddressType `protobuf:"bytes,6,opt,name=ipv4_mdt_address,json=ipv4MdtAddress" json:"ipv4_mdt_address,omitempty"`
	// IPv4 VPN Addr
	Ipv4VpnAddress string `protobuf:"bytes,7,opt,name=ipv4_vpn_address,json=ipv4VpnAddress" json:"ipv4_vpn_address,omitempty"`
	// IPv4 VPN Mcast Addr
	Ipv4VpnaMcastddress string `protobuf:"bytes,8,opt,name=ipv4_vpna_mcastddress,json=ipv4VpnaMcastddress" json:"ipv4_vpna_mcastddress,omitempty"`
	// IPV6 Addr
	Ipv6Address *IPV6AddressType `protobuf:"bytes,9,opt,name=ipv6_address,json=ipv6Address" json:"ipv6_address,omitempty"`
	// IPV6 Mcast Addr
	Ipv6McastAddress *IPV6AddressType `protobuf:"bytes,10,opt,name=ipv6_mcast_address,json=ipv6McastAddress" json:"ipv6_mcast_address,omitempty"`
	// IPv6 Label Addr
	Ipv6LabelAddress *IPV6AddressType `protobuf:"bytes,11,opt,name=ipv6_label_address,json=ipv6LabelAddress" json:"ipv6_label_address,omitempty"`
	// IPv6 VPN Addr
	Ipv6VpnAddress *IPV6AddressType `protobuf:"bytes,12,opt,name=ipv6_vpn_address,json=ipv6VpnAddress" json:"ipv6_vpn_address,omitempty"`
	// IPv6 VPN Mcast Addr
	Ipv6VpnMcastAddress *IPV6AddressType `protobuf:"bytes,13,opt,name=ipv6_vpn_mcast_address,json=ipv6VpnMcastAddress" json:"ipv6_vpn_mcast_address,omitempty"`
	// L2VPN VPLS Addr
	L2VpnvplsAddress *BgpL2VpnAddrT `protobuf:"bytes,14,opt,name=l2_vpnvpls_address,json=l2VpnvplsAddress" json:"l2_vpnvpls_address,omitempty"`
	// RT Constrt Addr
	RtConstraintAddress *RTConstraintAddressType `protobuf:"bytes,15,opt,name=rt_constraint_address,json=rtConstraintAddress" json:"rt_constraint_address,omitempty"`
	// MVPN addr
	Ipv6MvpnAddress *IPV6MVPNAddressType `protobuf:"bytes,16,opt,name=ipv6_mvpn_address,json=ipv6MvpnAddress" json:"ipv6_mvpn_address,omitempty"`
	// MVPN4 addr
	Ipv4MvpnAddress *IPV4MVPNAddressType `protobuf:"bytes,17,opt,name=ipv4_mvpn_address,json=ipv4MvpnAddress" json:"ipv4_mvpn_address,omitempty"`
	// L2VPN EVPN Addr
	L2VpnEvpnAddress *L2VPNEVPNAddressType `protobuf:"bytes,18,opt,name=l2_vpn_evpn_address,json=l2VpnEvpnAddress" json:"l2_vpn_evpn_address,omitempty"`
	// LINKSTATE LINKSTATE Addr
	LsLsAddress *LS_LSAddressType `protobuf:"bytes,19,opt,name=ls_ls_address,json=lsLsAddress" json:"ls_ls_address,omitempty"`
	// L2VPN MSPW Addr
	L2VpnMspwAddress *BgpL2VpnMspwAddrT `protobuf:"bytes,20,opt,name=l2_vpn_mspw_address,json=l2VpnMspwAddress" json:"l2_vpn_mspw_address,omitempty"`
	// IPV4 Flowspec Addr
	Ipv4FlowspecAddress *IPv4FlowspecAddressType `protobuf:"bytes,21,opt,name=ipv4_flowspec_address,json=ipv4FlowspecAddress" json:"ipv4_flowspec_address,omitempty"`
	// IPV6 Flowspec Addr
	Ipv6FlowspecAddress *IPv6FlowspecAddressType `protobuf:"bytes,22,opt,name=ipv6_flowspec_address,json=ipv6FlowspecAddress" json:"ipv6_flowspec_address,omitempty"`
	// IPV4 VPN Flowspec Addr
	Ipv4VpnFlowspecAddress *IPv4FlowspecAddressType `protobuf:"bytes,23,opt,name=ipv4_vpn_flowspec_address,json=ipv4VpnFlowspecAddress" json:"ipv4_vpn_flowspec_address,omitempty"`
	// IPV6 VPN Flowspec Addr
	Ipv6VpnFlowspecAddress *IPv6FlowspecAddressType `protobuf:"bytes,24,opt,name=ipv6_vpn_flowspec_address,json=ipv6VpnFlowspecAddress" json:"ipv6_vpn_flowspec_address,omitempty"`
	// IPV4 Policy Addr
	Ipv4SrPolicyAddress *BgpIpv4SrpolicyAddrT `protobuf:"bytes,25,opt,name=ipv4_sr_policy_address,json=ipv4SrPolicyAddress" json:"ipv4_sr_policy_address,omitempty"`
	// IPV6 Policy Addr
	Ipv6SrPolicyAddress *BgpIpv6SrpolicyAddrT `protobuf:"bytes,26,opt,name=ipv6_sr_policy_address,json=ipv6SrPolicyAddress" json:"ipv6_sr_policy_address,omitempty"`
}

func (m *BgpAddrtype) Reset()                    { *m = BgpAddrtype{} }
func (m *BgpAddrtype) String() string            { return proto.CompactTextString(m) }
func (*BgpAddrtype) ProtoMessage()               {}
func (*BgpAddrtype) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *BgpAddrtype) GetAfi() string {
	if m != nil {
		return m.Afi
	}
	return ""
}

func (m *BgpAddrtype) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *BgpAddrtype) GetIpv4McastAddress() string {
	if m != nil {
		return m.Ipv4McastAddress
	}
	return ""
}

func (m *BgpAddrtype) GetIpv4LabelAddress() string {
	if m != nil {
		return m.Ipv4LabelAddress
	}
	return ""
}

func (m *BgpAddrtype) GetIpv4TunnelAddress() *IPV4TunnelAddressType {
	if m != nil {
		return m.Ipv4TunnelAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv4MdtAddress() *IPV4MDTAddressType {
	if m != nil {
		return m.Ipv4MdtAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv4VpnAddress() string {
	if m != nil {
		return m.Ipv4VpnAddress
	}
	return ""
}

func (m *BgpAddrtype) GetIpv4VpnaMcastddress() string {
	if m != nil {
		return m.Ipv4VpnaMcastddress
	}
	return ""
}

func (m *BgpAddrtype) GetIpv6Address() *IPV6AddressType {
	if m != nil {
		return m.Ipv6Address
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6McastAddress() *IPV6AddressType {
	if m != nil {
		return m.Ipv6McastAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6LabelAddress() *IPV6AddressType {
	if m != nil {
		return m.Ipv6LabelAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6VpnAddress() *IPV6AddressType {
	if m != nil {
		return m.Ipv6VpnAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6VpnMcastAddress() *IPV6AddressType {
	if m != nil {
		return m.Ipv6VpnMcastAddress
	}
	return nil
}

func (m *BgpAddrtype) GetL2VpnvplsAddress() *BgpL2VpnAddrT {
	if m != nil {
		return m.L2VpnvplsAddress
	}
	return nil
}

func (m *BgpAddrtype) GetRtConstraintAddress() *RTConstraintAddressType {
	if m != nil {
		return m.RtConstraintAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6MvpnAddress() *IPV6MVPNAddressType {
	if m != nil {
		return m.Ipv6MvpnAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv4MvpnAddress() *IPV4MVPNAddressType {
	if m != nil {
		return m.Ipv4MvpnAddress
	}
	return nil
}

func (m *BgpAddrtype) GetL2VpnEvpnAddress() *L2VPNEVPNAddressType {
	if m != nil {
		return m.L2VpnEvpnAddress
	}
	return nil
}

func (m *BgpAddrtype) GetLsLsAddress() *LS_LSAddressType {
	if m != nil {
		return m.LsLsAddress
	}
	return nil
}

func (m *BgpAddrtype) GetL2VpnMspwAddress() *BgpL2VpnMspwAddrT {
	if m != nil {
		return m.L2VpnMspwAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv4FlowspecAddress() *IPv4FlowspecAddressType {
	if m != nil {
		return m.Ipv4FlowspecAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6FlowspecAddress() *IPv6FlowspecAddressType {
	if m != nil {
		return m.Ipv6FlowspecAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv4VpnFlowspecAddress() *IPv4FlowspecAddressType {
	if m != nil {
		return m.Ipv4VpnFlowspecAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6VpnFlowspecAddress() *IPv6FlowspecAddressType {
	if m != nil {
		return m.Ipv6VpnFlowspecAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv4SrPolicyAddress() *BgpIpv4SrpolicyAddrT {
	if m != nil {
		return m.Ipv4SrPolicyAddress
	}
	return nil
}

func (m *BgpAddrtype) GetIpv6SrPolicyAddress() *BgpIpv6SrpolicyAddrT {
	if m != nil {
		return m.Ipv6SrPolicyAddress
	}
	return nil
}

type BgpTeTunnel struct {
	// Nexthop Tunnel Type
	TunnelType string `protobuf:"bytes,1,opt,name=tunnel_type,json=tunnelType" json:"tunnel_type,omitempty"`
	// Tunnel name attribute
	TunnelName string `protobuf:"bytes,2,opt,name=tunnel_name,json=tunnelName" json:"tunnel_name,omitempty"`
	// Tunnel Up flag
	IsTunnelUp bool `protobuf:"varint,3,opt,name=is_tunnel_up,json=isTunnelUp" json:"is_tunnel_up,omitempty"`
	// Tunnel is stale
	IsTunnelInfoStale bool `protobuf:"varint,4,opt,name=is_tunnel_info_stale,json=isTunnelInfoStale" json:"is_tunnel_info_stale,omitempty"`
	// Tunnel registered flag
	IsTunnelRegistered bool `protobuf:"varint,5,opt,name=is_tunnel_registered,json=isTunnelRegistered" json:"is_tunnel_registered,omitempty"`
	// Tunnel need IPv6
	TunnelV6Required bool `protobuf:"varint,6,opt,name=tunnel_v6_required,json=tunnelV6Required" json:"tunnel_v6_required,omitempty"`
	// IPv6 enabled
	TunnelV6Enabled bool `protobuf:"varint,7,opt,name=tunnel_v6_enabled,json=tunnelV6Enabled" json:"tunnel_v6_enabled,omitempty"`
	// Binding label for the tunnel
	BindingLabel uint32 `protobuf:"varint,8,opt,name=binding_label,json=bindingLabel" json:"binding_label,omitempty"`
	// Interface handle for the tunnel
	TunnelIfHandle uint32 `protobuf:"varint,9,opt,name=tunnel_if_handle,json=tunnelIfHandle" json:"tunnel_if_handle,omitempty"`
	// Time since the last tunnel update happened
	LastTunnelUpdate uint32 `protobuf:"varint,10,opt,name=last_tunnel_update,json=lastTunnelUpdate" json:"last_tunnel_update,omitempty"`
}

func (m *BgpTeTunnel) Reset()                    { *m = BgpTeTunnel{} }
func (m *BgpTeTunnel) String() string            { return proto.CompactTextString(m) }
func (*BgpTeTunnel) ProtoMessage()               {}
func (*BgpTeTunnel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *BgpTeTunnel) GetTunnelType() string {
	if m != nil {
		return m.TunnelType
	}
	return ""
}

func (m *BgpTeTunnel) GetTunnelName() string {
	if m != nil {
		return m.TunnelName
	}
	return ""
}

func (m *BgpTeTunnel) GetIsTunnelUp() bool {
	if m != nil {
		return m.IsTunnelUp
	}
	return false
}

func (m *BgpTeTunnel) GetIsTunnelInfoStale() bool {
	if m != nil {
		return m.IsTunnelInfoStale
	}
	return false
}

func (m *BgpTeTunnel) GetIsTunnelRegistered() bool {
	if m != nil {
		return m.IsTunnelRegistered
	}
	return false
}

func (m *BgpTeTunnel) GetTunnelV6Required() bool {
	if m != nil {
		return m.TunnelV6Required
	}
	return false
}

func (m *BgpTeTunnel) GetTunnelV6Enabled() bool {
	if m != nil {
		return m.TunnelV6Enabled
	}
	return false
}

func (m *BgpTeTunnel) GetBindingLabel() uint32 {
	if m != nil {
		return m.BindingLabel
	}
	return 0
}

func (m *BgpTeTunnel) GetTunnelIfHandle() uint32 {
	if m != nil {
		return m.TunnelIfHandle
	}
	return 0
}

func (m *BgpTeTunnel) GetLastTunnelUpdate() uint32 {
	if m != nil {
		return m.LastTunnelUpdate
	}
	return 0
}

type BgpIntNhGw_ struct {
	// Gateway flags
	GatewayFlags uint32 `protobuf:"varint,1,opt,name=gateway_flags,json=gatewayFlags" json:"gateway_flags,omitempty"`
	// Nexthop registration type
	RegistrationType string `protobuf:"bytes,2,opt,name=registration_type,json=registrationType" json:"registration_type,omitempty"`
	// Time since registration
	RegistrationSince uint32 `protobuf:"varint,3,opt,name=registration_since,json=registrationSince" json:"registration_since,omitempty"`
}

func (m *BgpIntNhGw_) Reset()                    { *m = BgpIntNhGw_{} }
func (m *BgpIntNhGw_) String() string            { return proto.CompactTextString(m) }
func (*BgpIntNhGw_) ProtoMessage()               {}
func (*BgpIntNhGw_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *BgpIntNhGw_) GetGatewayFlags() uint32 {
	if m != nil {
		return m.GatewayFlags
	}
	return 0
}

func (m *BgpIntNhGw_) GetRegistrationType() string {
	if m != nil {
		return m.RegistrationType
	}
	return ""
}

func (m *BgpIntNhGw_) GetRegistrationSince() uint32 {
	if m != nil {
		return m.RegistrationSince
	}
	return 0
}

type BgpIntNh_ struct {
	// Nexthop address
	NexthopAddress *BgpAddrtype `protobuf:"bytes,1,opt,name=nexthop_address,json=nexthopAddress" json:"nexthop_address,omitempty"`
	// Comm librray ID
	NexthopId uint32 `protobuf:"varint,2,opt,name=nexthop_id,json=nexthopId" json:"nexthop_id,omitempty"`
	// Table version
	NexthopVersion uint32 `protobuf:"varint,3,opt,name=nexthop_version,json=nexthopVersion" json:"nexthop_version,omitempty"`
	// Nexthop flags
	NexthopFlags uint32 `protobuf:"varint,4,opt,name=nexthop_flags,json=nexthopFlags" json:"nexthop_flags,omitempty"`
	// Nexthop ifhandle
	NexthopIfHandle uint32 `protobuf:"varint,5,opt,name=nexthop_if_handle,json=nexthopIfHandle" json:"nexthop_if_handle,omitempty"`
	// Nexthop metrices
	NexthopMetrices []uint32 `protobuf:"varint,6,rep,packed,name=nexthop_metrices,json=nexthopMetrices" json:"nexthop_metrices,omitempty"`
	// Nexthop refcounts
	NexthopRefcounts []uint32 `protobuf:"varint,7,rep,packed,name=nexthop_refcounts,json=nexthopRefcounts" json:"nexthop_refcounts,omitempty"`
	// Bitmask indicating the AFs which share the nexthop
	NexthopAfUserBits uint32 `protobuf:"varint,8,opt,name=nexthop_af_user_bits,json=nexthopAfUserBits" json:"nexthop_af_user_bits,omitempty"`
	// Nexthop label
	NexthopLabel uint32 `protobuf:"varint,9,opt,name=nexthop_label,json=nexthopLabel" json:"nexthop_label,omitempty"`
	// Gateway flags
	GatewayFlags uint32 `protobuf:"varint,10,opt,name=gateway_flags,json=gatewayFlags" json:"gateway_flags,omitempty"`
	// Internal nexthop Gateway info
	NexthopGatewayInternalInfo []*BgpIntNhGw_ `protobuf:"bytes,11,rep,name=nexthop_gateway_internal_info,json=nexthopGatewayInternalInfo" json:"nexthop_gateway_internal_info,omitempty"`
}

func (m *BgpIntNh_) Reset()                    { *m = BgpIntNh_{} }
func (m *BgpIntNh_) String() string            { return proto.CompactTextString(m) }
func (*BgpIntNh_) ProtoMessage()               {}
func (*BgpIntNh_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *BgpIntNh_) GetNexthopAddress() *BgpAddrtype {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *BgpIntNh_) GetNexthopId() uint32 {
	if m != nil {
		return m.NexthopId
	}
	return 0
}

func (m *BgpIntNh_) GetNexthopVersion() uint32 {
	if m != nil {
		return m.NexthopVersion
	}
	return 0
}

func (m *BgpIntNh_) GetNexthopFlags() uint32 {
	if m != nil {
		return m.NexthopFlags
	}
	return 0
}

func (m *BgpIntNh_) GetNexthopIfHandle() uint32 {
	if m != nil {
		return m.NexthopIfHandle
	}
	return 0
}

func (m *BgpIntNh_) GetNexthopMetrices() []uint32 {
	if m != nil {
		return m.NexthopMetrices
	}
	return nil
}

func (m *BgpIntNh_) GetNexthopRefcounts() []uint32 {
	if m != nil {
		return m.NexthopRefcounts
	}
	return nil
}

func (m *BgpIntNh_) GetNexthopAfUserBits() uint32 {
	if m != nil {
		return m.NexthopAfUserBits
	}
	return 0
}

func (m *BgpIntNh_) GetNexthopLabel() uint32 {
	if m != nil {
		return m.NexthopLabel
	}
	return 0
}

func (m *BgpIntNh_) GetGatewayFlags() uint32 {
	if m != nil {
		return m.GatewayFlags
	}
	return 0
}

func (m *BgpIntNh_) GetNexthopGatewayInternalInfo() []*BgpIntNhGw_ {
	if m != nil {
		return m.NexthopGatewayInternalInfo
	}
	return nil
}

type BgpNexthopGwInfo_ struct {
	// Route resolving the nethop
	NexthopRoute *BgpAddrtype `protobuf:"bytes,1,opt,name=nexthop_route,json=nexthopRoute" json:"nexthop_route,omitempty"`
	// Prefix length of the route resolving the nexthop
	NexthopRoutePrefixLength uint32 `protobuf:"varint,2,opt,name=nexthop_route_prefix_length,json=nexthopRoutePrefixLength" json:"nexthop_route_prefix_length,omitempty"`
	// Protocol that resolves the route to the nexthop
	NexthopRouteProtocol string `protobuf:"bytes,3,opt,name=nexthop_route_protocol,json=nexthopRouteProtocol" json:"nexthop_route_protocol,omitempty"`
	// Number of paths in the resolving route
	NexthopRoutePathCount uint32 `protobuf:"varint,4,opt,name=nexthop_route_path_count,json=nexthopRoutePathCount" json:"nexthop_route_path_count,omitempty"`
	// Nexthops of the resolving route
	NexthopRoutePaths []*BgpAddrtype `protobuf:"bytes,5,rep,name=nexthop_route_paths,json=nexthopRoutePaths" json:"nexthop_route_paths,omitempty"`
	// Bitmask indicating the AFs which have been invalidated for the nexthop
	NexthopAfInvalidBits uint32 `protobuf:"varint,6,opt,name=nexthop_af_invalid_bits,json=nexthopAfInvalidBits" json:"nexthop_af_invalid_bits,omitempty"`
	// Nexthop status
	NexthopStatus uint32 `protobuf:"varint,7,opt,name=nexthop_status,json=nexthopStatus" json:"nexthop_status,omitempty"`
	// Nexthop Table id
	NexthopTableid uint64 `protobuf:"varint,8,opt,name=nexthop_tableid,json=nexthopTableid" json:"nexthop_tableid,omitempty"`
	// IGP metric for nexthop
	NexthopMetric uint32 `protobuf:"varint,9,opt,name=nexthop_metric,json=nexthopMetric" json:"nexthop_metric,omitempty"`
	// Last nexthop event type
	LastEventType string `protobuf:"bytes,10,opt,name=last_event_type,json=lastEventType" json:"last_event_type,omitempty"`
	// Last nexthop update type
	LastUpdateType string `protobuf:"bytes,11,opt,name=last_update_type,json=lastUpdateType" json:"last_update_type,omitempty"`
	// Number of critical events received from RIB
	CriticalEvents uint32 `protobuf:"varint,12,opt,name=critical_events,json=criticalEvents" json:"critical_events,omitempty"`
	// Number of non-critical events received from RIB
	NonCriticalEvents uint32 `protobuf:"varint,13,opt,name=non_critical_events,json=nonCriticalEvents" json:"non_critical_events,omitempty"`
	// Time since the last event sent to or received from RIB
	LastEventSince uint32 `protobuf:"varint,14,opt,name=last_event_since,json=lastEventSince" json:"last_event_since,omitempty"`
	// Time since the last rib update happened
	LastRibUpdate uint32 `protobuf:"varint,15,opt,name=last_rib_update,json=lastRibUpdate" json:"last_rib_update,omitempty"`
	// TRUE if MPLS is configured for IAS/CsC application
	NexthopMplsEnabled bool `protobuf:"varint,16,opt,name=nexthop_mpls_enabled,json=nexthopMplsEnabled" json:"nexthop_mpls_enabled,omitempty"`
	// Number of interfaces on which MPLS is enabled
	NexthopMplsInterfaces uint32 `protobuf:"varint,17,opt,name=nexthop_mpls_interfaces,json=nexthopMplsInterfaces" json:"nexthop_mpls_interfaces,omitempty"`
	// Local label allocated for IAS/CsC application
	NexthopMplsLabel uint32 `protobuf:"varint,18,opt,name=nexthop_mpls_label,json=nexthopMplsLabel" json:"nexthop_mpls_label,omitempty"`
}

func (m *BgpNexthopGwInfo_) Reset()                    { *m = BgpNexthopGwInfo_{} }
func (m *BgpNexthopGwInfo_) String() string            { return proto.CompactTextString(m) }
func (*BgpNexthopGwInfo_) ProtoMessage()               {}
func (*BgpNexthopGwInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *BgpNexthopGwInfo_) GetNexthopRoute() *BgpAddrtype {
	if m != nil {
		return m.NexthopRoute
	}
	return nil
}

func (m *BgpNexthopGwInfo_) GetNexthopRoutePrefixLength() uint32 {
	if m != nil {
		return m.NexthopRoutePrefixLength
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopRouteProtocol() string {
	if m != nil {
		return m.NexthopRouteProtocol
	}
	return ""
}

func (m *BgpNexthopGwInfo_) GetNexthopRoutePathCount() uint32 {
	if m != nil {
		return m.NexthopRoutePathCount
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopRoutePaths() []*BgpAddrtype {
	if m != nil {
		return m.NexthopRoutePaths
	}
	return nil
}

func (m *BgpNexthopGwInfo_) GetNexthopAfInvalidBits() uint32 {
	if m != nil {
		return m.NexthopAfInvalidBits
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopStatus() uint32 {
	if m != nil {
		return m.NexthopStatus
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopTableid() uint64 {
	if m != nil {
		return m.NexthopTableid
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopMetric() uint32 {
	if m != nil {
		return m.NexthopMetric
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetLastEventType() string {
	if m != nil {
		return m.LastEventType
	}
	return ""
}

func (m *BgpNexthopGwInfo_) GetLastUpdateType() string {
	if m != nil {
		return m.LastUpdateType
	}
	return ""
}

func (m *BgpNexthopGwInfo_) GetCriticalEvents() uint32 {
	if m != nil {
		return m.CriticalEvents
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNonCriticalEvents() uint32 {
	if m != nil {
		return m.NonCriticalEvents
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetLastEventSince() uint32 {
	if m != nil {
		return m.LastEventSince
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetLastRibUpdate() uint32 {
	if m != nil {
		return m.LastRibUpdate
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopMplsEnabled() bool {
	if m != nil {
		return m.NexthopMplsEnabled
	}
	return false
}

func (m *BgpNexthopGwInfo_) GetNexthopMplsInterfaces() uint32 {
	if m != nil {
		return m.NexthopMplsInterfaces
	}
	return 0
}

func (m *BgpNexthopGwInfo_) GetNexthopMplsLabel() uint32 {
	if m != nil {
		return m.NexthopMplsLabel
	}
	return 0
}

func init() {
	proto.RegisterType((*BgpNexthopBag_KEYS)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_nexthop_bag_KEYS")
	proto.RegisterType((*BgpNexthopBag)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_nexthop_bag")
	proto.RegisterType((*IPV4TunnelAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPV4TunnelAddressType")
	proto.RegisterType((*IPV4MDTAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPV4MDTAddressType")
	proto.RegisterType((*RTConstraintAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.RTConstraintAddressType")
	proto.RegisterType((*IPV6AddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPV6AddressType")
	proto.RegisterType((*BgpIpv4SrpolicyAddrT)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_ipv4_srpolicy_addr_t")
	proto.RegisterType((*BgpIpv6SrpolicyAddrT)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_ipv6_srpolicy_addr_t")
	proto.RegisterType((*BgpL2VpnAddrT)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_l2vpn_addr_t")
	proto.RegisterType((*L2VPNEVPNAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.L2VPNEVPNAddressType")
	proto.RegisterType((*BgpL2VpnMspwAddrT)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_l2vpn_mspw_addr_t")
	proto.RegisterType((*IPV6MVPNAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPV6MVPNAddressType")
	proto.RegisterType((*IPV4MVPNAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPV4MVPNAddressType")
	proto.RegisterType((*LS_LSAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.LS_LSAddressType")
	proto.RegisterType((*IPv4FlowspecAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPv4FlowspecAddressType")
	proto.RegisterType((*IPv6FlowspecAddressType)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.IPv6FlowspecAddressType")
	proto.RegisterType((*BgpAddrtype)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_addrtype")
	proto.RegisterType((*BgpTeTunnel)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_te_tunnel")
	proto.RegisterType((*BgpIntNhGw_)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_int_nh_gw_")
	proto.RegisterType((*BgpIntNh_)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_int_nh_")
	proto.RegisterType((*BgpNexthopGwInfo_)(nil), "cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af.bgp_nexthop_gw_info_")
}

func init() { proto.RegisterFile("bgp_nexthop_bag.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2126 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0x5b, 0x6f, 0x24, 0x47,
	0x15, 0x56, 0x67, 0xbd, 0x5e, 0xbb, 0x66, 0xc6, 0x9e, 0x29, 0xdf, 0x7a, 0x03, 0x2b, 0x8c, 0x97,
	0xb0, 0xc3, 0x66, 0xe3, 0xa0, 0xc9, 0xa4, 0x17, 0x42, 0x02, 0x09, 0x8b, 0x37, 0x3b, 0xc2, 0xb6,
	0xac, 0xb6, 0x63, 0x89, 0xa7, 0x56, 0xcf, 0x4c, 0xf5, 0x4c, 0x49, 0xed, 0xea, 0xa6, 0xab, 0x66,
	0xbc, 0xfe, 0x19, 0xbc, 0xf3, 0x07, 0xb8, 0x04, 0x71, 0x11, 0x88, 0x77, 0x9e, 0x78, 0x03, 0xc1,
	0x03, 0x52, 0xb8, 0x48, 0x40, 0x84, 0x84, 0x78, 0x80, 0x1f, 0x80, 0x84, 0xea, 0xd4, 0x65, 0xba,
	0xdb, 0x63, 0xd6, 0x79, 0x73, 0xbf, 0x58, 0xe3, 0x73, 0xbe, 0x53, 0x5d, 0x5f, 0xd5, 0xa9, 0x53,
	0xa7, 0xea, 0x14, 0xda, 0xe8, 0x8f, 0xd2, 0x80, 0x91, 0xe7, 0x62, 0x9c, 0xa4, 0x41, 0x3f, 0x1c,
	0xed, 0xa6, 0x59, 0x22, 0x12, 0xfc, 0x5d, 0x67, 0x40, 0xf9, 0x20, 0x09, 0x68, 0xc2, 0x83, 0xe7,
	0x59, 0x40, 0xd3, 0x69, 0x37, 0x90, 0xc8, 0x24, 0x25, 0xd9, 0x6e, 0x7f, 0x94, 0xee, 0x52, 0xc6,
	0x45, 0xc8, 0x06, 0x84, 0xdb, 0x5f, 0xf6, 0x47, 0x10, 0x0e, 0x04, 0x9d, 0x92, 0xdd, 0x69, 0x16,
	0x71, 0xf9, 0x67, 0x37, 0x8c, 0xf8, 0x6e, 0x18, 0xed, 0xca, 0xaf, 0x04, 0xf2, 0x33, 0xe1, 0x70,
	0x98, 0x11, 0xce, 0x83, 0x28, 0x3c, 0xa3, 0x31, 0x25, 0xfc, 0x0a, 0xcd, 0x45, 0x4e, 0x1e, 0xe5,
	0x41, 0xd1, 0xce, 0x3f, 0x1c, 0xb4, 0x5e, 0xea, 0x78, 0xf0, 0xcd, 0xbd, 0x6f, 0x1d, 0xe3, 0xfb,
	0xa8, 0x61, 0xbb, 0xc1, 0xc2, 0x33, 0xe2, 0x3a, 0xdb, 0x4e, 0x7b, 0xd9, 0xaf, 0x1b, 0xe1, 0x61,
	0x78, 0x46, 0xf0, 0x5d, 0xb4, 0x34, 0xcd, 0x22, 0xa5, 0x7f, 0x09, 0xf4, 0x77, 0xa6, 0x59, 0x04,
	0xaa, 0x2d, 0x74, 0x27, 0xd4, 0x9a, 0x5b, 0xa0, 0x59, 0x0c, 0x95, 0xe2, 0x01, 0x6a, 0xe6, 0x3a,
	0xa0, 0x10, 0x0b, 0x80, 0x68, 0x48, 0xf9, 0xb3, 0x24, 0x7d, 0x4f, 0x01, 0xdb, 0x79, 0xa0, 0xa2,
	0xe3, 0xde, 0x06, 0xe0, 0x8a, 0x01, 0x2a, 0xa9, 0xec, 0x6b, 0x28, 0x44, 0x46, 0xfb, 0x13, 0x41,
	0x02, 0x4e, 0x84, 0xbb, 0xa8, 0xfa, 0x6a, 0x85, 0xc7, 0x44, 0xec, 0xfc, 0xb7, 0x8e, 0x56, 0x4b,
	0x4c, 0xf3, 0x9d, 0xec, 0x14, 0x3a, 0xf9, 0x7b, 0x07, 0xad, 0x1a, 0xa0, 0xf9, 0xf6, 0x1b, 0xdb,
	0x4e, 0xbb, 0xd6, 0xf9, 0xbe, 0xb3, 0x7b, 0x93, 0x27, 0x54, 0xf6, 0x00, 0xb0, 0xe2, 0x22, 0x25,
	0x6a, 0xa0, 0xc6, 0xb3, 0x81, 0xfa, 0xb5, 0x83, 0x96, 0xd9, 0x38, 0x10, 0x13, 0xc6, 0x48, 0xec,
	0x76, 0x81, 0xd0, 0x0f, 0x2a, 0x40, 0x48, 0x10, 0xdd, 0x67, 0x7f, 0x89, 0x8d, 0x4f, 0xe0, 0x17,
	0xfe, 0x1c, 0x5a, 0xc9, 0x68, 0xdf, 0x4e, 0x27, 0x1d, 0xba, 0x6f, 0x6e, 0x3b, 0xed, 0x86, 0x5f,
	0xcf, 0x68, 0xff, 0x50, 0x09, 0x7b, 0x43, 0xfc, 0x2e, 0xfa, 0xb4, 0x41, 0xa4, 0x84, 0x0d, 0x29,
	0x1b, 0x05, 0x19, 0x19, 0x51, 0x2e, 0xb2, 0x50, 0xd0, 0x84, 0xb9, 0x1e, 0xd8, 0xbc, 0xac, 0x31,
	0x47, 0x0a, 0xe2, 0xe7, 0x10, 0xd8, 0x43, 0x5b, 0xa6, 0x85, 0x8c, 0x44, 0x24, 0x23, 0x92, 0xf6,
	0x20, 0x99, 0x30, 0xe1, 0x3e, 0x06, 0xe3, 0x0d, 0xad, 0xf6, 0x8d, 0xf6, 0x89, 0x54, 0xe2, 0xc7,
	0xc8, 0x65, 0xe3, 0xb2, 0x49, 0x20, 0x12, 0x11, 0xc6, 0xee, 0x97, 0xb4, 0xe1, 0xb8, 0x68, 0x73,
	0x22, 0x95, 0xb8, 0x83, 0x36, 0xd9, 0x38, 0x88, 0x68, 0xc6, 0xd5, 0x18, 0xd0, 0x28, 0x18, 0x87,
	0x6c, 0x18, 0x13, 0xf7, 0xcb, 0xe0, 0xa3, 0x98, 0x8d, 0x9f, 0x4a, 0xe5, 0xb3, 0x24, 0xed, 0x45,
	0xcf, 0x40, 0x83, 0x3f, 0x76, 0xd0, 0xba, 0xe9, 0xe5, 0x28, 0x14, 0xe4, 0x3c, 0xbc, 0x08, 0x28,
	0x8b, 0x12, 0xf7, 0xad, 0xed, 0x5b, 0xed, 0x5a, 0xe7, 0xa7, 0x15, 0x98, 0x63, 0xdb, 0xfd, 0x73,
	0xe8, 0x79, 0xe0, 0x63, 0x2d, 0x79, 0x5f, 0xf1, 0xe9, 0xb1, 0x28, 0xc1, 0xbb, 0x68, 0xcd, 0x2e,
	0x4b, 0x3a, 0x4a, 0x83, 0x33, 0x22, 0x32, 0x3a, 0x70, 0xbf, 0x02, 0xe3, 0xd9, 0x32, 0xde, 0x4e,
	0x47, 0xe9, 0x01, 0x28, 0xf0, 0x9f, 0x1d, 0xb4, 0x61, 0x3d, 0x84, 0x09, 0x92, 0xb1, 0x30, 0x56,
	0x03, 0xf3, 0x36, 0x38, 0xff, 0xf7, 0x2a, 0x30, 0x30, 0x94, 0x89, 0x80, 0x8d, 0x03, 0xdf, 0x30,
	0xef, 0x69, 0x1e, 0x30, 0x20, 0x7f, 0x01, 0x82, 0x74, 0x34, 0xee, 0x27, 0x99, 0x6d, 0x35, 0xa6,
	0x5c, 0xb8, 0xef, 0xc0, 0xcc, 0x57, 0x2a, 0x5c, 0xad, 0x19, 0x26, 0x3a, 0x5e, 0xed, 0x53, 0x2e,
	0xf0, 0x5b, 0xe8, 0x6e, 0xd9, 0xb3, 0x33, 0x12, 0x0e, 0xc6, 0x61, 0x3f, 0x26, 0xee, 0x57, 0xb7,
	0x9d, 0xf6, 0x92, 0xbf, 0x55, 0xf4, 0x14, 0xdf, 0xa8, 0xf1, 0xfb, 0x68, 0xbb, 0x6c, 0x9b, 0x66,
	0x24, 0xa2, 0xcf, 0x83, 0x41, 0xc2, 0x18, 0x19, 0x08, 0x32, 0x74, 0xbf, 0x06, 0x4d, 0xdc, 0x2b,
	0x36, 0x71, 0x04, 0xa8, 0x27, 0x06, 0x84, 0xdf, 0x43, 0xf7, 0xae, 0x68, 0x28, 0x26, 0x6c, 0x24,
	0xc6, 0xee, 0xbb, 0x85, 0x38, 0x52, 0x68, 0x65, 0x1f, 0x10, 0x3b, 0xaf, 0xa1, 0x8d, 0xde, 0xd1,
	0x69, 0x57, 0x45, 0x2f, 0x4d, 0xf0, 0xe4, 0x22, 0x25, 0x78, 0x1d, 0xdd, 0x9e, 0x86, 0xf1, 0xc4,
	0xec, 0xb0, 0xea, 0x9f, 0x9d, 0x87, 0x08, 0x4b, 0xf8, 0xc1, 0x37, 0x4e, 0x5e, 0x8c, 0x7d, 0x1d,
	0x6d, 0xf9, 0x27, 0x4f, 0x12, 0x26, 0x63, 0x16, 0x65, 0xe2, 0xc5, 0x06, 0x0f, 0xd0, 0x6a, 0xef,
	0xe8, 0xd4, 0x7b, 0x31, 0xf0, 0x10, 0xb9, 0xe0, 0x82, 0xd2, 0x6b, 0x78, 0x96, 0x26, 0x31, 0x1d,
	0x5c, 0xc0, 0x7c, 0x05, 0x02, 0x77, 0xd0, 0xc6, 0x65, 0xb9, 0xdc, 0x28, 0x65, 0x0b, 0x75, 0x7f,
	0x4d, 0x2a, 0x8f, 0xb5, 0x4e, 0x7f, 0x29, 0xd7, 0x9e, 0x77, 0x45, 0x7b, 0xde, 0xff, 0x6b, 0xcf,
	0x2b, 0xb7, 0xf7, 0x18, 0x35, 0x65, 0x7b, 0x71, 0x67, 0x9a, 0x32, 0xd3, 0xce, 0x7d, 0xd4, 0x98,
	0xfd, 0x3f, 0xb3, 0xaf, 0x83, 0xd0, 0x18, 0x3e, 0x42, 0xeb, 0xfb, 0x9d, 0xd3, 0xa3, 0xc3, 0xbd,
	0xd3, 0xa3, 0xc3, 0x17, 0x0f, 0xc3, 0xdb, 0x2a, 0xbb, 0x53, 0xcd, 0x9e, 0xf1, 0xf4, 0xfc, 0x13,
	0x7d, 0xeb, 0x55, 0xb4, 0x26, 0x47, 0xfb, 0xe0, 0x5a, 0x9f, 0x52, 0xe0, 0xee, 0xf5, 0xc0, 0x6d,
	0xd4, 0xdc, 0x3f, 0x0e, 0xf6, 0x8f, 0xaf, 0xe5, 0x22, 0xbd, 0xa3, 0x69, 0xf7, 0x69, 0x9c, 0x9c,
	0xf3, 0x94, 0x0c, 0xae, 0x6b, 0xe0, 0x5d, 0xdf, 0xe0, 0xe3, 0x57, 0x50, 0x3d, 0xbf, 0x9a, 0x71,
	0x13, 0xdd, 0x0a, 0x23, 0xaa, 0x41, 0xf2, 0x27, 0xfe, 0x2c, 0xaa, 0x83, 0xc7, 0x98, 0xc1, 0x52,
	0x29, 0x63, 0x4d, 0xca, 0x4c, 0x86, 0xf2, 0x08, 0x61, 0x80, 0x9c, 0x0d, 0x42, 0x2e, 0x2c, 0x50,
	0x65, 0x90, 0x4d, 0xa9, 0x39, 0x90, 0x8a, 0x32, 0x3a, 0x0e, 0xfb, 0x24, 0xb6, 0xe8, 0x85, 0x19,
	0x7a, 0x5f, 0x2a, 0x0c, 0xfa, 0xef, 0x0e, 0x02, 0xa7, 0xd4, 0xb9, 0x44, 0x21, 0xa9, 0xac, 0x75,
	0x7e, 0x76, 0xc3, 0x23, 0xe5, 0xdc, 0xe0, 0xe1, 0xb7, 0x64, 0x37, 0x0b, 0x62, 0xfc, 0x91, 0x83,
	0x9a, 0x6a, 0x0c, 0x87, 0xb3, 0x11, 0x5c, 0x04, 0x8e, 0x3f, 0xae, 0x00, 0xc7, 0x62, 0xc4, 0xf3,
	0x57, 0x60, 0xd2, 0x87, 0x76, 0xca, 0xdb, 0x9a, 0x5c, 0x7e, 0xd1, 0xdd, 0x51, 0xa7, 0x02, 0x29,
	0x3f, 0xb5, 0xcb, 0xce, 0xc6, 0xa7, 0x69, 0xca, 0x42, 0xe5, 0x4f, 0x1a, 0xbe, 0x04, 0xf0, 0x35,
	0x0d, 0x0f, 0x0f, 0x66, 0x2a, 0xfc, 0x5b, 0x07, 0x5c, 0xd4, 0xb3, 0x4d, 0x2f, 0xc3, 0xb8, 0x7d,
	0x78, 0xf3, 0xc7, 0x2d, 0x1f, 0xcc, 0x61, 0x49, 0x19, 0x01, 0xfe, 0xa3, 0x03, 0xab, 0xc4, 0x2b,
	0xad, 0x29, 0x54, 0x49, 0x66, 0x72, 0xf2, 0xbd, 0x42, 0x0c, 0xb0, 0xf4, 0x8a, 0x41, 0xa0, 0x56,
	0x5d, 0x7a, 0x85, 0xa0, 0xf5, 0x07, 0xb5, 0x9a, 0xbd, 0x82, 0xc3, 0xd7, 0x2b, 0x49, 0x4e, 0x2e,
	0x50, 0x2f, 0xb7, 0x40, 0xff, 0xe6, 0xa0, 0x4d, 0x4b, 0xad, 0xe8, 0x9c, 0x8d, 0x4a, 0x12, 0x5c,
	0xd3, 0x04, 0x0b, 0xfe, 0xf9, 0x27, 0x07, 0xe1, 0xb8, 0x23, 0x39, 0x4e, 0xd3, 0x98, 0x5b, 0x86,
	0x2b, 0xc0, 0xf0, 0x47, 0x15, 0x48, 0xcf, 0xf3, 0xc9, 0x95, 0xdf, 0x8c, 0x3b, 0xa7, 0x8a, 0x89,
	0xe1, 0xf7, 0x4f, 0x07, 0x6d, 0x64, 0x42, 0x26, 0xd4, 0x3a, 0xfd, 0xb4, 0x14, 0x57, 0x81, 0xe2,
	0xcf, 0x6f, 0x38, 0xc5, 0x2b, 0x32, 0x67, 0x7f, 0x2d, 0x13, 0x97, 0x14, 0xf2, 0x3c, 0xd9, 0x52,
	0xb1, 0x34, 0xbf, 0x1c, 0x9b, 0x40, 0xf4, 0x27, 0x15, 0xf0, 0xd6, 0x52, 0x5a, 0xe9, 0xaf, 0x42,
	0x38, 0x9d, 0xe5, 0xaa, 0x86, 0x60, 0xb7, 0x48, 0xb0, 0x55, 0x15, 0x82, 0xdd, 0x79, 0x04, 0xbb,
	0x79, 0x82, 0x7f, 0x75, 0xd0, 0x9a, 0x5a, 0x8e, 0x01, 0xc9, 0x53, 0xc4, 0x40, 0xf1, 0xa6, 0x5f,
	0x94, 0xcc, 0x3b, 0xb3, 0xe8, 0x35, 0xb9, 0x97, 0x23, 0xf9, 0x3b, 0x07, 0x35, 0x62, 0x1e, 0xe4,
	0xc2, 0xcd, 0x5a, 0x25, 0xc2, 0x4d, 0xf9, 0x30, 0xe3, 0xd7, 0x62, 0xbe, 0xcf, 0x73, 0xfb, 0x85,
	0x99, 0x3a, 0x7b, 0x06, 0x93, 0xdc, 0xd6, 0x2b, 0x91, 0xbf, 0xcf, 0x3d, 0x40, 0xea, 0xb9, 0x3b,
	0xe0, 0xe9, 0x79, 0x3e, 0x9e, 0x42, 0xdf, 0x23, 0x7d, 0xf4, 0xb2, 0x3c, 0x37, 0x2a, 0x11, 0x4f,
	0xaf, 0x38, 0x66, 0xaa, 0x7c, 0xbb, 0xa4, 0x30, 0x64, 0xbd, 0xcb, 0x64, 0x37, 0xab, 0x42, 0xd6,
	0xbb, 0x8a, 0x6c, 0x59, 0x81, 0xff, 0xe3, 0xa0, 0xbb, 0xf6, 0xec, 0x72, 0x89, 0xf0, 0x56, 0xa5,
	0x67, 0x77, 0x53, 0x9f, 0xa6, 0xae, 0xe0, 0xec, 0xcd, 0xe7, 0xec, 0x56, 0x7a, 0x92, 0x37, 0x75,
	0xba, 0x57, 0xe6, 0xfc, 0x2f, 0x95, 0xd7, 0x76, 0x03, 0x9e, 0x05, 0xa5, 0xab, 0xac, 0xbb, 0x40,
	0xf8, 0x17, 0x55, 0xb8, 0x75, 0x9e, 0x73, 0xe5, 0x67, 0xee, 0xf4, 0x8e, 0xf2, 0x77, 0x70, 0x86,
	0xae, 0x37, 0x87, 0xee, 0xcb, 0x55, 0xa2, 0xeb, 0xcd, 0xa5, 0xeb, 0x95, 0xe8, 0xee, 0x7c, 0x78,
	0x0b, 0x35, 0x0a, 0x35, 0x29, 0xfc, 0x19, 0x54, 0xd3, 0x37, 0x4a, 0xe2, 0x22, 0x35, 0xb7, 0x62,
	0x48, 0x89, 0xe0, 0xc2, 0x6c, 0x06, 0xc8, 0x55, 0x4a, 0x35, 0x00, 0xca, 0x8d, 0xdb, 0xa8, 0x4e,
	0xb9, 0xb9, 0x96, 0x9a, 0xa4, 0x70, 0xdf, 0xb5, 0xe4, 0x23, 0xca, 0xd5, 0xcd, 0xce, 0x07, 0x29,
	0x7e, 0x1d, 0xad, 0xcf, 0x10, 0x50, 0x1f, 0xe1, 0x22, 0x8c, 0x55, 0xe5, 0x74, 0xc9, 0x6f, 0x19,
	0x64, 0x8f, 0x45, 0xc9, 0xb1, 0x54, 0xe0, 0x2f, 0xe6, 0x0d, 0x54, 0xc9, 0x8b, 0x64, 0x64, 0x08,
	0x97, 0x5d, 0x4b, 0x3e, 0x36, 0x06, 0xbe, 0xd5, 0xe0, 0x47, 0x08, 0x6b, 0xf8, 0xd4, 0x0b, 0x32,
	0xf2, 0xed, 0x09, 0x95, 0xf8, 0x45, 0xc0, 0x37, 0x95, 0xe6, 0xd4, 0xf3, 0xb5, 0x1c, 0x3f, 0x44,
	0xad, 0x19, 0x9a, 0xb0, 0xb0, 0x1f, 0x93, 0x21, 0x5c, 0xc4, 0x2c, 0xf9, 0xab, 0x06, 0xbc, 0xa7,
	0xc4, 0xf8, 0x3e, 0x6a, 0xf4, 0xa9, 0x2a, 0xbe, 0xc1, 0x21, 0x1d, 0x6e, 0x60, 0x1a, 0x7e, 0x5d,
	0x0b, 0xe1, 0xbc, 0x8b, 0xdb, 0xa8, 0x69, 0xe8, 0xd9, 0x82, 0xd7, 0x32, 0xe0, 0x56, 0x94, 0xdc,
	0x16, 0xbb, 0x1e, 0x21, 0x1c, 0xcb, 0xc3, 0xa2, 0x1d, 0xaf, 0x61, 0x28, 0x08, 0xdc, 0x67, 0x34,
	0xfc, 0xa6, 0xd4, 0x98, 0x51, 0x93, 0xf2, 0x9d, 0xef, 0x38, 0x68, 0x25, 0x57, 0x46, 0x19, 0x9d,
	0x07, 0xb2, 0x3f, 0xe6, 0x16, 0x3f, 0x8a, 0xc3, 0x91, 0xba, 0xb5, 0x6d, 0xf8, 0x75, 0x2d, 0x7c,
	0x2a, 0x65, 0xf8, 0x55, 0xd4, 0xca, 0x57, 0x0a, 0xd5, 0xdc, 0xaa, 0xa9, 0x6b, 0xe6, 0x15, 0x30,
	0xc3, 0xaf, 0x21, 0x5c, 0x00, 0x73, 0xca, 0x06, 0xaa, 0xf0, 0xdd, 0xf0, 0x0b, 0xcd, 0x1c, 0x4b,
	0xc5, 0xce, 0xaf, 0x16, 0x51, 0x2d, 0xd7, 0xa7, 0xb9, 0xe5, 0x66, 0xa7, 0xfa, 0xe5, 0xe6, 0x7b,
	0x08, 0xe5, 0xca, 0xb3, 0x2f, 0xc1, 0x68, 0x2c, 0x33, 0x5b, 0x9b, 0x7d, 0x30, 0x23, 0x3d, 0x25,
	0x19, 0xa7, 0x09, 0xd3, 0x23, 0x66, 0xda, 0x39, 0x55, 0x52, 0x39, 0x5f, 0x06, 0xa8, 0xe6, 0x6b,
	0x41, 0xcd, 0x97, 0x16, 0xaa, 0xf9, 0x7a, 0x88, 0x5a, 0xf6, 0x63, 0xd6, 0x81, 0x6e, 0x03, 0xd0,
	0x7c, 0xc6, 0x7a, 0xd0, 0x17, 0xd4, 0xd3, 0x02, 0x89, 0x55, 0x15, 0x44, 0xc2, 0xdd, 0xc5, 0xed,
	0x5b, 0x39, 0xe8, 0x81, 0x16, 0x4b, 0x37, 0xc8, 0x95, 0x7f, 0xa1, 0x88, 0xcb, 0xdd, 0x3b, 0x80,
	0x6d, 0xce, 0x0a, 0xbf, 0x4a, 0x2e, 0x57, 0xa9, 0x9d, 0xc6, 0x28, 0x98, 0x70, 0x92, 0x05, 0x7d,
	0x2a, 0xb8, 0xf6, 0x77, 0x5b, 0x9f, 0x8c, 0x3e, 0xe0, 0x24, 0xfb, 0x3a, 0x15, 0x3c, 0xcf, 0x4c,
	0xad, 0x8c, 0xe5, 0x02, 0x33, 0xb5, 0x32, 0x2e, 0xb9, 0x2b, 0x9a, 0xe3, 0xae, 0xff, 0x76, 0x2e,
	0x97, 0xa8, 0x8a, 0x15, 0xcf, 0x1a, 0x14, 0x04, 0x7f, 0x58, 0x9d, 0x8a, 0xe7, 0xe8, 0x3c, 0x28,
	0x57, 0xd4, 0xf2, 0xb5, 0xcf, 0x9d, 0x5f, 0x2e, 0x17, 0xdf, 0xae, 0x98, 0xca, 0x31, 0xfe, 0x8d,
	0x33, 0x1b, 0xd6, 0x2c, 0x99, 0x08, 0x52, 0xc5, 0xc5, 0x64, 0x7c, 0xc0, 0x97, 0x04, 0xf0, 0x3b,
	0xe8, 0x53, 0x05, 0x46, 0xa5, 0xf2, 0xa3, 0x5a, 0x5b, 0x6e, 0xde, 0x24, 0x5f, 0x7c, 0xc4, 0x5d,
	0xb4, 0x59, 0x36, 0x4f, 0x44, 0x32, 0x48, 0x62, 0x5d, 0x5a, 0x59, 0x2f, 0x5a, 0x2a, 0x1d, 0x3c,
	0x61, 0x28, 0x5a, 0x85, 0x62, 0xac, 0xdf, 0x3e, 0x2c, 0x14, 0xdf, 0x3e, 0x80, 0x5d, 0x28, 0xc6,
	0xea, 0xed, 0xc3, 0x47, 0xce, 0xac, 0x4e, 0x3f, 0xb3, 0xe4, 0xee, 0xed, 0xea, 0xd5, 0xa4, 0x5b,
	0x65, 0x86, 0x1c, 0xbf, 0x39, 0x7b, 0x11, 0x12, 0x46, 0x01, 0x65, 0xd3, 0x30, 0xa6, 0x43, 0xb5,
	0xd0, 0x17, 0x61, 0x54, 0xd6, 0xed, 0x42, 0xef, 0x29, 0x25, 0xac, 0xf5, 0x57, 0x90, 0x89, 0x6b,
	0x72, 0xef, 0x16, 0x13, 0x55, 0xb7, 0x68, 0xf8, 0xc6, 0x55, 0x8f, 0x41, 0x98, 0x8f, 0x8a, 0x42,
	0x6e, 0x9f, 0x74, 0x08, 0xe1, 0x63, 0xc1, 0x46, 0xc5, 0x13, 0x25, 0xcd, 0xb7, 0xa7, 0x9f, 0x41,
	0x2c, 0x17, 0xda, 0xd3, 0x4f, 0x20, 0x3e, 0x8f, 0x56, 0x61, 0xb7, 0x24, 0x53, 0xc2, 0x84, 0xda,
	0xc5, 0x90, 0x7a, 0x6e, 0x25, 0xc5, 0x7b, 0x52, 0x0a, 0x5b, 0x58, 0x1b, 0xc1, 0xde, 0xa9, 0xb7,
	0x53, 0x05, 0xac, 0xa9, 0xc2, 0x8a, 0x94, 0xab, 0xdd, 0x14, 0x90, 0x0f, 0xd0, 0xea, 0x20, 0xa3,
	0x82, 0x0e, 0xc2, 0x58, 0xb5, 0xaa, 0x2e, 0xa4, 0x1b, 0xfe, 0x8a, 0x11, 0x43, 0xab, 0x1c, 0x5e,
	0x6b, 0x24, 0x2c, 0x28, 0x83, 0x1b, 0x3a, 0x1a, 0x26, 0xec, 0x49, 0x11, 0x6f, 0xba, 0xa0, 0xba,
	0xaa, 0xf6, 0xd0, 0x15, 0xd5, 0xb2, 0xed, 0x2b, 0x6c, 0xa0, 0x96, 0x54, 0x46, 0xfb, 0x66, 0xff,
	0x5f, 0x55, 0xe4, 0xa5, 0xd8, 0xa7, 0x7d, 0xd5, 0x5d, 0x99, 0x05, 0xd9, 0x31, 0x4a, 0x63, 0x6e,
	0x13, 0x95, 0xa6, 0xca, 0x82, 0xcc, 0x48, 0xa5, 0x31, 0x37, 0xb9, 0x4a, 0xee, 0xb9, 0x0f, 0x58,
	0x40, 0x0c, 0x8d, 0x42, 0xb9, 0x43, 0xb4, 0x0a, 0x2e, 0x2f, 0x8d, 0x7a, 0x56, 0x29, 0x93, 0x92,
	0x82, 0x9d, 0x0a, 0xe7, 0x58, 0x25, 0x25, 0x39, 0x13, 0x08, 0xe9, 0xfd, 0x45, 0x58, 0x7f, 0x6f,
	0xfc, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x73, 0x46, 0x70, 0xae, 0x35, 0x28, 0x00, 0x00,
}
