// Code generated by protoc-gen-go.
// source: ipv4_acl_edm_ace.proto
// DO NOT EDIT!

/*
Package cisco_ios_xr_ipv4_acl_oper_ipv4_acl_and_prefix_list_access_list_manager_accesses_access_access_list_sequences_access_list_sequence is a generated protocol buffer package.

It is generated from these files:
	ipv4_acl_edm_ace.proto

It has these top-level messages:
	Ipv4AclEdmAce_KEYS
	Ipv4AclEdmAce
	AclUdfAce
	Ipv4AclBagNhInfo
	Ipv4AclBagHwNhInfo
*/
package cisco_ios_xr_ipv4_acl_oper_ipv4_acl_and_prefix_list_access_list_manager_accesses_access_access_list_sequences_access_list_sequence

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ACLE bag
type Ipv4AclEdmAce_KEYS struct {
	AccessListName string `protobuf:"bytes,1,opt,name=access_list_name,json=accessListName" json:"access_list_name,omitempty"`
	SequenceNumber uint32 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber" json:"sequence_number,omitempty"`
}

func (m *Ipv4AclEdmAce_KEYS) Reset()                    { *m = Ipv4AclEdmAce_KEYS{} }
func (m *Ipv4AclEdmAce_KEYS) String() string            { return proto.CompactTextString(m) }
func (*Ipv4AclEdmAce_KEYS) ProtoMessage()               {}
func (*Ipv4AclEdmAce_KEYS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Ipv4AclEdmAce_KEYS) GetAccessListName() string {
	if m != nil {
		return m.AccessListName
	}
	return ""
}

func (m *Ipv4AclEdmAce_KEYS) GetSequenceNumber() uint32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

type Ipv4AclEdmAce struct {
	// ACE type (acl, remark)
	ItemType string `protobuf:"bytes,50,opt,name=item_type,json=itemType" json:"item_type,omitempty"`
	// ACLE sequence number
	Sequence uint32 `protobuf:"varint,51,opt,name=sequence" json:"sequence,omitempty"`
	// Permit/deny
	Grant string `protobuf:"bytes,52,opt,name=grant" json:"grant,omitempty"`
	// IPv4 protocol operator
	ProtocolOperator uint32 `protobuf:"varint,53,opt,name=protocol_operator,json=protocolOperator" json:"protocol_operator,omitempty"`
	// IPv4 protocol type
	Protocol uint32 `protobuf:"varint,54,opt,name=protocol" json:"protocol,omitempty"`
	// IPv4 protocol 2
	Protocol2 uint32 `protobuf:"varint,55,opt,name=protocol2" json:"protocol2,omitempty"`
	// Source address
	SourceAddress string `protobuf:"bytes,56,opt,name=source_address,json=sourceAddress" json:"source_address,omitempty"`
	// Source mask
	SourceAddressMask string `protobuf:"bytes,57,opt,name=source_address_mask,json=sourceAddressMask" json:"source_address_mask,omitempty"`
	// Destination address
	DestinationAddress string `protobuf:"bytes,58,opt,name=destination_address,json=destinationAddress" json:"destination_address,omitempty"`
	// Destination mask
	DestinationAddressMask string `protobuf:"bytes,59,opt,name=destination_address_mask,json=destinationAddressMask" json:"destination_address_mask,omitempty"`
	// Source operator
	SourceOperator string `protobuf:"bytes,60,opt,name=source_operator,json=sourceOperator" json:"source_operator,omitempty"`
	// Source port 1
	SourcePort1 uint32 `protobuf:"varint,61,opt,name=source_port1,json=sourcePort1" json:"source_port1,omitempty"`
	// Source port 2
	SourcePort2 uint32 `protobuf:"varint,62,opt,name=source_port2,json=sourcePort2" json:"source_port2,omitempty"`
	// Deprecated by Source operator
	SorceOperator string `protobuf:"bytes,63,opt,name=sorce_operator,json=sorceOperator" json:"sorce_operator,omitempty"`
	// Deprecated by SourcePort1
	SorcePort1 uint32 `protobuf:"varint,64,opt,name=sorce_port1,json=sorcePort1" json:"sorce_port1,omitempty"`
	// Deprecated by SourcePort2
	SorcePort2 uint32 `protobuf:"varint,65,opt,name=sorce_port2,json=sorcePort2" json:"sorce_port2,omitempty"`
	// Destination operator
	DestinationOperator string `protobuf:"bytes,66,opt,name=destination_operator,json=destinationOperator" json:"destination_operator,omitempty"`
	// Destination port 1
	DestinationPort1 uint32 `protobuf:"varint,67,opt,name=destination_port1,json=destinationPort1" json:"destination_port1,omitempty"`
	// Destination port 2
	DestinationPort2 uint32 `protobuf:"varint,68,opt,name=destination_port2,json=destinationPort2" json:"destination_port2,omitempty"`
	// Log option
	LogOption string `protobuf:"bytes,69,opt,name=log_option,json=logOption" json:"log_option,omitempty"`
	// Counter name
	CounterName string `protobuf:"bytes,70,opt,name=counter_name,json=counterName" json:"counter_name,omitempty"`
	// Capture option, TRUE if enabled
	Capture bool `protobuf:"varint,71,opt,name=capture" json:"capture,omitempty"`
	// DSCP present
	DscpPresent bool `protobuf:"varint,72,opt,name=dscp_present,json=dscpPresent" json:"dscp_present,omitempty"`
	// DSCP or DSCP range start
	Dscp uint32 `protobuf:"varint,73,opt,name=dscp" json:"dscp,omitempty"`
	// DSCP Range End
	Dscp2 uint32 `protobuf:"varint,74,opt,name=dscp2" json:"dscp2,omitempty"`
	// DSCP Operator
	DscpOperator uint32 `protobuf:"varint,75,opt,name=dscp_operator,json=dscpOperator" json:"dscp_operator,omitempty"`
	// Precedence present
	PrecedencePresent bool `protobuf:"varint,76,opt,name=precedence_present,json=precedencePresent" json:"precedence_present,omitempty"`
	// Precedence
	Precedence uint32 `protobuf:"varint,77,opt,name=precedence" json:"precedence,omitempty"`
	// TCP flags operator
	TcpFlagsOperator string `protobuf:"bytes,78,opt,name=tcp_flags_operator,json=tcpFlagsOperator" json:"tcp_flags_operator,omitempty"`
	// TCP flags
	TcpFlags uint32 `protobuf:"varint,79,opt,name=tcp_flags,json=tcpFlags" json:"tcp_flags,omitempty"`
	// TCP flags mask
	TcpFlagsMask uint32 `protobuf:"varint,80,opt,name=tcp_flags_mask,json=tcpFlagsMask" json:"tcp_flags_mask,omitempty"`
	// Fragments
	Fragments uint32 `protobuf:"varint,81,opt,name=fragments" json:"fragments,omitempty"`
	// Packet length operator
	PacketLengthOperator string `protobuf:"bytes,82,opt,name=packet_length_operator,json=packetLengthOperator" json:"packet_length_operator,omitempty"`
	// Packet length 1
	PacketLength1 uint32 `protobuf:"varint,83,opt,name=packet_length1,json=packetLength1" json:"packet_length1,omitempty"`
	// Packet length 2
	PacketLength2 uint32 `protobuf:"varint,84,opt,name=packet_length2,json=packetLength2" json:"packet_length2,omitempty"`
	// TTL operator
	TtlOperator string `protobuf:"bytes,85,opt,name=ttl_operator,json=ttlOperator" json:"ttl_operator,omitempty"`
	// TTL 1
	Ttl1 uint32 `protobuf:"varint,86,opt,name=ttl1" json:"ttl1,omitempty"`
	// TTL 2
	Ttl2 uint32 `protobuf:"varint,87,opt,name=ttl2" json:"ttl2,omitempty"`
	// No stats
	NoStats bool `protobuf:"varint,88,opt,name=no_stats,json=noStats" json:"no_stats,omitempty"`
	// Number of hits
	Hits uint64 `protobuf:"varint,89,opt,name=hits" json:"hits,omitempty"`
	// True if ICMP off
	IsIcmpOff bool `protobuf:"varint,90,opt,name=is_icmp_off,json=isIcmpOff" json:"is_icmp_off,omitempty"`
	// Qos group number
	QosGroup uint32 `protobuf:"varint,91,opt,name=qos_group,json=qosGroup" json:"qos_group,omitempty"`
	// Next hop type
	NextHopType string `protobuf:"bytes,92,opt,name=next_hop_type,json=nextHopType" json:"next_hop_type,omitempty"`
	// Next hop info
	NextHopInfo []*Ipv4AclBagNhInfo `protobuf:"bytes,93,rep,name=next_hop_info,json=nextHopInfo" json:"next_hop_info,omitempty"`
	// HW Next hop info
	HwNextHopInfo *Ipv4AclBagHwNhInfo `protobuf:"bytes,94,opt,name=hw_next_hop_info,json=hwNextHopInfo" json:"hw_next_hop_info,omitempty"`
	// Remark String
	Remark string `protobuf:"bytes,95,opt,name=remark" json:"remark,omitempty"`
	// Is dynamic ACE
	Dynamic bool `protobuf:"varint,96,opt,name=dynamic" json:"dynamic,omitempty"`
	// Source prefix object-group
	SourcePrefixGroup string `protobuf:"bytes,97,opt,name=source_prefix_group,json=sourcePrefixGroup" json:"source_prefix_group,omitempty"`
	// Destination prefix object-group
	DestinationPrefixGroup string `protobuf:"bytes,98,opt,name=destination_prefix_group,json=destinationPrefixGroup" json:"destination_prefix_group,omitempty"`
	// Source port object-group
	SourcePortGroup string `protobuf:"bytes,99,opt,name=source_port_group,json=sourcePortGroup" json:"source_port_group,omitempty"`
	// Destination port object-group
	DestinationPortGroup string `protobuf:"bytes,100,opt,name=destination_port_group,json=destinationPortGroup" json:"destination_port_group,omitempty"`
	// ACL Name
	AclName string `protobuf:"bytes,101,opt,name=acl_name,json=aclName" json:"acl_name,omitempty"`
	// Sequence String
	SequenceStr string `protobuf:"bytes,102,opt,name=sequence_str,json=sequenceStr" json:"sequence_str,omitempty"`
	// Fragment offset operator
	FragmentOffsetOperator string `protobuf:"bytes,103,opt,name=fragment_offset_operator,json=fragmentOffsetOperator" json:"fragment_offset_operator,omitempty"`
	// Fragment offset 1
	FragmentOffset1 uint32 `protobuf:"varint,104,opt,name=fragment_offset1,json=fragmentOffset1" json:"fragment_offset1,omitempty"`
	// Fragment offset 2
	FragmentOffset2 uint32 `protobuf:"varint,105,opt,name=fragment_offset2,json=fragmentOffset2" json:"fragment_offset2,omitempty"`
	// UDF BAG
	Udf []*AclUdfAce `protobuf:"bytes,106,rep,name=udf" json:"udf,omitempty"`
	// SET TTL
	SetTtl uint32 `protobuf:"varint,107,opt,name=set_ttl,json=setTtl" json:"set_ttl,omitempty"`
	// Fragment flags
	FragmentFlags uint32 `protobuf:"varint,108,opt,name=fragment_flags,json=fragmentFlags" json:"fragment_flags,omitempty"`
}

func (m *Ipv4AclEdmAce) Reset()                    { *m = Ipv4AclEdmAce{} }
func (m *Ipv4AclEdmAce) String() string            { return proto.CompactTextString(m) }
func (*Ipv4AclEdmAce) ProtoMessage()               {}
func (*Ipv4AclEdmAce) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Ipv4AclEdmAce) GetItemType() string {
	if m != nil {
		return m.ItemType
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetGrant() string {
	if m != nil {
		return m.Grant
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetProtocolOperator() uint32 {
	if m != nil {
		return m.ProtocolOperator
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetProtocol2() uint32 {
	if m != nil {
		return m.Protocol2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetSourceAddress() string {
	if m != nil {
		return m.SourceAddress
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSourceAddressMask() string {
	if m != nil {
		return m.SourceAddressMask
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetDestinationAddress() string {
	if m != nil {
		return m.DestinationAddress
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetDestinationAddressMask() string {
	if m != nil {
		return m.DestinationAddressMask
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSourceOperator() string {
	if m != nil {
		return m.SourceOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSourcePort1() uint32 {
	if m != nil {
		return m.SourcePort1
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetSourcePort2() uint32 {
	if m != nil {
		return m.SourcePort2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetSorceOperator() string {
	if m != nil {
		return m.SorceOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSorcePort1() uint32 {
	if m != nil {
		return m.SorcePort1
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetSorcePort2() uint32 {
	if m != nil {
		return m.SorcePort2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetDestinationOperator() string {
	if m != nil {
		return m.DestinationOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetDestinationPort1() uint32 {
	if m != nil {
		return m.DestinationPort1
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetDestinationPort2() uint32 {
	if m != nil {
		return m.DestinationPort2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetLogOption() string {
	if m != nil {
		return m.LogOption
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetCounterName() string {
	if m != nil {
		return m.CounterName
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetCapture() bool {
	if m != nil {
		return m.Capture
	}
	return false
}

func (m *Ipv4AclEdmAce) GetDscpPresent() bool {
	if m != nil {
		return m.DscpPresent
	}
	return false
}

func (m *Ipv4AclEdmAce) GetDscp() uint32 {
	if m != nil {
		return m.Dscp
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetDscp2() uint32 {
	if m != nil {
		return m.Dscp2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetDscpOperator() uint32 {
	if m != nil {
		return m.DscpOperator
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetPrecedencePresent() bool {
	if m != nil {
		return m.PrecedencePresent
	}
	return false
}

func (m *Ipv4AclEdmAce) GetPrecedence() uint32 {
	if m != nil {
		return m.Precedence
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetTcpFlagsOperator() string {
	if m != nil {
		return m.TcpFlagsOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetTcpFlags() uint32 {
	if m != nil {
		return m.TcpFlags
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetTcpFlagsMask() uint32 {
	if m != nil {
		return m.TcpFlagsMask
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetFragments() uint32 {
	if m != nil {
		return m.Fragments
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetPacketLengthOperator() string {
	if m != nil {
		return m.PacketLengthOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetPacketLength1() uint32 {
	if m != nil {
		return m.PacketLength1
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetPacketLength2() uint32 {
	if m != nil {
		return m.PacketLength2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetTtlOperator() string {
	if m != nil {
		return m.TtlOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetTtl1() uint32 {
	if m != nil {
		return m.Ttl1
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetTtl2() uint32 {
	if m != nil {
		return m.Ttl2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetNoStats() bool {
	if m != nil {
		return m.NoStats
	}
	return false
}

func (m *Ipv4AclEdmAce) GetHits() uint64 {
	if m != nil {
		return m.Hits
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetIsIcmpOff() bool {
	if m != nil {
		return m.IsIcmpOff
	}
	return false
}

func (m *Ipv4AclEdmAce) GetQosGroup() uint32 {
	if m != nil {
		return m.QosGroup
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetNextHopType() string {
	if m != nil {
		return m.NextHopType
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetNextHopInfo() []*Ipv4AclBagNhInfo {
	if m != nil {
		return m.NextHopInfo
	}
	return nil
}

func (m *Ipv4AclEdmAce) GetHwNextHopInfo() *Ipv4AclBagHwNhInfo {
	if m != nil {
		return m.HwNextHopInfo
	}
	return nil
}

func (m *Ipv4AclEdmAce) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetDynamic() bool {
	if m != nil {
		return m.Dynamic
	}
	return false
}

func (m *Ipv4AclEdmAce) GetSourcePrefixGroup() string {
	if m != nil {
		return m.SourcePrefixGroup
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetDestinationPrefixGroup() string {
	if m != nil {
		return m.DestinationPrefixGroup
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSourcePortGroup() string {
	if m != nil {
		return m.SourcePortGroup
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetDestinationPortGroup() string {
	if m != nil {
		return m.DestinationPortGroup
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetAclName() string {
	if m != nil {
		return m.AclName
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetSequenceStr() string {
	if m != nil {
		return m.SequenceStr
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetFragmentOffsetOperator() string {
	if m != nil {
		return m.FragmentOffsetOperator
	}
	return ""
}

func (m *Ipv4AclEdmAce) GetFragmentOffset1() uint32 {
	if m != nil {
		return m.FragmentOffset1
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetFragmentOffset2() uint32 {
	if m != nil {
		return m.FragmentOffset2
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetUdf() []*AclUdfAce {
	if m != nil {
		return m.Udf
	}
	return nil
}

func (m *Ipv4AclEdmAce) GetSetTtl() uint32 {
	if m != nil {
		return m.SetTtl
	}
	return 0
}

func (m *Ipv4AclEdmAce) GetFragmentFlags() uint32 {
	if m != nil {
		return m.FragmentFlags
	}
	return 0
}

type AclUdfAce struct {
	// UDF Name
	UdfName []byte `protobuf:"bytes,1,opt,name=udf_name,json=udfName,proto3" json:"udf_name,omitempty"`
	// UDF Value
	UdfValue uint32 `protobuf:"varint,2,opt,name=udf_value,json=udfValue" json:"udf_value,omitempty"`
	// UDF Mask
	UdfMask uint32 `protobuf:"varint,3,opt,name=udf_mask,json=udfMask" json:"udf_mask,omitempty"`
}

func (m *AclUdfAce) Reset()                    { *m = AclUdfAce{} }
func (m *AclUdfAce) String() string            { return proto.CompactTextString(m) }
func (*AclUdfAce) ProtoMessage()               {}
func (*AclUdfAce) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AclUdfAce) GetUdfName() []byte {
	if m != nil {
		return m.UdfName
	}
	return nil
}

func (m *AclUdfAce) GetUdfValue() uint32 {
	if m != nil {
		return m.UdfValue
	}
	return 0
}

func (m *AclUdfAce) GetUdfMask() uint32 {
	if m != nil {
		return m.UdfMask
	}
	return 0
}

// NH_Info structure
type Ipv4AclBagNhInfo struct {
	// The next hop
	NextHop string `protobuf:"bytes,1,opt,name=next_hop,json=nextHop" json:"next_hop,omitempty"`
	// Track name
	TrackName string `protobuf:"bytes,2,opt,name=track_name,json=trackName" json:"track_name,omitempty"`
	// The next hop status
	Status string `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	// The next hop at status
	AtStatus string `protobuf:"bytes,4,opt,name=at_status,json=atStatus" json:"at_status,omitempty"`
	// The nexthop exist
	IsAclNextHopExist bool `protobuf:"varint,5,opt,name=is_acl_next_hop_exist,json=isAclNextHopExist" json:"is_acl_next_hop_exist,omitempty"`
}

func (m *Ipv4AclBagNhInfo) Reset()                    { *m = Ipv4AclBagNhInfo{} }
func (m *Ipv4AclBagNhInfo) String() string            { return proto.CompactTextString(m) }
func (*Ipv4AclBagNhInfo) ProtoMessage()               {}
func (*Ipv4AclBagNhInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Ipv4AclBagNhInfo) GetNextHop() string {
	if m != nil {
		return m.NextHop
	}
	return ""
}

func (m *Ipv4AclBagNhInfo) GetTrackName() string {
	if m != nil {
		return m.TrackName
	}
	return ""
}

func (m *Ipv4AclBagNhInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Ipv4AclBagNhInfo) GetAtStatus() string {
	if m != nil {
		return m.AtStatus
	}
	return ""
}

func (m *Ipv4AclBagNhInfo) GetIsAclNextHopExist() bool {
	if m != nil {
		return m.IsAclNextHopExist
	}
	return false
}

// HW_NH_Info structure
type Ipv4AclBagHwNhInfo struct {
	// The Next Hop
	NextHop uint32 `protobuf:"varint,1,opt,name=next_hop,json=nextHop" json:"next_hop,omitempty"`
	// the next-hop type
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// VRF name
	VrfName string `protobuf:"bytes,3,opt,name=vrf_name,json=vrfName" json:"vrf_name,omitempty"`
}

func (m *Ipv4AclBagHwNhInfo) Reset()                    { *m = Ipv4AclBagHwNhInfo{} }
func (m *Ipv4AclBagHwNhInfo) String() string            { return proto.CompactTextString(m) }
func (*Ipv4AclBagHwNhInfo) ProtoMessage()               {}
func (*Ipv4AclBagHwNhInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Ipv4AclBagHwNhInfo) GetNextHop() uint32 {
	if m != nil {
		return m.NextHop
	}
	return 0
}

func (m *Ipv4AclBagHwNhInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Ipv4AclBagHwNhInfo) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func init() {
	proto.RegisterType((*Ipv4AclEdmAce_KEYS)(nil), "cisco_ios_xr_ipv4_acl_oper.ipv4_acl_and_prefix_list.access_list_manager.accesses.access.access_list_sequences.access_list_sequence.ipv4_acl_edm_ace_KEYS")
	proto.RegisterType((*Ipv4AclEdmAce)(nil), "cisco_ios_xr_ipv4_acl_oper.ipv4_acl_and_prefix_list.access_list_manager.accesses.access.access_list_sequences.access_list_sequence.ipv4_acl_edm_ace")
	proto.RegisterType((*AclUdfAce)(nil), "cisco_ios_xr_ipv4_acl_oper.ipv4_acl_and_prefix_list.access_list_manager.accesses.access.access_list_sequences.access_list_sequence.acl_udf_ace")
	proto.RegisterType((*Ipv4AclBagNhInfo)(nil), "cisco_ios_xr_ipv4_acl_oper.ipv4_acl_and_prefix_list.access_list_manager.accesses.access.access_list_sequences.access_list_sequence.ipv4_acl_bag_nh_info")
	proto.RegisterType((*Ipv4AclBagHwNhInfo)(nil), "cisco_ios_xr_ipv4_acl_oper.ipv4_acl_and_prefix_list.access_list_manager.accesses.access.access_list_sequences.access_list_sequence.ipv4_acl_bag_hw_nh_info")
}

func init() { proto.RegisterFile("ipv4_acl_edm_ace.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1258 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x5d, 0x77, 0x1b, 0x35,
	0x13, 0x3e, 0x6e, 0xd3, 0x24, 0x1e, 0xd7, 0x69, 0xa2, 0xa6, 0xa9, 0xfa, 0xb6, 0x6f, 0x09, 0x81,
	0x1e, 0x0c, 0x85, 0x80, 0xb7, 0x01, 0xca, 0x37, 0x05, 0xfa, 0x45, 0xdb, 0x24, 0x38, 0xa5, 0x50,
	0xbe, 0x54, 0x45, 0xd6, 0xda, 0x5b, 0xaf, 0x57, 0xdb, 0x95, 0x9c, 0xa6, 0xb7, 0xfc, 0x01, 0x6e,
	0x39, 0x87, 0x3b, 0xfe, 0x02, 0x17, 0x5c, 0x71, 0xc9, 0xff, 0xe2, 0x68, 0x66, 0x77, 0xbd, 0x76,
	0xcc, 0x35, 0xbd, 0x5a, 0xcd, 0x33, 0xcf, 0x68, 0x46, 0x23, 0xcd, 0xcc, 0xc2, 0x5a, 0x94, 0x1e,
	0x6c, 0x09, 0xa9, 0x62, 0xa1, 0xbb, 0x43, 0x21, 0x95, 0xde, 0x4c, 0x33, 0xe3, 0x0c, 0xfb, 0xb9,
	0xa6, 0x22, 0xab, 0x8c, 0x88, 0x8c, 0x15, 0x87, 0x99, 0x28, 0x59, 0x26, 0xd5, 0xd9, 0x66, 0x29,
	0xc9, 0xa4, 0x2b, 0xd2, 0x4c, 0x87, 0xd1, 0xa1, 0x88, 0x23, 0xeb, 0x36, 0xa5, 0x52, 0xda, 0x5a,
	0x5c, 0x8b, 0xa1, 0x4c, 0x64, 0x4f, 0x67, 0x39, 0xa6, 0x6d, 0xbe, 0x98, 0xe0, 0x58, 0xfd, 0x64,
	0xa4, 0x13, 0xa5, 0x67, 0xa3, 0x1b, 0x8f, 0xe1, 0xcc, 0x74, 0x78, 0xe2, 0xce, 0xf5, 0x87, 0x7b,
	0xac, 0x05, 0xcb, 0x55, 0x83, 0x44, 0x0e, 0x35, 0xaf, 0xad, 0xd7, 0x5a, 0xf5, 0xce, 0x12, 0xe1,
	0x77, 0x23, 0xeb, 0xb6, 0xe5, 0x50, 0xb3, 0x57, 0xe0, 0x54, 0xb1, 0x9d, 0x48, 0x46, 0xc3, 0x7d,
	0x9d, 0xf1, 0x63, 0xeb, 0xb5, 0x56, 0xb3, 0xb3, 0x54, 0xc0, 0xdb, 0x88, 0x6e, 0xfc, 0xb1, 0x0a,
	0xcb, 0xd3, 0xce, 0xd8, 0x79, 0xa8, 0x47, 0x4e, 0x0f, 0x85, 0x7b, 0x96, 0x6a, 0x1e, 0xa0, 0x83,
	0x45, 0x0f, 0xdc, 0x7f, 0x96, 0x6a, 0xf6, 0x3f, 0x58, 0x2c, 0xf6, 0xe0, 0x57, 0x70, 0xcf, 0x52,
	0x66, 0xab, 0x70, 0xa2, 0x97, 0xc9, 0xc4, 0xf1, 0x2d, 0x34, 0x22, 0x81, 0x5d, 0x86, 0x15, 0xcc,
	0xae, 0x32, 0x94, 0x48, 0xe9, 0x4c, 0xc6, 0xdf, 0x46, 0xd3, 0xe5, 0x42, 0xb1, 0x93, 0xe3, 0x7e,
	0xfb, 0x02, 0xe3, 0xef, 0xd0, 0xf6, 0x85, 0xcc, 0x2e, 0x40, 0xbd, 0x58, 0x07, 0xfc, 0x5d, 0x54,
	0x8e, 0x01, 0x76, 0x09, 0x96, 0xac, 0x19, 0x65, 0x4a, 0x0b, 0xd9, 0xed, 0x66, 0xda, 0x5a, 0x7e,
	0x15, 0xa3, 0x68, 0x12, 0x7a, 0x8d, 0x40, 0xb6, 0x09, 0xa7, 0x27, 0x69, 0x62, 0x28, 0xed, 0x80,
	0xbf, 0x87, 0xdc, 0x95, 0x09, 0xee, 0x3d, 0x69, 0x07, 0xec, 0x4d, 0x38, 0xdd, 0xd5, 0xd6, 0x45,
	0x89, 0x74, 0x91, 0x49, 0xca, 0xbd, 0xdf, 0x47, 0x3e, 0xab, 0xa8, 0x0a, 0x07, 0x57, 0x81, 0xcf,
	0x30, 0x20, 0x2f, 0x1f, 0xa0, 0xd5, 0xda, 0x51, 0x2b, 0x74, 0xe5, 0x6f, 0x8d, 0x42, 0x2b, 0xd3,
	0xf4, 0x21, 0x5d, 0x2f, 0xc1, 0x65, 0x92, 0x5e, 0x84, 0x93, 0x39, 0x31, 0x35, 0x99, 0x6b, 0xf3,
	0x8f, 0x30, 0x17, 0x0d, 0xc2, 0x76, 0x3d, 0x34, 0x45, 0x09, 0xf8, 0xc7, 0xd3, 0x94, 0x3c, 0x61,
	0x13, 0xde, 0x3e, 0x29, 0x12, 0x56, 0x75, 0xf6, 0x02, 0x34, 0x88, 0x46, 0xbe, 0x3e, 0xc5, 0x8d,
	0x00, 0x21, 0x72, 0x35, 0x41, 0x08, 0xf8, 0xb5, 0x29, 0x42, 0xc0, 0xda, 0xb0, 0x5a, 0xcd, 0x48,
	0xe9, 0xee, 0x33, 0x74, 0x57, 0x4d, 0x6f, 0xe9, 0xf4, 0x32, 0xac, 0x54, 0x4d, 0xc8, 0xf5, 0xe7,
	0xf4, 0x66, 0x2a, 0x0a, 0x0a, 0x60, 0x06, 0x39, 0xe0, 0x5f, 0xcc, 0x24, 0x07, 0xec, 0xff, 0x00,
	0xb1, 0xe9, 0x09, 0x93, 0x7a, 0x88, 0x5f, 0xc7, 0x10, 0xea, 0xb1, 0xe9, 0xed, 0x20, 0xe0, 0xf3,
	0xa6, 0xcc, 0x28, 0x71, 0x3a, 0xa3, 0xfa, 0xba, 0x81, 0x84, 0x46, 0x8e, 0x61, 0x71, 0x71, 0x58,
	0x50, 0x32, 0x75, 0xa3, 0x4c, 0xf3, 0x9b, 0xeb, 0xb5, 0xd6, 0x62, 0xa7, 0x10, 0xbd, 0x71, 0xd7,
	0xaa, 0xd4, 0x37, 0x07, 0xab, 0x13, 0xc7, 0x6f, 0xa1, 0xba, 0xe1, 0xb1, 0x5d, 0x82, 0x18, 0x83,
	0x39, 0x2f, 0xf2, 0xdb, 0x18, 0x1e, 0xae, 0x7d, 0xd9, 0xf8, 0x6f, 0xc0, 0xbf, 0x44, 0x90, 0x04,
	0xf6, 0x12, 0x34, 0x71, 0xb3, 0x32, 0x5d, 0x77, 0x50, 0x8b, 0x1e, 0xca, 0x3c, 0xbd, 0x01, 0x2c,
	0xcd, 0xb4, 0xd2, 0x5d, 0x2c, 0xf5, 0xc2, 0xef, 0x5d, 0xf4, 0xbb, 0x32, 0xd6, 0x14, 0xde, 0x2f,
	0x02, 0x8c, 0x41, 0x7e, 0x8f, 0x6e, 0x6a, 0x8c, 0xb0, 0xd7, 0x81, 0x39, 0x95, 0x8a, 0x30, 0x96,
	0x3d, 0x3b, 0x76, 0xbc, 0x8d, 0x39, 0x58, 0x76, 0x2a, 0xbd, 0xe1, 0x15, 0xa5, 0xf3, 0xf3, 0x50,
	0x2f, 0xd9, 0x7c, 0x87, 0x8a, 0xb5, 0x20, 0xb1, 0x97, 0x61, 0x69, 0xbc, 0x15, 0x3e, 0xfe, 0x5d,
	0x8a, 0xbf, 0x60, 0xe0, 0x93, 0xbf, 0x00, 0xf5, 0x30, 0x93, 0xbd, 0xa1, 0x4e, 0x9c, 0xe5, 0x5f,
	0x51, 0x49, 0x97, 0x00, 0xdb, 0x82, 0xb5, 0x54, 0xaa, 0x81, 0x76, 0x22, 0xd6, 0x49, 0xcf, 0xf5,
	0xc7, 0x21, 0x75, 0x30, 0xa4, 0x55, 0xd2, 0xde, 0x45, 0x65, 0x19, 0xd6, 0x25, 0x58, 0x9a, 0xb0,
	0x6a, 0xf3, 0x3d, 0xdc, 0xb8, 0x59, 0x65, 0xb7, 0x8f, 0xd0, 0x02, 0x7e, 0xff, 0x28, 0x2d, 0xf0,
	0x77, 0xea, 0x5c, 0xa5, 0x71, 0x7d, 0x4d, 0x0f, 0xc2, 0xb9, 0x71, 0xcf, 0x62, 0x30, 0xe7, 0x5c,
	0xdc, 0xe6, 0x0f, 0xe8, 0x4e, 0xfd, 0x3a, 0xc7, 0x02, 0xfe, 0x4d, 0x89, 0x05, 0xec, 0x1c, 0x2c,
	0x26, 0x46, 0x58, 0x27, 0x9d, 0xe5, 0xdf, 0xd2, 0xcb, 0x49, 0xcc, 0x9e, 0x17, 0x3d, 0xbd, 0x1f,
	0x39, 0xcb, 0x1f, 0xae, 0xd7, 0x5a, 0x73, 0x1d, 0x5c, 0xb3, 0x8b, 0xd0, 0x88, 0xac, 0x88, 0xd4,
	0x30, 0x15, 0x26, 0x0c, 0xf9, 0x77, 0x68, 0x51, 0x8f, 0xec, 0x6d, 0x35, 0x4c, 0x77, 0xc2, 0xd0,
	0xa7, 0xff, 0x89, 0xb1, 0xa2, 0x97, 0x99, 0x51, 0xca, 0xbf, 0xa7, 0xf4, 0x3f, 0x31, 0xf6, 0xa6,
	0x97, 0xd9, 0x06, 0x34, 0x13, 0x7d, 0xe8, 0x44, 0xdf, 0xa4, 0xd4, 0xc7, 0x7f, 0xa0, 0xb8, 0x3d,
	0x78, 0xcb, 0xa4, 0xd8, 0xca, 0xff, 0xaa, 0x55, 0x48, 0x51, 0x12, 0x1a, 0xfe, 0xe3, 0xfa, 0xf1,
	0x56, 0x23, 0xf8, 0xb5, 0xb6, 0xf9, 0xdf, 0x8f, 0xc1, 0xb1, 0x9f, 0x7d, 0xd9, 0x13, 0x49, 0x1f,
	0x03, 0x2c, 0xe3, 0xbf, 0x9d, 0x84, 0x86, 0xfd, 0x5d, 0x83, 0xe5, 0xfe, 0x53, 0x31, 0x79, 0x84,
	0x9f, 0xd6, 0x6b, 0xad, 0x46, 0xf0, 0xdb, 0xf3, 0x77, 0x04, 0x1f, 0x69, 0x7e, 0x8a, 0x66, 0xff,
	0xe9, 0x76, 0xe5, 0x1c, 0x6b, 0x30, 0x9f, 0xe9, 0xa1, 0xcc, 0x06, 0x5c, 0xe0, 0x25, 0xe5, 0x92,
	0x6f, 0x34, 0xdd, 0x67, 0x89, 0x1c, 0x46, 0x8a, 0x3f, 0xa2, 0xe7, 0x92, 0x8b, 0x95, 0x21, 0x96,
	0x47, 0x4f, 0x8f, 0x40, 0x56, 0x87, 0xd8, 0x2e, 0x6a, 0xe8, 0x35, 0x4c, 0xcd, 0xa4, 0x09, 0xa3,
	0xfd, 0x23, 0x33, 0xa9, 0x6a, 0xf9, 0x1a, 0xac, 0x54, 0xe6, 0x48, 0x6e, 0xa2, 0xd0, 0xe4, 0xd4,
	0x78, 0x98, 0x10, 0x77, 0x0b, 0xd6, 0xa6, 0xfb, 0x70, 0x6e, 0xd0, 0xa5, 0x72, 0x9d, 0x6a, 0xc6,
	0x64, 0x75, 0x0e, 0x16, 0x7d, 0x8a, 0xb0, 0xdb, 0x6a, 0xe4, 0x2d, 0x48, 0x15, 0x63, 0xa7, 0xf5,
	0x43, 0xac, 0xf8, 0x8d, 0xb1, 0x2e, 0xe3, 0x21, 0xbd, 0xe1, 0x02, 0xdb, 0x73, 0x99, 0x3f, 0x59,
	0xd1, 0x2f, 0x7c, 0x95, 0x58, 0xed, 0xc6, 0xa5, 0xda, 0xa3, 0x93, 0x15, 0xfa, 0x1d, 0x54, 0x97,
	0x55, 0xfb, 0x2a, 0x2c, 0x4f, 0x59, 0xb6, 0x79, 0x1f, 0xab, 0xe8, 0xd4, 0xa4, 0x45, 0x7b, 0x06,
	0x35, 0xe0, 0xd1, 0x2c, 0x6a, 0xc0, 0x7e, 0xaf, 0xc1, 0xf1, 0x51, 0x37, 0xe4, 0x8f, 0xb1, 0x92,
	0x7e, 0x79, 0x2e, 0x9e, 0xa1, 0x77, 0x31, 0xea, 0x86, 0xfe, 0xdf, 0xae, 0xe3, 0x83, 0x63, 0x67,
	0x61, 0xc1, 0x27, 0xca, 0xb9, 0x98, 0x0f, 0xf0, 0x18, 0xf3, 0x56, 0xbb, 0xfb, 0x2e, 0xf6, 0x3d,
	0xb1, 0x3c, 0x28, 0xb5, 0xf5, 0x98, 0x7a, 0x62, 0x81, 0x62, 0xe7, 0xde, 0x78, 0x04, 0x8d, 0xca,
	0x9e, 0xfe, 0x06, 0xfd, 0xb2, 0xfc, 0x1f, 0x3d, 0xd9, 0x59, 0x18, 0x75, 0x43, 0xbc, 0xc1, 0xf3,
	0x50, 0xf7, 0xaa, 0x03, 0x19, 0x8f, 0x74, 0xfe, 0x0b, 0xea, 0xb9, 0x0f, 0xbc, 0x5c, 0xd8, 0xe1,
	0x70, 0x38, 0x8e, 0x3a, 0x6f, 0xe7, 0xe7, 0xc2, 0xc6, 0x9f, 0x35, 0x58, 0x9d, 0xd5, 0x00, 0xb0,
	0x87, 0xe6, 0xf5, 0x9e, 0xff, 0xfb, 0x2e, 0xe4, 0x2d, 0xc1, 0x4f, 0x76, 0x97, 0x49, 0x35, 0xa0,
	0x40, 0x8e, 0xd1, 0x64, 0x47, 0x04, 0x43, 0x59, 0x83, 0x79, 0xdf, 0x7a, 0x47, 0x16, 0x7d, 0xd5,
	0x3b, 0xb9, 0xe4, 0x43, 0x94, 0x4e, 0xe4, 0xaa, 0x39, 0xfa, 0xdb, 0x95, 0x6e, 0x8f, 0x94, 0x6f,
	0xc1, 0x99, 0xc8, 0x62, 0x10, 0x65, 0x97, 0xd1, 0x87, 0x91, 0x75, 0xfc, 0x04, 0x8d, 0xd8, 0xc8,
	0x5e, 0x53, 0x71, 0x5e, 0xcb, 0xd7, 0xbd, 0x62, 0x43, 0xc1, 0xd9, 0x7f, 0x29, 0xfb, 0x23, 0xb1,
	0x37, 0xc7, 0xb1, 0xfb, 0x71, 0xe1, 0xbb, 0x34, 0x45, 0x8d, 0x6b, 0x4f, 0x3f, 0xc8, 0xf2, 0xb4,
	0x52, 0xc8, 0x0b, 0x07, 0x19, 0xa6, 0x75, 0x7f, 0x1e, 0x7f, 0x7b, 0xaf, 0xfc, 0x13, 0x00, 0x00,
	0xff, 0xff, 0x59, 0x9d, 0x97, 0x7d, 0xc8, 0x0c, 0x00, 0x00,
}
