// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_mpls_te_oper.mpls_te.tunnels.summary;

// MPLS TE Tunnel Summary Information
message mpls_te_tunnels_summary_info_bag_KEYS {
}

message mpls_te_tunnels_summary_info_bag {
    // PCALC tiebreaker
    uint32 pcalc_tiebreaker = 50;
    // Describes how the path selection tiebreaker was specified:default, or globally set
    string tiebreaker_qualifier = 51;
    // Status of te_control
    string te_process_status = 52;
    // Status of rsvp
    bool is_rsvp_process_enabled = 53;
    // TRUE if forwarding is enabled
    bool is_forwarding_enabled = 54;
    // Total tunnel heads activated
    uint32 activated_heads = 55;
    // Total tunnel heads deactivated
    uint32 deactivated_heads = 56;
    // Number of heads recovered
    uint32 recovered_heads = 57;
    // TRUE if periodic reoptimization is on
    bool is_periodic_reoptimization_on = 58;
    // Reoptimization period in seconds
    uint32 reoptimization_period = 59;
    // Time left till next reoptimization (seconds)
    uint32 next_reoptimization_timer = 60;
    // Counter with number of auto-bw enabled tunnels
    uint32 auto_bandwidth_tunnels = 61;
    // Collection period in minutes
    uint32 auto_bandwidth_collection_period = 62;
    // TRUE if periodic frr promotion is on
    bool is_promotion_on = 63;
    // FRR promotion period in seconds
    uint32 promotion_period = 64;
    // Time left till next FRR promotion (seconds)
    uint32 next_promotion_timer = 65;
    // Tunnel head check period (seconds)
    uint32 tunnel_check_period = 66;
    // Time left till next FRR promotion (seconds)
    uint32 next_check_time = 67;
    // Tunnel head verify period (seconds)
    uint32 tunnel_verify_period = 68;
    // Time left till next FRR promotion (seconds)
    uint32 next_verify_timer = 69;
    // FRR tunnels in Up state at head end
    uint32 frr_head_tunnels = 70;
    // FRR protected tunnels in Up state at head end
    uint32 protected_head_tunnels = 71;
    // FRR rerouted tunnels in Up state at head end
    uint32 rerouted_head_tunnels = 72;
    // FRR tunnels at mid point
    uint32 frr_mid_point_tunnels = 73;
    // FRR protected tunnels at mid point
    uint32 protected_mid_point_tunnels = 74;
    // FRR rerouted tunnels at mid point
    uint32 rerouted_mid_point_tunnels = 75;
    // FRR link protected tunnels
    uint32 link_protected_tunnels = 76;
    // FRR node protected tunnels
    uint32 node_protected_tunnels = 77;
    // FRR BW protected tunnels
    uint32 bw_protected_tunnels = 78;
    // P2P FRR tunnels in Up state at head end
    uint32 frr_p2_p_head_tunnels = 79;
    // P2P FRR protected tunnels in Up state at head end
    uint32 protected_p2_p_head_tunnels = 80;
    // P2P FRR rerouted tunnels in Up state at head end
    uint32 rerouted_p2_p_head_tunnels = 81;
    // P2P FRR tunnels at mid point
    uint32 frr_p2_p_mid_point_tunnels = 82;
    // P2P FRR protected tunnels at mid point
    uint32 protected_p2_p_mid_point_tunnels = 83;
    // P2P FRR rerouted tunnels at mid point
    uint32 rerouted_p2_p_mid_point_tunnels = 84;
    // P2P FRR link protected tunnels
    uint32 link_protected_p2_p_tunnels = 85;
    // P2P FRR node protected tunnels
    uint32 node_protected_p2_p_tunnels = 86;
    // P2P FRR BW protected tunnels
    uint32 bw_protected_p2_p_tunnels = 87;
    // FRR backup tunnels in Up state
    uint32 backup_tunnels = 88;
    // FRR backup tunnels assigned
    uint32 backups_assigned = 89;
    // FRR Protected Interfaces
    uint32 frr_protected_interfaces = 90;
    // FRR Rerouted Interfaces
    uint32 rerouted_interfaces = 91;
    // p2p Tunnel interfaces
    uint32 p2_p_head_tunnels = 92;
    // p2p Tunnel interfaces in Up state
    uint32 up_p2_p_head_tunnels = 93;
    // p2p Tunnel up via a dynamic path
    uint32 dynamic_up_p2_p_head_tunnels = 94;
    // p2p Tunnel interfaces with FRR configuration
    uint32 frr_config_p2_p_head_tunnels = 95;
    // p2p Destinations at Head
    uint32 p2_p_head_destinations = 96;
    // p2p Destinations in Up state at Head
    uint32 p2_p_head_destinations_up = 97;
    // p2p S2Ls BW Protected
    uint32 bw_protected_p2_p_s2_ls = 98;
    // p2p S2Ls Link Protected
    uint32 link_protected_p2_p_s2_ls = 99;
    // p2p S2Ls in Up state at Head
    uint32 up_p2_p_head_s2_ls = 100;
    // p2p S2Ls in signalling-proceeding state at Head
    uint32 proceeding_p2_p_head_s2_ls = 101;
    // p2p S2Ls recovering at Head
    uint32 recovering_p2_p_head_s2_ls = 102;
    // p2p S2Ls with FRR requested at Head
    uint32 frr_p2_p_head_s2_ls = 103;
    // p2p S2Ls FRR Protected at Head
    uint32 protected_p2_p_head_s2_ls = 104;
    // p2p S2Ls FRR Rerouted at Head
    uint32 rerouted_p2_p_head_s2_ls = 105;
    // p2p S2Ls at Mid
    uint32 p2_p_mid_point_s2_ls = 106;
    // p2p S2Ls in Up state at Mid
    uint32 up_p2_p_mid_point_s2_ls = 107;
    // p2p S2Ls in signalling=proceeding state at Mid
    uint32 proceeding_p2_p_mid_point_s2_ls = 108;
    // p2p S2Ls with FRR requested at Mid
    uint32 frr_p2_p_mid_point_s2_ls = 109;
    // p2p S2Ls FRR Protected at Mid
    uint32 protected_p2_p_mid_point_s2_ls = 110;
    // p2p S2Ls FRR Rerouted at Mid
    uint32 rerouted_p2_p_mid_point_s2_ls = 111;
    // p2p S2Ls at Tail
    uint32 p2_p_tail_s2_ls = 112;
    // p2p S2Ls in Up state at Tail
    uint32 up_p2_p_tail_s2_ls = 113;
    // p2p Tunnel tail interfaces
    uint32 p2_p_tail_tunnels = 114;
    // Tunnels configured with Path Protect
    uint32 path_protect_configured_tunnels = 115;
    // Path Protect configured tunnels connected/up
    uint32 path_protect_configured_tunnels_up = 116;
    // Tunnels with standby LSP up
    uint32 path_protect_configured_tunnels_standby_up = 117;
    // Link diverse paths
    uint32 link_diverse_paths = 118;
    // Node diverse paths
    uint32 node_diverse_paths = 119;
    // Link and Node diverse paths
    uint32 link_and_node_diverse_paths = 120;
    // User defined paths
    uint32 user_defined_paths = 121;
    // P2MP Tunnel interfaces
    uint32 p2_mp_head_tunnels = 122;
    // P2MP Tunnel interfaces in Up state
    uint32 up_p2_mp_head_tunnels = 123;
    // P2MP Tunnel interfaces with FRR configuration
    uint32 frr_config_p2_mp_head_tunnels = 124;
    // P2MP Destinations at Head
    uint32 p2_mp_head_destinations = 125;
    // P2MP Destinations in Up state at Head
    uint32 up_p2_mp_head_destinations = 126;
    // P2MP S2Ls BW Protected
    uint32 bw_protected_p2_mp_s2_ls = 127;
    // P2MP S2Ls Link Protected
    uint32 link_protected_p2_mp_s2_ls = 128;
    // P2MP S2Ls in Up state at Head
    uint32 up_p2_mp_head_s2_ls = 129;
    // P2MP S2Ls in signalling-proceeding state at Head
    uint32 proceeding_p2_mp_head_s2_ls = 130;
    // P2MP S2Ls with FRR requested at Head
    uint32 frr_p2_mp_head_s2_ls = 131;
    // P2MP S2Ls FRR Protected at Head
    uint32 protected_p2_mp_head_s2_ls = 132;
    // P2MP S2Ls FRR Rerouted at Head
    uint32 rerouted_p2_mp_head_s2_ls = 133;
    // P2MP S2Ls at Mid
    uint32 p2_mp_mid_point_s2_ls = 134;
    // P2MP S2Ls in Up state at Mid
    uint32 up_p2_mp_mid_point_s2_ls = 135;
    // P2MP S2Ls in signalling=proceeding state at Mid
    uint32 proceeding_p2_mp_mid_point_s2_ls = 136;
    // P2MP S2Ls with FRR requested at Mid
    uint32 frr_p2_mp_mid_point_s2_ls = 137;
    // P2MP S2Ls FRR Protected at Mid
    uint32 protected_p2_mp_mid_point_s2_ls = 138;
    // P2MP S2Ls FRR Rerouted at Mid
    uint32 rerouted_p2_mp_mid_point_s2_ls = 139;
    // P2MP S2Ls at Tail
    uint32 p2_mp_tail_s2_ls = 140;
    // P2MP S2Ls in Up state at Tail
    uint32 up_p2_mp_tail_s2_ls = 141;
    // Bidirectional Head Tunnel interfaces
    uint32 bidir_head_tunnels = 142;
    // Connected Bidirectional Head Tunnel interfaces
    uint32 bidir_head_tunnels_up = 143;
    // Associated Bidirectional Head Tunnels
    uint32 bidir_head_tunnels_associated = 144;
    // Corouted Bidirectional Head Tunnels
    uint32 bidir_head_tunnels_corouted = 145;
    // Connected Bidirectional Head Tunnel interfaces
    uint32 bidir_head_ls_ps_up = 146;
    // Proceeding Bidirectional Head LSPs
    uint32 bidir_head_ls_ps_proceeding = 147;
    // Associated Bidirectional Head LSPs
    uint32 bidir_head_ls_ps_associated = 148;
    // Standby Bidirectional Head LSPs
    uint32 bidir_head_ls_ps_standby = 149;
    // Bidirectional Mid Tunnel interfaces
    uint32 bidir_mid_tunnels = 150;
    // Connected Bidirectional Mid Tunnel interfaces
    uint32 bidir_mid_tunnels_up = 151;
    // Proceeding Bidirectional Mid LSPs
    uint32 bidir_mid_ls_ps_proceeding = 152;
    // Associated Bidirectional Mid LSPs
    uint32 bidir_mid_ls_ps_associated = 153;
    // Standby Bidirectional Mid LSPs
    uint32 bidir_mid_ls_ps_standby = 154;
    // Bidirectional Tail LSPs
    uint32 bidir_tail_ls_ps = 155;
    // Connected Bidirectional Tail LSPs
    uint32 bidir_tail_ls_ps_up = 156;
    // Proceeding Bidirectional Tail LSPs
    uint32 bidir_tail_ls_ps_proceeding = 157;
    // Associated Bidirectional Tail LSPs
    uint32 bidir_tail_ls_ps_associated = 158;
    // Standby Bidirectional Tail LSPs
    uint32 bidir_tail_ls_ps_standby = 159;
    // Corouted Bidirectional Tail LSPs
    uint32 bidir_tail_ls_ps_corouted = 160;
    // Autobackup summary
    mpls_te_autotun_backup_summary_info autobackup_summary = 161;
    // Automesh summary
    mpls_te_autotun_mesh_summary_info auto_mesh_summary = 162;
    // Automesh Onehop summary
    mpls_te_autotun_mesh_onehop_summary_info auto_mesh_one_hop_summary = 163;
    // GMPLS-UNI summary
    mpls_te_gmpls_uni_summary_info gmpls_uni_summary = 164;
    // GMPLS-NNI summary
    mpls_te_gmpls_nni_summary_info gmpls_nni_summary = 165;
    // Current Tunnel convergemce summary information
    te_conv_tbl_summary_bag current_tunnel_convergence_summary = 166;
    // Last Tunnel convergemce summary information
    te_conv_tbl_summary_bag last_tunnel_convergence_summary = 167;
    // Auto-tunnel server tunnel summary
    mpls_te_autotun_svr_summary_info auto_tun_server_summary = 168;
}

// P2MP auto-tunnel summary per client information
message mpls_te_autotun_p2mp_info {
    // Total number of client P2MP auto-tunnels
    uint32 auto_p2_mp_tunnel = 1;
    // Total number of client P2MP auto-tunnel destinations
    uint32 auto_p2_mp_destinations = 2;
    // Total number of client P2MP auto-tunnel destinations that are up
    uint32 up_auto_p2_mp_destinations = 3;
    // Total number of client P2MP auto-tunnel destinations that are down
    uint32 down_auto_p2_mp_destinations = 4;
    // Total number of client P2MP auto-tunnels that are up
    uint32 up_auto_p2_mp_tunnels = 5;
    // Total number of client P2MP auto-tunnels that are down
    uint32 down_auto_p2_mp_tunnels = 6;
    // Total number of client P2MP auto-tunnels that are FRR enabled
    uint32 frr_auto_p2_mp_tunnels = 7;
}

// P2P auto-tunnel summary per client information
message mpls_te_autotun_p2p_info {
    // Total number of client P2P auto-tunnels
    uint32 auto_p2_p_tunnel = 1;
    // Total number of client P2P auto-tunnels that are up
    uint32 up_auto_p2_p_tunnels = 2;
    // Total number of client P2P auto-tunnels that are down
    uint32 down_auto_p2_p_tunnels = 3;
}

// Auto-tunnel server client summary
message mpls_te_autotun_svr_info {
    // P2MP info for a client
    mpls_te_autotun_p2mp_info p2_mp_info = 1;
    // P2P info for a client
    mpls_te_autotun_p2p_info p2_p_info = 2;
    // Client's protocol type
    string protocol_type = 3;
    // Client Instance name
    string client_instance_name = 4;
    // Client ID
    uint32 client_id = 5;
}

// Auto-tunnel server summary information
message mpls_te_autotun_svr_summary_info {
    // List of auto-tunnel server clients
    repeated mpls_te_autotun_svr_info clients_summary = 1;
    // Total number of P2MP auto-tunnels
    mpls_te_autotun_p2mp_info total_auto_p2_mp_tunnels = 2;
    // Total number of P2P auto-tunnels
    mpls_te_autotun_p2p_info total_auto_p2_p_tunnels = 3;
}

// Autotunnel backup summary information
message mpls_te_autotun_backup_summary_info {
    // Total number of autobackup tunnels
    uint32 autobackups = 1;
    // Total number of autobackup tunnels that are up
    uint32 up_autobackups = 2;
    // Total number of autobackup tunnels that are down
    uint32 down_autobackups = 3;
    // Total number of autobackup tunnels that are unused
    uint32 unused_autobackups = 4;
    // Total number of autobackup tunnels that are NHOP
    uint32 next_hop_autobackups = 5;
    // Total number of autobackup tunnels that are NNHOP
    uint32 next_next_hop_autobackups = 6;
    // Total number of autobackup tunnels that are using SRLG strict
    uint32 srlg_strict_autobackups = 7;
    // Total number of autobackup tunnels that are using SRLG preferred
    uint32 srlg_preferred_autobackups = 8;
    // Total number of autobackup tunnels that are using weighted SRLG
    uint32 srlg_weighted_autobackups = 9;
    // Total number of autobackup protected LSPs with NHOP and no SRLG
    uint32 next_hop_autobackup_protected_ls_ps = 10;
    // Total number of autobackup protected LSPs with NNHOP and no SRLG
    uint32 next_next_hop_autobackup_protected_ls_ps = 11;
    // Total number of autobackup protected LSPs with NHOP and SRLG
    uint32 next_hop_srlg_autobackup_protected_ls_ps = 12;
    // Total number of autobackup protected LSPs with NNHOP and SRLG
    uint32 next_next_hop_srlg_autobackup_protected_ls_ps = 13;
    // Total number of autobackup protected S2L Families with NHOP and no SRLG
    uint32 next_hop_autobackup_protected_s2_l_families = 14;
    // Total number of autobackup protected S2L Families with NNHOP and no SRLG
    uint32 next_next_hop_autobackup_protected_s2_l_families = 15;
    // Total number of autobackup protected S2L Families with NHOP and SRLG
    uint32 next_hop_srlg_autobackup_protected_s2_l_families = 16;
    // Total number of autobackup protected S2L Families with NNHOP and SRLG
    uint32 next_next_hop_srlg_autobackup_protected_s2_l_families = 17;
    // Total number of autobackup protected S2Ls with NHOP and no SRLG
    uint32 next_hop_autobackup_protected_s2_ls = 18;
    // Total number of autobackup protected S2Ls with NNHOP and no SRLG
    uint32 next_next_hop_autobackup_protected_s2_ls = 19;
    // Total number of autobackup protected S2Ls with NHOP and SRLG
    uint32 next_hop_srlg_autobackup_protected_s2_ls = 20;
    // Total number of autobackup protected S2Ls with NNHOP and SRLG
    uint32 next_next_hop_srlg_autobackup_protected_s2_ls = 21;
}

// Autotunnel mesh summary information
message mpls_te_autotun_mesh_summary_info {
    // Total number of automesh tunnels
    uint32 auto_mesh_tunnels = 1;
    // Total number of automesh tunnels that are up
    uint32 up_auto_mesh_tunnels = 2;
    // Total number of automesh tunnels that are down
    uint32 down_auto_mesh_tunnels = 3;
    // Total number of automesh tunnels that are FRR enabled
    uint32 frr_auto_mesh_tunnels = 4;
    // Total number of automesh mesh-groups
    uint32 auto_mesh_groups = 5;
    // Total number of automesh destinations
    uint32 auto_mesh_destinations = 6;
}

// Autotunnel mesh onehop summary information
message mpls_te_autotun_mesh_onehop_summary_info {
    // Total number of automesh onehop tunnels
    uint32 auto_mesh_one_hop_tunnels = 1;
    // Total number of automesh onehop tunnels that are up
    uint32 up_auto_mesh_one_hop_tunnels = 2;
    // Total number of automesh onehop tunnels that are down
    uint32 down_auto_mesh_one_hop_tunnels = 3;
    // Total number of automesh onehop tunnels that are FRR enabled
    uint32 frr_auto_mesh_tunnels = 4;
    // Total number of automesh onehop mesh-groups
    uint32 auto_mesh_one_hop_groups = 5;
    // Total number of automesh onehop destinations
    uint32 auto_mesh_one_hop_destinations = 6;
}

// TE LSP datapoint information
message te_lsp_datapoint_info {
}

// Convergence table bag entry
message te_table_datapoint_info {
}

// TE tunnels convergence summary information bag
message te_conv_tbl_summary_bag {
    // FRR active Tunnel count
    uint32 tunnel_frr_active_count = 1;
    // FRR triggered Tunnel count
    uint32 tunnel_frr_total_count = 2;
    // Tunnel converged count
    uint32 tunnel_converged_count = 3;
    // Tunnel convergence complete timestamp (clocktime in nsecs)
    uint64 tunnel_total_convergence_complete_time = 4;
    // Table path-out entry
    te_table_datapoint_info table_path_out = 5;
    // Table resv-in entry
    te_table_datapoint_info table_resv_in = 6;
    // Table label rewrite entry
    te_table_datapoint_info table_label_rewrite = 7;
    // Table PCALC entry
    te_table_datapoint_info table_pcalc = 8;
    // Table Tunnel rewrite entry
    te_table_datapoint_info table_tunnel_rewrite = 9;
    // Table FRR trigger entry
    te_table_datapoint_info table_frr_trigger = 10;
}

// GMPLS-UNI summary information
message mpls_te_gmpls_uni_summary_info {
    // Tunnel heads in up state
    uint32 heads_up = 1;
    // Tunnel heads in down state
    uint32 heads_down = 2;
    // Tunnel tails in up state
    uint32 tails_up = 3;
    // Tunnel tails in down state
    uint32 tails_down = 4;
}

// GMPLS-NNI summary information
message mpls_te_gmpls_nni_summary_info {
    // Tunnel heads in up state
    uint32 heads_up = 1;
    // Tunnel heads in down state
    uint32 heads_down = 2;
    // Tunnel mids in up state
    uint32 mids_up = 3;
    // Tunnel mids in down state
    uint32 mids_down = 4;
    // Tunnel tails in up state
    uint32 tails_up = 5;
    // Tunnel tails in down state
    uint32 tails_down = 6;
}

