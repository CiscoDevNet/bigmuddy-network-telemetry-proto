// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_mpls_te_oper.mpls_te.p2p_p2mp_tunnel.tunnel_remotes.tunnel_remote;

// A P2MP LSP
message mpls_te_p2mp_lsp_KEYS {
    uint32 lsp_id = 1;
    uint32 tunnel_id = 2;
    string extended_tunnel_id = 3;
    string source_address = 4;
    string c_type = 5;
    string destination_address = 6;
    uint32 p2_mp_id = 7;
}

message mpls_te_p2mp_lsp {
    // Signaled Name
    string signaled_name = 50;
    // P2MP LSP has FRR Failed
    bool is_frr_failed = 51;
    // P2MP LSP FRR active reason
    uint32 frr_active_reason = 52;
    // P2MP LSP Bandwidth
    uint32 lsp_bandwidth = 53;
    // LSP setup priority
    uint32 lsp_setup_priority = 54;
    // LSP hold priority
    uint32 lsp_hold_priority = 55;
    // The LSP bandwidth type
    string lsp_bandwidth_type = 56;
    // Do the class type and priority match a DSTE class
    bool dste_class_match = 57;
    // Matching DSTE class index
    uint32 dste_class_index = 58;
    // FEC for the LSP
    te_lsp_fec_t lsp_fec = 59;
    // The type of this LSP
    string type = 60;
    // array of S2L structures
    repeated mpls_te_p2mp_s2l s2_l_list = 61;
    // Time in seconds since the tunnel was up
    uint32 uptime = 62;
    // Number of connected S2Ls
    uint32 s2_ls_up = 63;
    // Number of proceeding S2Ls
    uint32 s2_ls_proceeding = 64;
    // Number of down S2Ls
    uint32 s2_ls_down = 65;
    // Reason for re-optimization
    string reoptimize_reason = 66;
    // Re-optimize trigger
    string reoptimize_trigger = 67;
    // Time in seconds left to take next action if any
    uint32 timer_left = 68;
    // True for passive tunnel
    bool is_passive = 69;
    // True for tunnel head
    bool is_interface = 70;
    // Time in seconds since the last path change
    uint32 last_path_change = 71;
    // Persistent forwarding statistics for number of bytes. Clear counters will not reset the counter
    uint64 persistent_bytes = 72;
    // Persistent forwarding statistics for Number of packets. Clear counters will not reset the counter
    uint64 persistent_packets = 73;
}

// The value of the counter
message rsvp_ng_api_stats_entry_bag {
    // Count
    uint64 count = 1;
}

// Collection of stats for a given event type
message rsvp_ng_api_stats_bag {
    // The CTX event of the stats
    string ctx_event_type = 1;
    // The ctrl event of the stats
    string ctrl_event_type = 2;
    // Number of scheduled events
    rsvp_ng_api_stats_entry_bag scheduled = 3;
    // Number of transmitted events
    rsvp_ng_api_stats_entry_bag tx = 4;
    // Number of received events
    rsvp_ng_api_stats_entry_bag rx = 5;
    // Number of dropped Tx events
    rsvp_ng_api_stats_entry_bag drop_tx = 6;
    // Number of dropped Rx events
    rsvp_ng_api_stats_entry_bag drop_rx = 7;
    // Number of postponed TX events
    rsvp_ng_api_stats_entry_bag postponed_tx = 8;
}

// Information about the event for an API CTX
message rsvp_ng_api_ctx_event_bag {
    // The event type
    string type = 1;
    // Producer summary replay ID
    uint64 producer_summary_replay_id = 2;
    // TRUE if this event is sent
    bool is_sent = 3;
    // Age the event (in sec)
    uint32 age = 4;
    // Reason if thus event is filtered during transmission
    string filter_reason = 5;
}

// CTX History Buffer
message rsvp_ng_api_ctx_history {
    // Event Timestamp
    uint32 timestamp = 1;
    // Event Type
    string event_type = 2;
    // Event Data
    repeated uint32 event_data = 3;
}

// Bag representing the CTX in the RSVP API
message rsvp_ng_api_ctx_bag {
    // Producer summary replay ID
    uint64 producer_summary_replay_id = 1;
    // Producer summary replay base ID
    uint32 producer_summary_replay_base_id = 2;
    // Consumer summary replay ID
    uint64 consumer_summary_replay_id = 3;
    // Consumer summary replay base ID
    uint32 consumer_summary_replay_base_id = 4;
    // Flags
    uint32 flags = 5;
    // Origin of this CTX
    string origin = 6;
    // Statistics
    repeated rsvp_ng_api_stats_bag statistics = 7;
    // Events
    repeated rsvp_ng_api_ctx_event_bag events = 8;
    // History
    repeated rsvp_ng_api_ctx_history history = 9;
    // Slave Producer summary replay ID
    uint64 slave_producer_summary_replay_id = 10;
    // Slave Consumer summary replay ID
    uint64 slave_consumer_summary_replay_id = 11;
}

// RSVP ERO IPV4 subobject
message rsvp_mgmt_ero_ipv4_subobj {
    // ERO Entry Is Strict
    bool is_strict_route = 1;
    // The ERO IPV4 Address
    string ero_address = 2;
    // ERO Prefix Length
    uint32 prefix_length = 3;
}

// RSVP ERO UNNUM subobject
message rsvp_mgmt_ero_unnum_subobj {
    // ERO Entry Is Strict
    bool is_strict_route = 1;
    // The Interface ID in ERO
    uint32 ero_interface_id = 2;
    // The Router ID in ERO
    string ero_router_id = 3;
    // Status of ERO
    string status = 4;
}

// Union of the different RSVP ERO types
message rsvp_mgmt_ero_subobj {
    string ero_type = 1;
    // IPV4 ERO Sub Object
    rsvp_mgmt_ero_ipv4_subobj ipv4_ero_sub_object = 2;
    // Unnumbered ERO Sub Object
    rsvp_mgmt_ero_unnum_subobj unnumbered_ero_sub_object = 3;
}

// RSVP RRO IPV4 Subobject Flags
message rsvp_mgmt_rro_ipv4_subobj_flags {
    // Local Protection Available
    bool is_protection_available = 1;
    // Local Protection In Use
    bool is_protection_in_use = 2;
    // Bandwidth Protection Available
    bool is_bandwidth_protected = 3;
    // Node Protection Available
    bool is_node_protection_available = 4;
    // Node ID In Use
    bool is_node_id = 5;
}

// RSVP RRO Label Subobject Flags
message rsvp_mgmt_rro_label_subobj_flags {
    // Label is Global across all interfaces
    bool is_global_label = 1;
}

// RSVP RRO UNNUMBERED Subobject Flags
message rsvp_mgmt_rro_unnumbered_subobj_flags {
    // Local Protection Available
    bool is_protection_available = 1;
    // Local Protection In Use
    bool is_protection_in_use = 2;
    // Bandwidth Protection Available
    bool is_bandwidth_protected = 3;
    // Node Protection Available
    bool is_node_protection_available = 4;
    // Node ID In Use
    bool is_node_id = 5;
}

// RSVP RRO IPV4 subobject
message rsvp_mgmt_rro_ipv4_subobj {
    // The RRO IPV4 Subobject Flags
    rsvp_mgmt_rro_ipv4_subobj_flags flags = 1;
    // The RRO IPV4 Address
    string rro_address = 2;
}

// RSVP RRO Label subobject
message rsvp_mgmt_rro_label_subobj {
    // The RRO Subobject Label Flags
    rsvp_mgmt_rro_label_subobj_flags flags = 1;
    // The RRO Subobject Label Value
    uint32 label = 2;
    // Is the RRO Subobject Label Variable Length
    bool is_label_variable_length = 3;
    // The RRO Subobject Variable Length Label
    repeated uint32 variable_length_label = 4;
}

// RSVP RRO Unnumbered subobject
message rsvp_mgmt_rro_unnumbered_subobj {
    // The RRO Subobject Unnumbered Flags
    rsvp_mgmt_rro_unnumbered_subobj_flags flags = 1;
    // The RRO Interface Address
    string interface_address = 2;
    // The RRO Interface ID
    uint32 interface_id = 3;
}

// RSVP RRO SRLG subobject
message rsvp_mgmt_rro_srlg_subobj {
    // The RRO Subobject SRLGs
    repeated uint32 srl_gs = 1;
}

// Union of the different RSVP RRO types
message rsvp_mgmt_rro_subobj {
    string rro_type = 1;
    // IPV4 RRO Sub Object
    rsvp_mgmt_rro_ipv4_subobj ipv4_rro_sub_object = 2;
    // Label RRO Sub Object
    rsvp_mgmt_rro_label_subobj label_rro_sub_object = 3;
    // Unnumbered RRO Sub Object
    rsvp_mgmt_rro_unnumbered_subobj unnumbered_rro_sub_object = 4;
    // SRLG RRO Sub Object
    rsvp_mgmt_rro_srlg_subobj srlg_rro_sub_object = 5;
}

// A sub-LSP FEC
message te_s2l_fec_t {
    // sub-LSP subgroup ID
    uint32 s2_l_fec_subgroup_id = 1;
    // LSP ID
    uint32 s2_l_fec_lsp_id = 2;
    // Tunnel ID
    uint32 s2_l_fec_tunnel_id = 3;
    // Extended tunnel ID
    string s2_l_fec_extended_tunnel_id = 4;
    // LSP source address
    string s2_l_fec_source = 5;
    // sub-LSP destination address
    string s2_l_fec_dest = 6;
    // P2MP ID
    uint32 s2_l_fec_p2_mp_id = 7;
    // Subgroup Originator
    string s2_l_fec_subgroup_originator = 8;
    // Session identifier (ctype)
    string s2_l_fec_c_type = 9;
    // VRF; currently only for GMPLS tunnels
    string s2_l_fec_vrf = 10;
}

// TE IPv4 unnumbered address type
message te_addr_type_ipv4_unnum {
    // IPv4 router ID
    string router_id = 1;
    // Interface index
    uint32 interface_index = 2;
}

message addr {
    string type = 1;
    // IPv4 address
    string ipv4_address = 2;
    // IPv4 unnumbered address
    te_addr_type_ipv4_unnum ipv4_unnumbered_address = 3;
}

message te_addr_t_ {
    // TE Address
    addr te_addr = 1;
}

// C-type-specific LSP FEC data
message te_lsp_fec_ctype_data_t {
    string fec_c_type = 1;
    // P2P LSP destination
    string p2_p_lsp_destination = 2;
    // P2MP ID
    uint32 fec_destination_p2_mp_id = 3;
}

// A LSP FEC
message te_lsp_fec_t {
    // LSP ID
    uint32 fec_lsp_id = 1;
    // Tunnel ID
    uint32 fec_tunnel_id = 2;
    // Extended tunnel ID
    string fec_extended_tunnel_id = 3;
    // Tunnel source address
    string fec_source = 4;
    // Destination or P2MP ID
    te_lsp_fec_ctype_data_t fec_destination_info = 5;
    // VRF; currently only for GMPLS tunnels
    string fec_vrf = 6;
}

// Affinity name constraints
message affinity_name_bag {
    // Constraint type
    uint32 constraint_type = 1;
    // Deprecated
    uint32 constraint_value = 2;
    // Deprecated
    uint32 forward_ref_value = 3;
    // Constraint value
    repeated uint32 constraint_extended_value = 4;
    // Reference bits for undefined affinity names
    repeated uint32 extended_forward_ref_value = 5;
}

// MPLS TE tunnel Affinity information
message mpls_te_tunnels_affinity_info {
    // The affinity bits (colors)
    uint32 affinity_bits = 1;
    // The affinity mask (colors)
    uint32 affinity_mask = 2;
    // Array of name based constratints currently applied to the tunnel
    repeated affinity_name_bag named_affinities = 3;
}

// Information about the Shared Risk Link Group
message mpls_srlg_info {
    // SRLG number
    uint32 shared_risk_group = 1;
    // SRLG name
    string srlg_name = 2;
}

// XRO IPv4 sub-object
message te_xro_subobj_ipv4 {
    // IPv4 address
    string address = 1;
    // Prefix length
    uint32 prefix_len = 2;
    // Attribute
    string attribute = 3;
    // Exclusion Type
    string exclusion_type = 4;
}

// XRO IPv6 sub-object
message te_xro_subobj_ipv6 {
    // IPv6 address
    string address = 1;
    // Prefix length
    uint32 prefix_len = 2;
    // Attribute
    string attribute = 3;
    // Exclusion Type
    string exclusion_type = 4;
}

// XRO unnumbered sub-object
message te_xro_subobj_unnum {
    // TE router-id
    string te_router_id = 1;
    // Interface ID
    uint32 interface_id = 2;
    // Attribute
    string attribute = 3;
    // Exclusion Type
    string exclusion_type = 4;
}

// XRO AS sub-object
message te_xro_subobj_as {
    // Autonomous System number
    uint32 as_number = 1;
}

// XRO SRLG sub-object
message te_xro_subobj_srlg {
    // SRLG ID
    uint32 srlg_id = 1;
    // Exclusion Type
    string exclusion_type = 2;
}

// XRO point-to-point LSP sub-object
message te_xro_subobj_p2p_lsp {
    // LSP FEC
    te_lsp_fec_t fec = 1;
    // Flag to indicate whether or not the lsp-id in the FEC is to be ignored
    bool ignore_lsp_id = 2;
    // Processing-node exception flag
    bool processing_node_exception = 3;
    // Penultimate-node exception flag
    bool penultimate_node_exception = 4;
    // Destination-node exception flag
    bool destination_node_exception = 5;
    // Exclusion Type
    string exclusion_type = 6;
}

// XRO sub-object union
message te_xro_subobj {
    string type = 1;
    // IPv4 sub-object
    te_xro_subobj_ipv4 ipv4_subobject = 2;
    // IPv6 sub-object
    te_xro_subobj_ipv6 ipv6_subobject = 3;
    // Unnumbered sub-object
    te_xro_subobj_unnum unnumbered_subobject = 4;
    // AS sub-object
    te_xro_subobj_as as_subobject = 5;
    // SRLG sub-object
    te_xro_subobj_srlg srlg_subobject = 6;
    // P2P LSP sub-object
    te_xro_subobj_p2p_lsp lsp_subobject = 7;
}

// XRO object
message te_xro {
    // List of XRO sub-objects
    repeated te_xro_subobj xro_subobjects = 1;
    // Mutual Diversity Flag
    bool mutual_diversity_flag = 2;
}

// Revert Schedule protection attribute set
message te_revert_sch_t {
    // Schedule name identifier
    bytes schedulename = 1;
    // Schedule time for reversion
    uint32 schedule_date = 2;
    // Schedule frequency for reversion
    string schedule_frequency = 3;
    // Duration for scheduled reversion
    uint32 duration = 4;
    // Max tries for scheduled reversion
    uint32 max_tries = 5;
}

// HASI ID Event
message hasi_id_event {
    // LocalID
    uint64 local_id = 1;
    // RemoteID
    uint64 remore_id = 2;
    // Time
    uint32 time = 3;
    // Count
    uint64 count = 4;
}

// HASI Slave Object ID events
message hasi_s_obj_id_events {
    // Create
    hasi_id_event create = 1;
    // Updates
    hasi_id_event updates = 2;
    // ApplicationSyncs
    hasi_id_event application_syncs = 3;
    // ApplicationNaks
    hasi_id_event application_naks = 4;
    // SummaryReplaySyncs
    hasi_id_event summary_replay_syncs = 5;
    // SummaryReplayNaks
    hasi_id_event summary_replay_naks = 6;
    // CacheNakRetries
    hasi_id_event cache_nak_retries = 7;
}

// HASI Slave Object Context
message hasi_s_object_ctx {
    // ObjectSyncID
    uint64 object_sync_id = 1;
    // ObjectType
    uint32 object_type = 2;
    // ObjectIdEvents
    hasi_s_obj_id_events object_id_events = 3;
}

// HASI Master Slave ID Events
message hasi_m_id_events {
    // ApplicationSyncs
    hasi_id_event application_syncs = 1;
    // ImplicitDeletes
    hasi_id_event implicit_deletes = 2;
    // ApplicationNaks
    hasi_id_event application_naks = 3;
    // SummaryReplaySyncs
    hasi_id_event summary_replay_syncs = 4;
    // SummaryReplayNaks
    hasi_id_event summary_replay_naks = 5;
}

// HASI Master Object Client Info
message hasi_m_object_slave_info {
    // SlaveId
    uint32 slave_id = 1;
    // IdEvents
    hasi_m_id_events id_events = 2;
}

// HASI Master Object Context
message hasi_m_object_ctx {
    // ObjectSyncID
    uint64 object_sync_id = 1;
    // ObjectType
    uint32 object_type = 2;
    // Queue
    uint32 queue = 3;
    // CreateID
    uint64 create_id = 4;
    // CreateTime
    uint32 create_time = 5;
    // UpdateTime
    uint32 update_time = 6;
    // DeleteTime
    uint32 delete_time = 7;
    // DeleteContextLength
    uint32 delete_ctx_lenght = 8;
    // SlaveInformation
    repeated hasi_m_object_slave_info slave_information = 9;
    // HasHistory
    bool has_history = 10;
    // PreActiveHistory
    hasi_s_obj_id_events pre_active_history = 11;
}

message te_serv_p2mp_auto_tun {
    // Client Context
    uint32 context = 1;
    // Client
    string client = 2;
    // Tunnel Source Address
    string source = 3;
    // Tunnel Attribute Set Name
    string attribute_set_name = 4;
    // Tunnel Attribute Set Resolved
    bool attribute_set_resloved = 5;
    // Forwarding info to be sent to LMRIB
    repeated uint32 egress_information = 6;
    // EgressInfoState
    uint32 state = 7;
    // EgressInfoResult
    uint32 result = 8;
    // Time at which it was last updated
    uint64 updated = 9;
    // Needs to be replayed
    bool needs_replay = 10;
}

message te_serv_p2p_auto_tun {
    // Client Context
    uint32 context = 1;
    // Protocol Type
    string protocol_tyoe = 2;
    // Client Instance Name
    string client_instance_name = 3;
    // Tunnel Destination Address
    string destination = 4;
    // Explicit Path
    string explicit_path = 5;
    // Tunnel Attribute Set Name
    string attribute_set_name = 6;
    // Tunnel Attribute Set Resolved
    bool attribute_set_resolved = 7;
    // Time at which it was last updated
    uint64 updated = 8;
    // Needs to be replayed
    bool needs_replay = 9;
    // IPv6 Caps Requested
    bool ipv6_caps_requested = 10;
    // IPv6 Caps Enabled
    bool ipv6_caps_enabled = 11;
    // Backup Tunnel
    bool backup_tunnel = 12;
    // Next hop
    string next_hop = 13;
    // Outgoing Interface Name
    string outgoing_interface = 14;
    // Label stack
    repeated uint32 label_stack = 15;
}

// Egress info
message te_serv_p2mp_einfo {
    // Client
    string client = 1;
    // State
    uint32 state = 2;
    // Result
    uint32 result = 3;
    // Forwarding info to be sent to LMRIB
    repeated uint32 egress_information = 4;
    // Time at which it was last updated
    uint64 updated = 5;
    // Needs to be replayed
    bool needs_replay = 6;
}

// FSM events
message mpls_te_p2mp_fsm_event_counts {
    // FSM event counts
    repeated uint32 counts = 1;
}

// FSM statistics
message mpls_te_p2mp_fsm_event_stat {
    // Event time
    uint32 event_time = 1;
    // Previous state
    string previous_state = 2;
    // Next state
    string next_state = 3;
    // Event ID
    string event_id = 4;
}

// FSM data
message mpls_te_p2mp_fsm_info {
    // S2L FSM state
    string s2_l_fsm_state = 1;
    // S2L Flags
    uint32 s2_l_flags = 2;
    // Deletion Cause
    string deletion_cause = 3;
    // Deletion Subcause
    string deletion_subcause = 4;
    // Number of injected events
    uint32 injected_events = 5;
    // Event stats
    repeated mpls_te_p2mp_fsm_event_stat event_statistics = 6;
    // Event counts
    mpls_te_p2mp_fsm_event_counts event_counts = 7;
    // Path is yet to be received
    bool path_to_be_received = 8;
    // Resv is yet to be received
    bool reservation_to_be_received = 9;
    // Label is yet to be received
    bool label_to_be_received = 10;
    // RW yet to be received
    bool rewrite_to_be_received = 11;
    // Sync-ID is yet to be received from RSVP
    bool sync_id_from_rsvp_to_be_received = 12;
    // Sync-ID is yet to be received from MASTER-TE
    bool sync_id_from_master_to_be_received = 13;
    // The outgoing interface for this S2L has gone down
    bool frr_active_pending = 14;
    // The S2L properties that are synced do not match the config
    bool config_consistent = 15;
    // TRUE if there is no vifi for this HEAD S2L
    bool missing_vif = 16;
    // TRUE if the signaled name in the S2L is different than the vif
    bool signame_diff = 17;
    // TRUE if the FRR property in the S2L is different than the vif
    bool frr_diff = 18;
    // TRUE if the FRR Node Protection property in the S2L is different than the vif
    bool frr_np_diff = 19;
    // TRUE if the FRR Bandwidth Protection property in the S2L is different than the vif
    bool frr_bwp_diff = 20;
    // TRUE if the Record Route property in the S2L is different than the vif
    bool record_route_diff = 21;
    // TRUE if the soft preemption property in the S2L is different than the vif
    bool soft_preemption_diff = 22;
}

message te_serv_p2mp_einfos {
    // P2MP Services Info Array
    repeated te_serv_p2mp_einfo service_infos = 1;
}

// Endpoint Services Information
message te_service_info {
    string service_type = 1;
    // VIF Egress-Info
    te_serv_p2mp_einfos vif_egress_info = 2;
    // S2L Egress-Info
    te_serv_p2mp_einfos s2_l_egress_info = 3;
    // VIF Auto-Tunnel Info
    te_serv_p2mp_auto_tun vif_auto_tunnel_info = 4;
    // VIF P2P Auto-Tunnel Info
    te_serv_p2p_auto_tun vif_auto_tunnel_p2_p_info = 5;
}

// ODU flex info for CBR framing type
message te_odu_flex_cbr_info {
    // Bit rate in kbit/s
    uint32 bit_rate = 1;
    // Tolerance
    uint32 tolerance = 2;
}

// ODU flex info for resizable GFP-F framing type
message te_odu_flex_gfp_f_res_info {
    // Bit rate in kbit/s
    uint32 bit_rate = 1;
}

// ODU flex info for non-resizable GFP-F framing type
message te_odu_flex_gfp_f_non_res_info {
    // Bit rate in kbit/s
    uint32 bit_rate = 1;
}

// ODU bandwidth union
message te_odu_v3_bw {
    string odu_level = 1;
    // Odu flex CBR info
    te_odu_flex_cbr_info odu_flex_cbr = 2;
    // Odu flex GFP-F resizable info
    te_odu_flex_gfp_f_res_info odu_flex_gfp_f_res = 3;
    // Odu flex GFP-F non-resizable info
    te_odu_flex_gfp_f_non_res_info odu_flex_gfp_f_non_res = 4;
}

// TE Logging Attributes
message mpls_te_logging_attributes {
    // LSP State logging: TRUE - enabled, FALSE - disabled
    bool lsp_state = 1;
    // S2L State logging: TRUE - enabled, FALSE - disabled
    bool s2_l_state = 2;
    // LSP re-route logging: TRUE - enabled, FALSE - disabled
    bool lsp_re_route = 3;
    // LSP re-optimization logging: TRUE - enabled, FALSE - disabled
    bool lsp_re_opt = 4;
    // LSP insufficient bandwidth logging: TRUE - enabled, FALSE - disabled
    bool lsp_insufficient_bw = 5;
    // LSP bandwidth change logging: TRUE - enabled, FALSE - disabled
    bool lsp_bandwidth_change = 6;
    // LSP pcalc failure logging: TRUE - enabled, FALSE - disabled
    bool lsp_pcalc_failure_logging_enabled = 7;
    // All logging option: TRUE - enabled, FALSE - disabled
    bool all_logging_enabled = 8;
}

// TE Auto-mesh Attribute Set
message mpls_te_attribute_set_auto_mesh {
    // Bandwidth value in kbps
    uint32 configured_bandwidth = 1;
    // DSTE Class
    uint32 dste_class_type = 2;
    // Is bandwidth configured
    bool is_bandwidth_configured = 3;
    // Setup priority
    uint32 setup_priority = 4;
    // Hold priority
    uint32 hold_priority = 5;
    // Is priority configured
    bool is_priority_configured = 6;
    // deprecated
    uint32 policy_class = 7;
    // PBTS policy classes
    repeated uint32 policy_classes = 8;
    // Is policy class configured
    bool is_policyclass_configured = 9;
    // Forward class
    uint32 forward_class = 10;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 11;
    // Is affinity configured
    bool is_affinity_configured = 12;
    // Fast reroute
    bool fast_reroute = 13;
    // FRR Node protection
    bool frr_node_protection = 14;
    // FRR bandwidth protection
    bool frr_bandwidth_protection = 15;
    // Record route
    bool record_route = 16;
    // Auto bandwidth collect only
    bool auto_bandwidth_collect = 17;
    // Announce auto route to IGP
    bool auto_route_announce = 18;
    // Soft preemption is configured
    bool soft_preemption_configured = 19;
    // Logging attributes
    mpls_te_logging_attributes logging = 20;
    // IM bandwidth
    uint32 bandwidth = 21;
    // Load-Share
    uint32 load_share = 22;
    // Is Interface BW configured
    bool is_interface_bw_configured = 23;
    // Meshgroup ID
    repeated uint32 mesh_group_id = 24;
    // Tunnel ID
    repeated uint32 tunnel_id = 25;
}

// TE Protected Interface Name String
message mpls_te_protected_if_name_str {
    // Protected Interface Name
    string protected_interface = 1;
}

// Attribute set signalled name
message mpls_te_attribute_set_sig_name {
    // Signalled name
    string name = 1;
    // Source address or name
    string source_type = 2;
    // Protected interface address or name
    string protected_interface_type = 3;
    // MP address appended
    bool is_mp_addresses = 4;
}

// TE Auto-backup Attribute Set
message mpls_te_attribute_set_auto_backup {
    // Is signalled name configured
    bool is_signalled_name_configured = 1;
    // Signalled name
    mpls_te_attribute_set_sig_name signalled_name = 2;
    // Setup priority
    uint32 setup_priority = 3;
    // Hold priority
    uint32 hold_priority = 4;
    // Is priority configured
    bool is_priority_configured = 5;
    // deprecated
    uint32 policy_class = 6;
    // PBTS policy classes
    repeated uint32 policy_classes = 7;
    // Is policy class configured
    bool is_policyclass_configured = 8;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 9;
    // Is affinity configured
    bool is_affinity_configured = 10;
    // Record route
    bool record_route = 11;
    // Logging attributes
    mpls_te_logging_attributes logging = 12;
    // Array of Protected Interface Names
    repeated mpls_te_protected_if_name_str protected_interfaces = 13;
    // Tunnel ID
    repeated uint32 tunnel_id = 14;
}

// TE attribute set versioning info
message mpls_te_attribute_set_version {
    // Attribute Type
    string attribute_type = 1;
    // Generation
    uint32 generation = 2;
    // Is default
    bool is_default = 3;
}

// TE segment routing path list
message mpls_te_attribute_set_bfd_rev_path {
    // BFD reverse path type
    string path_type = 1;
    // BFD reverse path binding label
    uint32 binding_label = 2;
}

// TE Path Option Attribute Set
message mpls_te_attribute_set_path_option {
    // Bandwidth value in kbps
    uint32 configured_bandwidth = 1;
    // Cost limit on the tunnel path
    uint32 cost_limit = 2;
    // DSTE Class
    uint32 dste_class_type = 3;
    // The bandwidth type
    string bandwidth_type = 4;
    // Is bandwidth configured
    bool is_bandwidth_configured = 5;
    // Is Cost Limit configured
    bool is_cost_limit_configured = 6;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 7;
    // Is affinity configured
    bool is_affinity_configured = 8;
    // Tunnel ID
    repeated uint32 tunnel_id = 9;
    // Generation
    uint32 generation = 10;
    // Version Info
    repeated mpls_te_attribute_set_version version_info = 11;
    // Path invalidation interval on the tunnel path
    uint32 path_invalidation_timeout = 12;
    // Path invalidation action
    uint32 path_invalidation_action = 13;
    // Is path invalidation timeout configured
    bool is_path_invalidation_timeout_configured = 14;
    // Is path invalidation action configured
    bool is_path_invalidation_action_configured = 15;
    // Exclude list name
    string exclude_list_name = 16;
    // Is exclude list name configured
    bool is_exclude_list_name_configured = 17;
    // Is PCE Configured
    bool is_pce_configured = 18;
    // Is PCE Disjoint Path Source Configured
    bool is_pce_disj_source_configured = 19;
    // Is PCE Disjoint Path Type Configured
    bool is_pce_disj_type_configured = 20;
    // Is PCE Disjoint Path Group ID Configured
    bool is_pce_disj_group_id_configured = 21;
    // PCE Disjoint Path Source Address
    uint32 pcedp_source_address = 22;
    // PCE Disjoint Path Type
    string pcedp_type = 23;
    // PCE Disjoint Path Group ID
    uint32 pcedp_group_id = 24;
    // Is PCE Bidirectional Source Configured
    bool is_pceb_dj_source_configured = 25;
    // Is PCE Bidirectional Group ID Configured
    bool is_pcebd_group_id_configured = 26;
    // PCE Bidirectional Source Address
    uint32 pcebd_source_address = 27;
    // PCE Bidirectional Group ID
    uint32 pcebd_group_id = 28;
    // BFD reverse path
    mpls_te_attribute_set_bfd_rev_path bfd_reverse_path = 29;
    // Is BFD reverse path configured
    bool is_bfd_reverse_pat_configured = 30;
}

// TE XRO attribute set
message mpls_te_attribute_set_xro {
    // The XRO specified by this attribute-set
    te_xro xro = 1;
}

// TE P2MP-TE Attribute Set
message mpls_te_attribute_set_p2mp_te {
    // Fast reroute
    bool fast_reroute = 1;
    // FRR bandwidth protection
    bool frr_bandwidth_protection = 2;
    // Setup priority
    uint32 setup_priority = 3;
    // Hold priority
    uint32 hold_priority = 4;
    // Is priority configured
    bool is_priority_configured = 5;
    // Bandwidth value in kbps
    uint32 configured_bandwidth = 6;
    // DSTE Class
    uint32 dste_class_type = 7;
    // Is bandwidth configured
    bool is_bandwidth_configured = 8;
    // Tunnel ID
    repeated uint32 tunnel_id = 9;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 10;
    // Is affinity configured
    bool is_affinity_configured = 11;
}

// TE OTN path protection attribute set
message mpls_te_attribute_set_aps_pp {
    // Sub-network Connection Mode
    string snc_mode = 1;
    // Sub-network Connection Monitoring Mode
    uint32 tcm_id = 2;
    // Protection Type
    string protection_type = 3;
    // Protection Restoration Mode
    string protection_mode = 4;
    // Wait to restore time
    uint32 wait_to_restore_time = 5;
    // Hold-off time
    uint32 hold_off_time = 6;
    // Revert Schedule
    te_revert_sch_t revert_schedule = 7;
    // Path Protection Profile Type
    string path_prot_profile_type = 8;
    // Restoration Style
    string restoration_style = 9;
}

// TE segment routing prepend entry
message mpls_te_attribute_set_sr_prepend_entry {
    // Prepend Type
    string type = 1;
    // Prepend index
    uint32 index = 2;
    // Prepend next label
    uint32 next_label = 3;
}

// TE segment routing prepend list
message mpls_te_attribute_set_sr_prepend_list {
    // List of prepend entries
    repeated mpls_te_attribute_set_sr_prepend_entry prepend_entries = 1;
}

// TE P2P-TE Attribute Set
message mpls_te_attribute_set_p2p_te {
    // Tunnel ID
    repeated uint32 tunnel_id = 1;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 2;
    // Is affinity configured
    bool is_affinity_configured = 3;
    // Path selection segment-routing type
    string path_selection_segment_routing_adjacency_protection = 4;
    // Is path selection segment routing configured
    bool is_path_selection_segment_routing_adjacency_protection_configured = 5;
    // Path invalidation timeout on the tunnel path
    uint32 path_invalidation_timeout = 6;
    // Path invalidation action
    string path_selection_invalidation_action = 7;
    // Is Path Invalidation timeout configured
    bool is_path_invalidation_timeout_configured = 8;
    // Is Path Invalidation action configured
    bool is_path_invalidation_action_configured = 9;
    // Path selection metric type
    string path_selection_metric = 10;
    // Is path selection metric configured
    bool is_path_selection_metric_configured = 11;
    // Path selection margin
    uint32 path_selection_segment_routing_margin = 12;
    // Path selection margin is_relative
    bool is_path_selection_segment_routing_margin_relative = 13;
    // Is path selection margin configured
    bool is_path_selection_segment_routing_margin_configured = 14;
    // Is path selection segment limit configured
    uint32 path_selection_segment_routing_segment_limit = 15;
    // Is path selection segment limit configured
    bool is_path_selection_segment_routing_segment_limit_configured = 16;
    // Is any of the path selection parameters configured
    bool is_path_select_configured = 17;
    // Logging attributes
    mpls_te_logging_attributes logging = 18;
    // SR prepend list
    mpls_te_attribute_set_sr_prepend_list prepend_list = 19;
    // Is SR prepend list configured
    bool is_prepend_list_configured = 20;
    // Is PCE Configured
    bool is_pce_configured = 21;
    // Is PCE Disjoint Path Source Configured
    bool is_pce_disj_source_configured = 22;
    // Is PCE Disjoint Path Type Configured
    bool is_pce_disj_type_configured = 23;
    // Is PCE Disjoint Path Group ID Configured
    bool is_pce_disj_group_id_configured = 24;
    // PCE Disjoint Path Source Address
    uint32 pcedp_source_address = 25;
    // PCE Disjoint Path Type
    string pcedp_type = 26;
    // PCE Disjoint Path Group ID
    uint32 pcedp_group_id = 27;
    // Is PCE Bidirectional Source Configured
    bool is_pceb_dj_source_configured = 28;
    // Is PCE Bidirectional Group ID Configured
    bool is_pcebd_group_id_configured = 29;
    // PCE Bidirectional Source Address
    uint32 pcebd_source_address = 30;
    // PCE Bidirectional Group ID
    uint32 pcebd_group_id = 31;
}

// TE Attribute Set Union
message mpls_te_attribute_set_union {
    string tunnel_attribute_set_type = 1;
    // MPLS TE Path Option Attribute Set
    mpls_te_attribute_set_path_option attribute_set_path_option = 2;
    // MPLS TE Auto-backup Attribute Set
    mpls_te_attribute_set_auto_backup attribute_set_autobackup = 3;
    // MPLS TE Auto-mesh Attribute Set
    mpls_te_attribute_set_auto_mesh attribute_set_automesh = 4;
    // Attribute Set XRO
    mpls_te_attribute_set_xro attribute_set_xro = 5;
    // MPLS TE P2MP-TE Attribute Set
    mpls_te_attribute_set_p2mp_te attribute_set_p2_mpte = 6;
    // Attribute Set OTN APS Path Protection
    mpls_te_attribute_set_aps_pp attribute_set_aps_pp = 7;
    // MPLS TE P2P-TE Attribute Set
    mpls_te_attribute_set_p2p_te attribute_set_p2_p_te = 8;
}

// TE Attribute Set
message mpls_te_attribute_set {
    // Attribute Set Name
    string tunnel_attribute_set_name = 1;
    // Attribute Set name CRC32 value
    uint32 tunnel_attribute_set_name_crc32 = 2;
    // Union of Attribute Sets
    mpls_te_attribute_set_union attribute_set_union = 3;
}

// GMPLS WDM fixed-grid Label
message mpls_te_mgmt_wdm_fixed_grid_label {
    // Flag to indicate whether label is set
    bool label_set = 1;
    // Grid
    string grid = 2;
    // Channel spacing
    string channel_spacing = 3;
    // Identifier
    uint32 identifier = 4;
    // Channel Number
    sint32 channel = 5;
}

// GMPLS G709 OTN fixed-size Label
message mpls_te_mgmt_g709_otn_fixed_size_label {
    // Tributary time slot
    uint32 tpn = 1;
    // Bit map length
    uint32 bit_map_length = 2;
    // Bit Map
    repeated uint32 bit_map = 3;
}

// A GMPLS label
message mpls_te_mgmt_gmpls_label {
    string label_type = 1;
    // Fixed-grid WDM label
    mpls_te_mgmt_wdm_fixed_grid_label wdm = 2;
    // Fixed-size G09 OTN label
    mpls_te_mgmt_g709_otn_fixed_size_label otn = 3;
}

// GMPLS Labels
message mpls_te_mgmt_gmpls_labels {
    // Path message (upstream) ingress label
    mpls_te_mgmt_gmpls_label path_ingress_label = 1;
    // Path message (upstream) egress label
    mpls_te_mgmt_gmpls_label path_egress_label = 2;
    // Resv message (downstream) ingress label
    mpls_te_mgmt_gmpls_label resv_ingress_label = 3;
    // Resv message (downstream) egress label
    mpls_te_mgmt_gmpls_label resv_egress_label = 4;
}

// OTN S2L's Controllers' information
message mpls_te_s2l_otn_info {
    // Incoming Controller
    string incoming_controller = 1;
    // State of Incoming Controller
    string incoming_controller_state = 2;
    // Incoming Sub Controller
    string incoming_sub_controller = 3;
    // State of Incoming Sub Controller
    string incoming_sub_controller_state = 4;
    // Outgoing Controller
    string outgoing_controller = 5;
    // State of Outgoing Controller
    string outgoing_controller_state = 6;
    // Outgoing Sub Controller
    string outgoing_sub_controller = 7;
    // State of Outgoing Sub Controller
    string outgoing_sub_controller_state = 8;
    // OTN Bandwidth for s2l
    te_odu_v3_bw bandwidth = 9;
    // Labels
    mpls_te_mgmt_gmpls_labels labels = 10;
    // Cross connect id
    uint32 cross_connect_id = 11;
    // True if subcontrollers are connected
    bool is_connected = 12;
    // XC Uptime
    uint32 uptime = 13;
    // Outgoing Controller Ifhandle
    string outgoing_controller_ifhandle = 14;
    // Outgoing Sub Controller Ifhandle
    string outgoing_sub_controller_ifhandle = 15;
    // Incoming Controller Ifhandle
    string incoming_controller_ifhandle = 16;
    // Incoming Sub Controller Ifhandle
    string incoming_sub_controller_ifhandle = 17;
    // Gpid Payload
    uint32 gpid = 18;
}

// Private Protection information signaled
message te_pvt_prot_obj_t {
    // Secondary bit
    bool s_bit = 1;
    // Protecting bit
    bool p_bit = 2;
    // Notification bit 
    bool n_bit = 3;
    // Operational bit
    bool o_bit = 4;
    // LSP Protect Type
    string protect_type = 5;
    // Is Wait-to-Restore timeout present
    bool is_wtr_present = 6;
    // Wait-to-Restore timeout
    uint32 wtr_timeout = 7;
    // Is Hold-Off timeout present
    bool is_ho_present = 8;
    // Hold-Off timeout
    uint32 ho_timeout = 9;
    // Is SNC mode present
    bool is_snc_mode_present = 10;
    // SNC mode
    string snc_mode = 11;
    // TCM_ID
    uint32 tcm_id = 12;
    // Path protection profile type
    string path_prot_profile_type = 13;
}

// APS Protection Info of S2L
message mpls_te_s2l_aps_info {
    // Protection Info
    te_pvt_prot_obj_t protection_info = 1;
}

// OTN S2l information
message mpls_te_otn_s2l_info {
    // Info Related to OTN technology in S2L
    mpls_te_s2l_otn_info otn = 1;
    // APS Info for OTN S2L
    mpls_te_s2l_aps_info aps = 2;
}

// TE Segment-Routing S2L path hop
message te_s2l_sr_path_hop {
    // Type of the SID
    string sid_type = 1;
    // Node has IP addresses specified
    bool has_ip_addresses = 2;
    // Local IP address of adjacency or Node ID
    string local_addr = 3;
    // Remote IP address of adjacency
    string remote_addr = 4;
    // Hop has MPLS label specified
    bool has_mpls_label = 5;
    // The MPLS label value
    uint32 mpls_label_value = 6;
    // Hop has EL specified
    bool has_entropy_label = 7;
}

// Path computation error information
message mpls_te_p2mp_pcalc_error {
    // Error message (for display purposes only)
    string error_message = 1;
    // LSP Mode
    string lsp_mode = 2;
    // Time in seconds seconds (since Jan. 1, 1970) when the error message is logged
    uint32 log_time = 3;
}

// P2MP signalling error
message mpls_te_p2mp_sig_error {
    // Source address of the error generating node
    uint32 error_node = 1;
    // Path Error code
    uint32 error = 2;
    // Path Error subcode
    uint32 sub_code = 3;
    string lsp_mode = 4;
    // Time in seconds when the error message is logged
    uint32 log_time = 5;
    // LSP-id for which the error was received
    uint32 signalling_lsp_id = 6;
    // Error message (for display purposes only)
    string error_message = 7;
    // Indicates if error is on the reverse LSP
    bool reverse_lsp = 8;
}

// P2MP path-option
message mpls_te_p2mp_path_option {
    // The path option index is valid
    bool option_index_is_valid = 1;
    // Path option index
    uint32 option_index = 2;
    // Path option name
    string path_option_name = 3;
    // Path option type
    string path_option_type = 4;
    // Explicit Path Name, this is the key to table ExplicitPaths.NameTable
    string explicit_path_name = 5;
    // Explicit Path ID, this is the key to table ExplicitPaths.IdentifierTable
    uint32 explicit_path_id = 6;
    // Holddown Duration (seconds)
    uint32 holddown_duration = 7;
    // PCE server address
    string pce_address = 8;
    // The path-option area constraint
    string path_option_area_id = 9;
    // TRUE if explicit path is strict
    bool is_strict_explicit_path = 10;
    // TRUE if path is helddown
    bool is_helddown = 11;
    // TRUE if the path is locked down
    bool is_lockdown = 12;
    // TRUE if the path is verbatim
    bool is_verbatim = 13;
    // TRUE if the path option is disabled
    bool is_disabled = 14;
    // TRUE if the path has an attribute set defined
    bool has_attribute_set = 15;
    // The path option attribute set used by this path
    mpls_te_attribute_set attribute_set = 16;
    // TRUE if the path has found the defined attribute set
    bool attribute_set_found = 17;
    // Path computation information
    repeated mpls_te_p2mp_pcalc_error path_calculation_error = 18;
    // Path computation remerge resolve info
    repeated mpls_te_p2mp_pcalc_error remerge_error = 19;
    // Signalling information
    repeated mpls_te_p2mp_sig_error signalling_error = 20;
    // TRUE if the path has an XRO attribute set configured
    bool has_xro_attribute_set = 21;
    // TRUE if the path's XRO attribute set is known
    bool xro_attribute_set_found = 22;
    // The XRO attribute set used by this path-option
    mpls_te_attribute_set xro_attribute_set = 23;
    // TRUE if the path is Segment-Routing
    bool is_segment_routing = 24;
    // Path option index for Protect path options
    uint32 protected_by_path_option_index = 25;
    // Path option index for Restore path options
    uint32 restored_from_path_option_index = 26;
}

// TE G709 OTN TSpec
message te_mgmt_g709_otn_tspec {
    // Signal Type
    uint32 signal_type = 1;
    // NMC or Tolerance
    uint32 nmc_or_tolerance = 2;
    // Number of Virtual Components
    uint32 nvc = 3;
    // Multiplier
    uint32 multiplier = 4;
    // Bit Rate in kbps
    uint32 bit_rate = 5;
}

// Union of different TE generic TSpec types
message te_mgmt_generic_tspec {
    string t_spec_type = 1;
    // TE TSpec for G709 OTN
    te_mgmt_g709_otn_tspec otnt_spec = 2;
}

// TE G709 OTN FSpec
message te_mgmt_g709_otn_fspec {
    // Signal Type
    uint32 signal_type = 1;
    // NMC or Tolerance
    uint32 nmc_or_tolerance = 2;
    // Number of Virtual Components
    uint32 nvc = 3;
    // Multiplier
    uint32 multiplier = 4;
    // Bit Rate in kbps
    uint32 bit_rate = 5;
}

// Union of different TE generic FSpec types
message te_mgmt_generic_fspec {
    string f_spec_type = 1;
    // TE FSpec for G709 OTN
    te_mgmt_g709_otn_fspec otnf_spec = 2;
}

// Bandwidth information of a flow
message bandwidth_spec_bag {
    // Average bandwidth in  kbps
    uint64 average_rate = 1;
    // Maximum burst of data in bytes
    uint64 maximum_burst = 2;
    // Peak rate in  kbps
    uint64 peak_rate = 3;
}

// TE LSP convergence related information
message te_lsp_convergence_info {
    // LSP RSVP Path-in timestamp (clocktime in nsecs)
    uint64 path_in = 1;
    // LSP RSVP Path-in timestamp (clocktime in nsecs)
    uint64 path_out = 2;
    // LSP RSVP Resv-in timestamp (clocktime in nsecs)
    uint64 resv_in = 3;
    // LSP RSVP Resv-out timestamp (clocktime in nsecs)
    uint64 resv_out = 4;
    // LSP Label rewrite timestamp (clocktime in nsecs)
    uint64 label_rewrite = 5;
    // Tunnel rewrite timestamp (clocktime in nsecs)
    uint64 tunnel_rewrite = 6;
}

// Midpoint Soft Preemption LSP Info
message mpls_te_soft_preemption_lsp_info {
    // The current state of the soft preemption operation
    string status = 1;
    // The POSIX timestamp when the soft preemption occurred
    uint32 soft_preemption_timestamp = 2;
    // Name of the link where the soft preemption occurred
    string soft_preemption_link = 3;
    // The address of the link where the preemption happened
    string preempting_link_address = 4;
    // The number of seconds until hard preemption is triggered
    uint32 time_to_hard_preemption = 5;
    // FRR-rewrite during soft preemption
    bool fr_rrewrite = 6;
    // The tunnel name of the backup
    string fr_rrewrite_tunnel_name = 7;
}

// Hop information
message tunnel_hop_info {
    // Hop address
    string hop_address = 1;
    // Deprecated
    uint32 hop_affinity = 2;
    // Hop affinity
    repeated uint32 hop_extended_affinity = 3;
}

// TE BFD Session Info
message mpls_te_bfd_session_info {
    // BFD session state
    string state = 1;
    // Time in seconds since the last session state change
    uint32 state_change_time = 2;
}

// TE Tunnel BFD Session Deletion History
message mpls_te_bfd_deletion_history {
    // LSP ID of the BFD session get deleted
    uint32 lsp_id = 1;
    // Time stamp of the BFD session get deleted
    uint32 deletion_time = 2;
    // Reason for the BFD session get deleted
    string deletion_reason = 3;
    // Diagnostic Code for the BFD session get deleted
    uint32 deletion_diagnostic_code = 4;
}

// TE Head-end BFD information
message mpls_te_head_bfd_info {
    // Time in seconds since the BFD session created
    uint32 creation_time = 1;
    // BFD Session Info
    mpls_te_bfd_session_info session_info = 2;
    // BFD Session Deletion History
    mpls_te_bfd_deletion_history deletion_history = 3;
    // LSP BFD type
    string lspbfd_type = 4;
    // sBFD session is redundant
    bool is_redundant = 5;
    // BFD reverse path labels
    repeated uint32 bfd_reverse_path_labels = 6;
    // The BFD reverse path is stale compared to configuration
    bool bfd_reverse_path_stale = 7;
}

// TE Tail-end BFD information
message mpls_te_tail_bfd_info {
    // BFD Session Info
    mpls_te_bfd_session_info session_info = 1;
    // BFD session failure diagnostic code
    uint32 failure_diagnostic_code = 2;
    // BFD session failure reason
    string failure_reason = 3;
    // BFD Local Discriminator
    uint32 local_discriminator = 4;
    // BFD Remote Discrminator
    uint32 remote_discriminator = 5;
    // Hello interval in mini second
    uint32 min_interval = 6;
    // Is default hello interval
    bool min_interval_default = 7;
    // Multiplier
    uint32 multiplier = 8;
    // Is default multiplier
    bool multiplier_default = 9;
}

// TE Association Object
message mpls_te_s2l_association_object {
    // S2L Association Type (draft-ietf-ccamp-mpls-tp-rsvpte-ext-associated-lsp)
    uint32 s2_l_association_type = 1;
    // S2L Association Tie Role
    string s2_l_association_tie_role = 2;
    // S2L Association ID
    uint32 s2_l_association_id = 3;
    // S2L Association Source
    string s2_l_association_source = 4;
    // S2L Global Source
    uint32 s2_l_global_source = 5;
    // S2L Extended ID Array
    repeated uint32 s2_l_extended_id = 6;
}

// TE Protection Object
message mpls_te_s2l_protection_object {
    //  S2L Protection Secondary Bit
    bool s2_l_secondary = 1;
    //  S2L Protection Protecting Bit
    bool s2_l_protecting = 2;
    //  S2L Protection Notification Bit
    bool s2_l_notification = 3;
    //  S2L Protection Operational Bit
    bool s2_l_operational = 4;
    // Indicates Enhanced Protection Scheme
    bool enhanced = 5;
    // Dedicated 1+1 Protection
    bool ded1_plus1 = 6;
    // Dedicated 1:1 Protection
    bool ded1_to1 = 7;
    // Shared Link Layer Protection
    bool shared = 8;
    // LSP should not use any Link Layer Protection
    bool link_unprotected = 9;
    // LSP should use Links that are protecting other (primary) traffic
    bool extra_traffic = 10;
    // Any
    bool any = 11;
    // Full Rerouting
    bool rerouting = 12;
    // Rerouting Without Extra-Traffic
    bool rerouting_no_et = 13;
    // 1:N Protection with Extra-Traffic
    bool one_to_n_protection_et = 14;
    // 1+1 Unidirectional Protection
    bool one_plus_one_uni = 15;
    // 1+1 Bidirectional Protection
    bool one_plus_one_bi = 16;
    // LSP Flags Unprotected
    bool lsp_unprotected = 17;
}

// Information about flex LSP lockout info for the link
message flex_lockout_t {
    // True if s2l is locked out
    bool is_lockout = 1;
    // Flex LSP Lockout Origination Source
    string origination = 2;
    // The timestamp when the lockout is set
    uint32 lockout_timestamp = 3;
}

// TE Per-S2L FlexLSP Information
message mpls_te_s2l_flex_info {
    // FlexLSP Entry Exists
    bool entry_exists = 1;
    // In Label
    uint32 in_label = 2;
    // GAL BFD Session Created
    bool bfd_created = 3;
    // GAL BFD Session Up
    bool bfd_up = 4;
    // OAM Entry Created
    bool oam_created = 5;
    // FEC for the FlexLSP Entry
    te_s2l_fec_t flex_fec = 6;
    // BFD Next Hop
    string bfd_next_hop = 7;
    // BFD Tunnel Interface Handle
    string bfd_tun_ifh = 8;
    // BFD Out Interface Handle
    string bfd_out_ifh = 9;
    // BFD Internal Label
    uint32 bfd_int_label = 10;
    // BFD Egress Label
    uint32 bfd_egress_label = 11;
    // Fault LDI Lockout
    bool fault_ldi_lockout = 12;
    // Fault LDI
    bool fault_ldi = 13;
    // Fault LKR
    bool fault_lkr = 14;
    // Fault AIS
    bool fault_ais = 15;
    // Fault Time
    uint32 fault_time = 16;
    // Flex LSP Lockout Info
    flex_lockout_t lockout = 17;
}

// SRLG-collection information
message te_s2l_srlg_collect_info {
    // SRLG-collection mechanism
    string srlg_collect_type = 1;
    // Discovered SRLGs
    repeated uint32 discovered_srl_gs = 2;
}

// Midpoint LSP Wrap Protection LSP Info
message tunnel_midpoint_lsp_wrap_info_bag {
    // LSP Wrap protection enabled
    bool lsp_wrap_protection_enable = 1;
    // LSP Wrap Merge Point Label
    uint32 lsp_wrap_protection_label = 2;
    // Reverse Egress Interface
    string reverse_egress_interface = 3;
    // Reverse LSP label
    uint32 reverse_lsp_label = 4;
    // LSP wrap protection state
    string lsp_wrap_protection_state = 5;
}

// S2l Diversity info
message mpls_te_s2l_diversity_info {
    // S2L path diversity type
    string diversity_type = 1;
}

// A P2MP S2L
message mpls_te_p2mp_s2l {
    // FEC for the S2L
    te_s2l_fec_t s2_l_fec = 1;
    // The path option used to find the path for this S2L
    mpls_te_p2mp_path_option active_path_option = 2;
    // The S2L's excluded srlg groups
    repeated mpls_srlg_info shared_risk_link_groups = 3;
    // IGP-area in which the S2L path was calculated
    string pcalc_area = 4;
    // TRUE if this LSR expanded a loose path
    bool is_expanded_ero = 5;
    // Loose path reevaluation query received at mid-point
    uint32 path_reeval_query_mid = 6;
    // Time since last reevaluation query received at mid-point
    uint32 time_since_last_query_received_mid = 7;
    // Time since last preferred path exists msg send from mid-point
    uint32 time_since_last_preferred_path_exists_send_mid = 8;
    // Time since last preferred tree exists msg send from mid-point
    uint32 time_since_last_preferred_tree_exists_send_mid = 9;
    // Indicates the protocol and area used to find Outgoing ERO
    string expanded_ero_area_id = 10;
    // The Outgoing ERO's affinity bits (colors)
    uint32 expanded_ero_affinity_bits = 11;
    // The Outgoing ERO's affinity mask (colors)
    uint32 expanded_ero_affinity_mask = 12;
    // The Outgoing ERO's selection metric
    string expanded_ero_metric_type = 13;
    // The metric value of the expanded path
    uint32 expanded_ero_metric = 14;
    // Next ABR auto discovered
    string abr_auto_discovered = 15;
    // FRR Enabled or Disabled
    bool is_frr_enabled = 16;
    // Node Protection Enabled or Disabled
    bool is_node_protected = 17;
    // BW Protection Enabled or Disabled
    bool is_bandwidth_protect = 18;
    // Path RRO Enabled or Disabled
    bool path_rro_enabled = 19;
    // Outgoing ERO for this S2L
    repeated rsvp_mgmt_ero_subobj out_ero = 20;
    // Incoming ERO for this S2L
    repeated rsvp_mgmt_ero_subobj in_ero = 21;
    // Outgoing XRO for this S2L
    te_xro out_xro = 22;
    // Incoming XRO for this S2L
    te_xro in_xro = 23;
    // Path RRO for this S2L
    repeated rsvp_mgmt_rro_subobj path_rro = 24;
    // Resv RRO for this S2L
    repeated rsvp_mgmt_rro_subobj resv_rro = 25;
    // Tunnel's Path hops with affinity
    repeated tunnel_hop_info path_affinity_array = 26;
    // The T spec info
    bandwidth_spec_bag t_spec = 27;
    // Generic TSpec
    te_mgmt_generic_tspec generic_t_spec = 28;
    // The F spec info
    bandwidth_spec_bag f_spec = 29;
    // Generic FSpec
    te_mgmt_generic_fspec generic_f_spec = 30;
    // The path's weight
    uint64 weight = 31;
    // The reverse path weight
    uint64 reverse_weight = 32;
    // Time in seconds since the tunnel was up
    uint32 uptime = 33;
    // Egress Interface
    string egress_interface = 34;
    // State of Outgoing Interface
    string egress_interface_state = 35;
    // Egress Interface in brief format
    string egress_interface_brief = 36;
    // Ingress Interface
    string ingress_interface = 37;
    // State of Incoming Interface
    string ingress_interface_state = 38;
    // Ingress Interface in brief format
    string ingress_interface_brief = 39;
    // Local label
    uint32 s2_l_local_label = 40;
    // Outgoing label
    uint32 s2_l_out_label = 41;
    // Indicates outbound FRR state
    string outbound_frr_state = 42;
    // FRR out tunnel intface
    string frr_out_tunnel_interface = 43;
    // Role of S2L
    string role = 44;
    // Signaling status
    string signalling_status = 45;
    // Local router id
    string local_router_id = 46;
    // Upstream router id
    string upstream_router_id = 47;
    // Downstream router id
    string downstream_router_id = 48;
    // Next hop address
    string next_hop_address = 49;
    // Next hop address
    te_addr_t_ next_hop_address_generic = 50;
    // Previous hop address
    string previous_hop_address = 51;
    // Previous hop address
    te_addr_t_ previous_hop_address_generic = 52;
    // Incoming interface address
    string incoming_address = 53;
    // Incoming interface address
    te_addr_t_ incoming_address_generic = 54;
    // Interface handle of the backup tunnel
    string backup_tunnel_interface = 55;
    // Hop count
    uint32 node_hop_count = 56;
    // TE LSP convergence related information
    te_lsp_convergence_info s2_l_convergence = 57;
    // The soft preemption info for this LSP.
    mpls_te_soft_preemption_lsp_info soft_preemption = 58;
    // Is Optical
    bool is_optical = 59;
    // GMPLS labels
    mpls_te_mgmt_gmpls_labels gmpls_labels = 60;
    // Otn S2L Information
    mpls_te_otn_s2l_info otn_s2_l = 61;
    // The Head-end BFD info
    mpls_te_head_bfd_info head_end_bfd_info = 62;
    // The Tail-end BFD info
    mpls_te_tail_bfd_info tail_end_bfd_info = 63;
    // SRLG-collection data
    te_s2l_srlg_collect_info srlg_collection = 64;
    // Association Object
    mpls_te_s2l_association_object association = 65;
    // Protection Object
    mpls_te_s2l_protection_object protection = 66;
    //  S2l Reverse ERO Object Present
    bool s2_l_reverse_ero_obj_present = 67;
    //  Reverse Incoming ERO for this S2L
    repeated rsvp_mgmt_ero_subobj reverse_ero_in = 68;
    // Reverse Associated Bidir LSP Present
    bool reverse_lsp_present = 69;
    // Reverse Associated Bidir LSP Connected
    bool reverse_lsp_connected = 70;
    // Reverse Associated Bidir LSP FEC
    te_lsp_fec_t reverse_lsp_fec = 71;
    // Reverse Associated Bidir LSP Name
    string reverse_lsp_name = 72;
    //  S2L Reverse TSpec Object Present
    bool s2_l_reverse_t_spec_obj_present = 73;
    // The Reverse T spec info
    bandwidth_spec_bag reverse_t_spec = 74;
    // Reverse LSP Sub Objects
    repeated uint32 s2_l_reverse_lsp_sub_objs = 75;
    // FlexLSP S2L Information
    mpls_te_s2l_flex_info flex_info = 76;
    // Segment-Routing S2L path info
    repeated te_s2l_sr_path_hop s2_l_segment_routing_path = 77;
    // Lsp Wrap  Related information
    tunnel_midpoint_lsp_wrap_info_bag lsp_wrap_info = 78;
    // Path is using Strict SPF
    bool path_using_strict_spf = 79;
    // S2L Diversity Information
    mpls_te_s2l_diversity_info diversity_info = 80;
}

