// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_fib_common_oper.fib.nodes.node.protocols.protocol.misc;

// FIB miscellaneous info
message fib_sh_misc_KEYS {
    string node_name = 1;
    string protocol_name = 2;
}

message fib_sh_misc {
    // Per protocol debug stats
    repeated fib_sh_proto_debug_stats mi_proto_dbg_stats = 50;
    // number of pfi ifh create notif
    uint64 mi_pfi_ifh_upd = 51;
    // number of pfi ifh delete notif
    uint64 mi_pfi_ifh_del = 52;
    // number of stale ifh removed
    uint64 mi_pfi_ifh_stale = 53;
    // total platform update time
    uint64 mi_tot_plat_upd_time = 54;
    // total time spent in gtrie operations
    uint64 mi_tot_gtrie_time = 55;
    // total download time
    uint64 mi_tot_dnld_time = 56;
    // clock download time
    uint64 mi_clock_time = 57;
    // CPU download time
    uint64 mi_cpu_time = 58;
    // Last FIB shared memory reset time stamp
    uint64 mi_shm_reset_ts = 59;
    // Number of idbs that hit ifh recycle
    uint32 mi_idb_recycle_count = 60;
    // Number of idb cleaned up after hitting ifh recycle
    uint32 mi_idb_recycle_cleanup_count = 61;
    // Number of recycled idb extensions that failed cleanup
    repeated uint32 mi_idb_ext_cleanup_failed_count = 62;
    // Number of management interfaces
    uint32 mi_num_mgmt_list = 63;
    // the number of counters used for purge counter stats
    repeated fib_sh_proto_purge_stats mi_idb_purge_cntrs = 64;
    // Timestamps of deleted routes
    repeated fib_sh_route_del_ts mi_del_ts = 65;
    // Per protocol Failure stats for label RPF
    repeated uint32 mi_lrpf_stats_fail = 66;
    // Per protocol actions stats for label RPF
    repeated uint32 mi_lrpf_stats_act = 67;
    // Per protocol number of label RPFs
    repeated uint32 mi_lrpf_num = 68;
    // Number of interfaces having label security enabled
    repeated uint32 mi_idb_lsec_enabled_num = 69;
    uint32 mi_num_virtual_ll_addresses_added = 70;
    uint32 mi_num_virtual_ll_addresses_deleted = 71;
    uint32 mi_num_virtual_ll_addresses_dropped = 72;
    uint32 mi_num_virtual_ll_addresses_cached = 73;
    // FIB ISSU state
    fib_issu_state mi_issu_state = 74;
    // FRR statistics
    repeated fib_sh_proto_frr_stats mi_frr_stats = 75;
    // FIB platform capabilities
    fib_sh_plat_capabilities mi_plat_capabilities = 76;
    // number of LISP EID prefixes
    repeated uint32 mi_num_lisp_eids = 77;
    // number of LISP EID prefixes eligible for forwarding
    repeated uint32 mi_num_lisp_valid_eids = 78;
    // cpuless node list init
    bool mi_cpuless_init = 79;
    // count of cpuless line cards
    uint32 mi_cpuless_count = 80;
    // list of cpuless line cards
    repeated uint32 mi_cpuless_nodes = 81;
    // Prefer AIB routes over RIB/LSD operational state
    bool mi_prefer_aib_routes_over_rib_oper = 82;
    // Prefer AIB routes over RIB/LSD configured state
    bool mi_prefer_aib_routes_over_rib_cfg = 83;
}

// FIB Max time statistics for each action types of an object
message fib_sh_obj_action_stats {
    // Total number of updates
    uint64 foas_tot_updates = 1;
    // Total time for updates
    uint64 foas_tot_upd_time = 2;
    // Total number of updates that took zero time
    uint64 foas_tot_updates_zero = 3;
    // Total number of successful updates
    uint64 foas_num_success = 4;
    // Total number of failed updates
    uint64 foas_num_failure = 5;
    // Time for the update
    uint64 foas_max_time = 6;
    // Time stamp of max update
    uint64 foas_max_tstamp = 7;
}

// FIB Max time statistics for each FIB object
message fib_sh_obj_stats {
    // Total number of updates
    uint64 fos_tot_updates = 1;
    // Total time for updates
    uint64 fos_tot_upd_time = 2;
    // Array of max time info indexed by action type
    repeated fib_sh_obj_action_stats fos_obj_act_stats = 3;
}

// FIB platform update statistics
message fib_sh_platf_upd_stats {
    // Number of successful updates
    uint64 fpus_num_success = 1;
    // Number of unsuccessful updates
    uint64 fpus_num_failure = 2;
    // Array of max time info indexed by object type
    repeated fib_sh_obj_stats fpus_obj_stats = 3;
    // Total time for all pd updates
    uint64 fpus_upd_total_time = 4;
}

// FIB timing statistics for individual gtrie functions
message fib_sh_gtrie_fn_timing {
    // Gtrie operation
    bytes fgft_fn = 1;
    // Total number of updates
    uint64 fgft_tot_updates = 2;
    // Total number of updates with zero timing (due to timestamp granularity)
    uint64 fgft_tot_updates_zero = 3;
    // Total time for updates
    uint64 fgft_tot_upd_time = 4;
    // Time for the update
    uint64 fgft_max_time = 5;
    // Time stamp of max update
    uint64 fgft_max_tstamp = 6;
}

// FIB platform update statistics
message fib_sh_gtrie_timing {
    // Number of successful updates
    uint64 fgt_num_success = 1;
    // Number of unsuccessful updates
    uint64 fgt_num_failure = 2;
    // Array of max time info indexed by gtrie function
    repeated fib_sh_gtrie_fn_timing fgt_gtrie_fn_timing = 3;
    // Total time for all pd updates
    uint64 fgt_upd_total_time = 4;
}

// FIB per protocol debug information
message fib_sh_proto_debug_stats {
    // the number of fib entries in global tbl
    uint64 fpd_gbltbl_entries = 1;
    // the number of fib entries in global retry tbl
    uint64 fpd_gbltbl_rej_entries = 2;
    // the number of fib entries in vrf tbls
    uint64 fpd_vrftbl_entries = 3;
    // the number of fib entries in vrf retry tbls
    uint64 fpd_vrftbl_rej_entries = 4;
    // the number of tables in table set
    uint32 fpd_num_tbls = 5;
    // Number of global routes from each route source
    repeated uint64 fpd_gbltbl_src_entries = 6;
    // Number of vrf routes from each route source
    repeated uint64 fpd_vrftbl_src_entries = 7;
    // the number of bcdl msgs
    uint64 fpd_bcdl_msgs = 8;
    // the number of route updates
    uint64 fpd_route_upd = 9;
    // the number of route deletes
    uint64 fpd_route_del = 10;
    // the number of routes received
    uint64 fpd_route_rcv = 11;
    // the number of routes dropped
    uint64 fpd_route_drops = 12;
    // the number of routes handled with recycled label
    uint64 fpd_lbl_recycled = 13;
    // the number of routes dropped because of version mismatch
    uint64 fpd_version_mismatch_drops = 14;
    // the number of adjacency updates
    uint64 fpd_adj_upd = 15;
    // the number of adjacency deletes
    uint64 fpd_adj_del = 16;
    // number of TX adjacency updates from AIB
    uint64 fpd_adj_upd_tx = 17;
    // number of TX adjacency updates that found or created NH
    uint64 fpd_adj_upd_tx_nh_found = 18;
    // number of TX adjacency updates that went to retry
    uint64 fpd_adj_upd_tx_retry_created = 19;
    // number of TX adj retries that found or created NH
    uint64 fpd_adj_tx_retry_nh_found = 20;
    // number of times TX NH retry objects updated
    uint64 fpd_adj_tx_retry_obj_reinit = 21;
    //  number of adj updates dropped because of OOR
    uint64 fpd_adj_drops = 22;
    // number of AIB messages
    uint64 fpd_adj_msg = 23;
    // the number of TE upds received
    uint64 fpd_te_rcv = 24;
    // the number of TE upds dropped because of version mismatch
    uint64 fpd_te_version_mismatch_drops = 25;
    // platform update statistics
    fib_sh_platf_upd_stats fpd_platf_upd_stats = 26;
    // Gtrie timing statistics
    fib_sh_gtrie_timing fpd_gtrie_timing = 27;
    // the number of retry timeouts
    uint64 fpd_num_retry_touts = 28;
    // the number of fixup LDIs
    uint64 fpd_ldi_num_fixedup = 29;
    // the number of corrected fixup LDIs
    uint64 fpd_ldi_num_correct_fixup = 30;
    // the number of PL queued for fixup
    uint64 fpd_pl_num_queued_fixedup = 31;
    // the number of corrected fixup PLs
    uint64 fpd_pl_num_correct_fixup = 32;
    // the number PLs added to retry while already in retry
    uint64 fpd_pl_retry_add_exist = 33;
    // the number of PLs linked to resolving tables for inline res
    uint64 fpd_pl_inline_res_q = 34;
    // number of pl creates with backu path
    uint64 fpd_pl_with_backup_create_count = 35;
    // number of pl deletes with backup path
    uint64 fpd_pl_with_backup_del_count = 36;
    // number of PLs marked to include backup path
    uint64 fpd_pl_backup_enable_count = 37;
    //  number of PLs unmarked to include backup path
    uint64 fpd_pl_backup_disable_count = 38;
    // number of PLs visited on fast notification
    uint64 fpd_pl_fast_nfn_count = 39;
    // number of ldi backup path activications
    uint64 fpd_ldi_backup_activate_count = 40;
    // ldi mod time for last backup activation
    uint64 fpd_ldi_last_backup_activate_time = 41;
    // max ldi mod time for backup activation
    uint64 fpd_ldi_max_backup_activate_time = 42;
    // min ldi mod time for backup activation
    uint64 fpd_ldi_min_backup_activate_time = 43;
    // total ldi mod time for backup activation
    uint64 fpd_ldi_total_backup_activate_time = 44;
    // avg ldi mod time for backup activation
    uint64 fpd_ldi_avg_backup_activate_time = 45;
    // number of resolution failures because of recursion constraint
    uint64 fpd_recursion_constraint_count = 46;
    // the number of deleted with non-zero refcount
    uint64 fpd_ldi_num_del_refcnt = 47;
    // the number of retries of each type
    repeated uint64 fpd_num_retries = 48;
    // the number of elements in retryq
    uint32 fpd_retryq_size = 49;
    // the number of allocs for this proto
    uint64 fpd_num_allocs = 50;
    // the number of frees for this proto
    uint64 fpd_num_frees = 51;
}

// FIB per protocol purge counters
message fib_sh_proto_purge_stats {
    // the number of frees for this proto
    repeated uint32 fpp_cntrs = 1;
}

message fib_sh_route_del_ts {
    uint32 tableid = 1;
    bytes prfx = 2;
    uint32 prfx_len = 3;
    uint32 prfx_proto = 4;
    uint64 msec_time = 5;
}

// FIB ISSU protocol state
message fib_issu_proto_state {
    // Protocol name
    string protocol_name = 1;
    string aib_eod_time_stamp = 2;
    // RSI EOD expected/valid
    bool rsi_eod_valid = 3;
    // RSI EOD received timestamp
    string rsi_eod_time_stamp = 4;
    // LSD EOD expected/valid
    bool lsd_eod_valid = 5;
    // LSD EOD received timestamp
    string lsd_eod_time_stamp = 6;
    // LMRIB EOD expected/valid
    bool lmrib_eod_valid = 7;
    // LMRIB EOD received timestamp
    string lmrib_eod_time_stamp = 8;
    // RIB table info valid
    bool rib_info_valid = 9;
    // Number of BCDL tables
    uint32 bcdl_tables = 10;
    // Number of tables converged
    uint32 converged_tables = 11;
    // All RIB tables converged timestamp
    string rib_tables_converged_time_stamp = 12;
    // Protocol EOD expected/valid
    bool protocol_eod_valid = 13;
    // Protocol EOD sent timestamp
    string protocol_eod_time_stamp = 14;
}

// FIB ISSU state
message fib_issu_state {
    // IMDR supported
    bool imdr_support = 1;
    // SLC supported
    bool slc_support = 2;
    // ISSU restart
    bool fis_issu_restart = 3;
    // IMDR End-of-config implicit
    bool imdr_eoc_implicit = 4;
    // SLC End-of-config implicit
    bool slc_eoc_implicit = 5;
    // End-of-config received from IMDR timestamp
    string eoc_received_imdr_time_stamp = 6;
    // End-of-config received from SLC timestamp
    string eoc_received_slc_time_stamp = 7;
    // End-of-download received from IM timestamp
    string eod_received_im_time_stamp = 8;
    // End-of-download send to IMDR timestamp
    string eod_sent_imdr_time_stamp = 9;
    // End-of-download send to SLC timestamp
    string eod_sent_slc_time_stamp = 10;
    // ISSU error sent to ISSUMGR timetstamp
    uint64 fis_issu_error_ts = 11;
    // IMDR state for the protocols
    repeated fib_issu_proto_state fis_proto_state = 12;
}

// FIB per protocol frr counters
message fib_sh_proto_frr_stats {
    // number of FRR events sent on nh interface down
    uint32 mi_num_intf_frr = 1;
    // number of FRR events sent on nh parent interface down
    uint32 mi_num_parent_intf_frr = 2;
    // number of interface down FRR events from PFI
    uint32 mi_num_pfi_intf_down = 3;
    // number of NH down FRR events frm BFD
    uint32 mi_num_bfd_down = 4;
    // total number of prot FRR objects
    uint32 mi_num_prot_frr_objects = 5;
    // total number of backup FRR objects
    uint32 mi_num_bkup_frr_objects = 6;
    // total number of successful FRR tunnel ID allocations
    uint32 mi_num_tunid_allocs = 7;
    // total number of FRR tunnel ID allocation failures
    uint32 mi_num_tunid_alloc_failures = 8;
    // total number of successful FRR tunnel ID frees
    uint32 mi_num_tunid_frees = 9;
    // total number of FRR tunnel ID free failures
    uint32 mi_num_tunid_free_failures = 10;
    // number of frr reset queue adds
    uint32 mi_num_frr_reset_queue_adds = 11;
    // number of frr reset queue deletes
    uint32 mi_num_frr_reset_queue_remove = 12;
    // number of frr resets
    uint32 mi_num_frr_reset = 13;
    // number of frr events received in proto thread
    uint32 mi_num_frr_proto_events = 14;
    // frr log size
    uint32 mi_num_frr_logs = 15;
}

// FIB platform capabilities
message fib_sh_plat_capabilities {
    // L3 LBL levels
    uint32 fpc_num_l3_lbl_levels = 1;
    // L3 Hash buckets
    uint32 fpc_num_l3_lbl_paths = 2;
    // L3 Recursive Hash buckets
    uint32 fpc_num_l3_lbl_rec_paths = 3;
    // L3 Unequal cost hash buckets
    uint32 fpc_num_l3_ucmp_paths = 4;
    // Forwarding stages
    uint32 fpc_num_fwding_stages = 5;
    // Label split
    uint32 fpc_local_label_split = 6;
    // Statistics support
    bool fpc_stats_support = 7;
    // Plat ready cb register
    bool fpc_platf_ready_cb_wait = 8;
    // Path per tunnel class
    uint32 fpc_num_paths_per_pbts_class = 9;
    // V4 update disable
    bool fpc_platf_v4_upd_disable = 10;
    // V6 update disable
    bool fpc_platf_v6_upd_disable = 11;
    // LBA tuples
    uint32 fpc_lba_tuples_default = 12;
    // MRAPS support
    bool fpc_mraps_support = 13;
    // PBTS default class support
    bool fpc_pbts_defclass_support = 14;
    // loadinfo filter support
    bool fpc_loadinfo_filter_support = 15;
    // LISP Decap over 4
    repeated bool fpc_lisp_decap_over_v4 = 16;
    // LISP Decap over 6
    repeated bool fpc_lisp_decap_over_v6 = 17;
    // LISP UCMP support
    repeated bool fpc_lisp_ucmp = 18;
    // Fallback VRF support
    repeated bool fpc_resolve_via_table = 19;
    // NHID support
    bool fpc_nhid = 20;
    // Backwalk dependents is required
    bool fpc_platf_temp_back_walk_reqd = 21;
    // Link MPLS IPv6 NH support
    bool fpc_link_mpls_nhinfo_in_ipv6_thread_support = 22;
    // Exclude Deag backup Paths
    bool fpc_exclude_deag_bkup = 23;
    // Per-destination load-balancing support
    bool fpc_dlb_support = 24;
    // Prefix filter level of support
    uint32 fpc_prefix_filter_support = 25;
    // Slowpath ingress inject required
    bool fpc_slowpath_ingress_inject_reqd = 26;
}

