// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_l2vpn_oper.l2vpn_forwarding.nodes.node.l2fibx_cons.l2fibx_con;

message l2fib_xcon_info_KEYS {
    string node_id = 1;
    uint32 xcid = 2;
}

message l2fib_xcon_info {
    // Base Information
    l2fib_base_info base = 50;
    // Bound
    bool bound = 51;
    // SW Type
    string switching_type = 52;
    // Segment1 Information
    l2fib_seg1_un segment1 = 53;
    // Segment2 Information
    l2fib_seg2_un segment2 = 54;
}

message l2fib_base_info {
}

// L2FIB event item
message l2fib_evt_entry {
    // The real timestamp of the event
    bytes event_time = 1;
    // Event type
    uint32 event_type = 2;
    // Multiple event instance flag
    bool event_many = 3;
    // Unwrittable flag
    bool event_sticky = 4;
    // base flag object
    uint32 event_flags = 5;
}

// L2FIB event history
message l2fib_evt_history {
    // number of item in the array
    uint32 event_neighbor_entry = 1;
    repeated l2fib_evt_entry event_entry = 2;
}

// L2VPN feature profile information
message l2fib_profile_info {
    // Feature profile name
    string profile_name = 1;
}

message l2fib_feature_un {
    string feature_type = 1;
    l2fib_profile_info dhcp = 2;
    l2fib_profile_info igmp = 3;
    l2fib_profile_info mld = 4;
}

// L2VPN common operational information
message l2fib_oper_info {
    // MTU
    uint32 mtu = 1;
    // MAC aging time in minutes
    uint32 mac_aging_time = 2;
    // MAC limit
    uint32 mac_limit = 3;
    uint32 number_of_macs = 4;
    // Is administratively disabled
    bool admin_disabled = 5;
    // Is flooding disabled
    bool flooding_disabled = 6;
    // Is flooding unknown unicast disabled
    bool flood_unknown_unicast_enabled = 7;
    // MAC limit action
    string mac_limit_action = 8;
    // Is MAC learning disabled
    bool mac_learning_disabled = 9;
    // Is MAC port down flush disabled
    bool mac_port_down_flush_disabled = 10;
    // MAC limit notification
    string mac_limit_notification_type = 11;
    // Is MAC Secure Enabled
    bool is_mac_secure_enabled = 12;
    // Is MAC Secure Logging Enabled
    bool is_mac_secure_logging_enabled = 13;
    // MAC secure action
    string mac_secure_action = 14;
    // Is MAC secure accept shutdown (BP only)
    bool is_mac_secure_accept_shutdown = 15;
    // MAC aging type
    bool mac_aging_type = 16;
    // Is unicast storm control enabled
    bool storm_control_unicast_enabled = 17;
    // Is broadcast storm control enabled
    bool storm_control_broadcast_enabled = 18;
    // Is multicast storm control enabled
    bool storm_control_multicast_enabled = 19;
    // Storm control unicast rate unit
    string storm_control_unicast_rate_unit = 20;
    // Storm control broadcast rate unit
    string storm_control_broadcast_rate_unit = 21;
    // Storm control multicast rate unit
    string storm_control_multicast_rate_unit = 22;
    // Is DHCP snooping enabled
    bool dhcp_enabled = 23;
    // Is DHCP trusted
    bool dhcp_trusted = 24;
    // Is Dynamic ARP Inspection Enabled
    bool is_dai_enabled = 25;
    // Is DAI IPv4 Address Validation Enabled
    bool is_dai_addr_validation_ipv4_enabled = 26;
    // Is DAI Source MAC Address Validation Enabled
    bool is_dai_addr_validation_source_mac_enabled = 27;
    // Is DAI Destination MAC Validation enabled
    bool is_dai_addr_validation_destination_mac_enabled = 28;
    // Is DAI Logging Enabled
    bool is_dai_logging_enabled = 29;
    // Is IP Source Guard Enabled
    bool is_ipsg_enabled = 30;
    // Is IP Source Guard Logging Enabled
    bool is_ipsg_logging_enabled = 31;
    // Is MMRP  Flood Optimization Enabled
    bool is_vpls_flood_optimization_enabled = 32;
    // Is IGMP snooping enabled
    bool igmp_snoop_enabled = 33;
    // Is IGMP snooping profile enabled
    bool igmp_snoop_profile_enabled = 34;
    // Is IGMP flood forwarding enabled
    bool igmp_flood_forward_enabled = 35;
    // Is mrouter port
    bool igmp_mroute_port_enabled = 36;
    // Is router gurad enabled
    bool igmp_route_guard_enabled = 37;
    // Is MLD snooping enabled
    bool mld_snoop_enabled = 38;
    // Is MLD snooping profile enabled
    bool mld_snoop_profile_enabled = 39;
    // Is MLD flood forwarding enabled
    bool mld_flood_forward_enabled = 40;
    // Is mrouter port
    bool mld_mroute_port_enabled = 41;
    // Is router gurad enabled
    bool mld_route_guard_enabled = 42;
    // Is Spanning Tree Protocol participating
    bool stp_participating = 43;
    // Is BVI Interface configured
    bool bvi_configured = 44;
    // Is BVI state UP
    bool is_bvi_up = 45;
    // Is VNI enabled
    bool is_vni_enabled = 46;
    // Is EVPN enabled
    bool is_evpn_enabled = 47;
    // Unknown Unicast Flooding is disabled
    bool unknown_unicast_flooding_disabled = 48;
    // Host Routing enabled on this BD
    bool host_routing_enabled = 49;
    // Is PBBEVPN enabled
    bool is_pbbevpn_enabled = 50;
    // Is SW MAC learning enabled
    bool is_swmac_learning = 51;
    // Is EVPN Flow Label enabled
    bool is_evpn_flow_label = 52;
    // Is EVPN CW disabled
    bool is_evpn_cw_disable = 53;
    // Multi-spanning tree instance
    uint32 msti = 54;
    // Is P2MP PW enabled
    bool is_p2_mp_pw_enabled = 55;
    // Is IGMP Snooping admin enabled
    bool is_igmp_snoop_enabled = 56;
    // nV Satellite Offload IPv4 Multicast Disabled
    bool n_v_satellite_offload_ipv4_multicast_disabled = 57;
    // Feature information
    repeated l2fib_feature_un feature = 58;
}

// L2VPN bridge port operational information
message l2fib_oper_bridge_port_info {
    // L2 operational information
    l2fib_oper_info operational_information = 1;
    // Unicast storm control pps
    uint64 unicast_storm_control_pps = 2;
    // Unicast storm control kbps
    uint64 unicast_storm_control_kb_ps = 3;
    // Broadcast storm control pps
    uint64 broadcast_storm_control_pps = 4;
    // Broadcast storm control kbps
    uint64 broadcast_storm_control_kb_ps = 5;
    // Multicast storm control pps
    uint64 multicast_storm_control_pps = 6;
    // Multicast storm control kbps
    uint64 multicast_storm_control_kb_ps = 7;
}

message l2fib_nhop_info {
    // Base Information
    l2fib_base_info base = 1;
    // NHOP Address
    string next_hop_address = 2;
    // NHOP Internal Label
    uint32 next_hop_internal_label = 3;
    // Is Platform Data Valid
    bool plaformt_data_valid = 4;
    // Platform Data Length
    uint32 platform_data_length = 5;
    // Children Count
    uint32 children_count = 6;
}

message l2fib_bridge_port_p2mp_info {
    // P2MP ptree type
    string p_tree_type = 1;
    // MLDP LSM id
    uint32 lsm_id = 2;
    // TE Tunnel Id
    uint32 tunnel_id = 3;
    // TE P2MP Id
    uint32 p2_mp_id = 4;
    // TE Extended Tunnel Id
    string extended_tunnel_id = 5;
    // PTree Owner LMRIB
    bool p_tree_owner_lmrib = 6;
}

message l2fib_ac_info {
    // Base Information
    l2fib_base_info base = 1;
    // Interface Handle
    string interface_handle = 2;
    // Sub Interface Handle
    string sub_interface_handle = 3;
    // Attachment Circuit ID
    uint32 attachment_circuit_id = 4;
    // MTU of Attachment Circuit
    uint32 attachment_circuit_mtu = 5;
    // Attachment Circuit Type
    uint32 ac_type = 6;
    // Interworking Mode
    uint32 inter_working_mode = 7;
    // Adjacency Valid
    bool adjacency_valid = 8;
    // Adjacency Valid
    string adjacency_address = 9;
    // Bound
    bool bound = 10;
    // IP Interworking MAC
    string ip_inter_working_mac = 11;
    // ICCP Redundancy Group ID
    uint32 redundancy_group_id = 12;
    // ICCP Redundancy Object ID
    uint64 redundancy_object_id = 13;
    // EVPN Internal Label
    uint32 evpn_internal_label = 14;
    // Is Flexible XConnect Service Next Hop Valid
    bool fxc_next_hop_valid = 15;
    // Flexible XConnect Service Next Hop
    l2fib_nhop_info fxc_next_hop = 16;
}

message l2fib_monitor_session_info {
    // Base Information
    l2fib_base_info base = 1;
    // Xconnect ID
    uint32 xcid = 2;
    // Monitor Session Name
    string session_name = 3;
    // hardware Information of Monitor Session
    bytes hardware_information = 4;
    // Bound
    bool bound = 5;
}

message l2fib_pbb_edge_info {
    // Configured MAC
    bool mac_configured = 1;
    // unknown unicast bmac
    string mac = 2;
}

message l2fib_pbb_core_info {
    uint32 vlan_id = 1;
}

message l2fib_pbb_un {
    string pbb_type = 1;
    l2fib_pbb_edge_info edge = 2;
    l2fib_pbb_core_info core = 3;
}

message l2fib_pbb_info {
    // Base Information
    l2fib_base_info base = 1;
    // Bound
    bool bound = 2;
    // Union of Edge and Core
    l2fib_pbb_un pbb_union = 3;
    // Forward Class
    uint32 forward_class = 4;
    // Core PBB-EVPN enabled
    bool core_pbb_evpn_enabled = 5;
}

message l2fib_vni_info {
    // Base Information
    l2fib_base_info base = 1;
    // VNI Src IPv4 Address
    string srcip = 2;
    // VNI Mcast IP Address
    string mcastip = 3;
    // Bound
    bool bound = 4;
    // Parent NVE Interface
    string parent_if = 5;
    // Encap type of VNI
    uint32 encap = 6;
    // UDP Port
    uint32 udp_port = 7;
    // Source IF Handle
    string source_vtep_if = 8;
    // Anycast VTEP IP
    string any_cast_ip = 9;
    // Anycast Multicast IP
    string anycast_mcast_ip = 10;
    // Vxlan mode
    uint32 vx_lan_mode = 11;
}

message l2fib_evpn_info {
    // Base Information
    l2fib_base_info base = 1;
    // Bound
    bool bound = 2;
    // EVPN ID
    uint32 evi = 3;
    // Forward Class
    uint32 forward_class = 4;
}

message l2fib_pw_mpls_info {
    // PW Label
    uint32 pw_label = 1;
    // Local PW Label
    uint32 pw_local_label = 2;
    // PW tunnel interface
    uint32 pw_tunnel_interface = 3;
    // PW XCID
    uint32 pw_xcid = 4;
}

message l2fib_pw_l2tp_sess_info {
    // L2TP session ID
    uint32 session_id = 1;
    // Cookie size
    uint32 cookie_size = 2;
    // Cookie low value
    uint32 cookie_low_value = 3;
    // Cookie high value
    uint32 cookie_high_value = 4;
}

message l2fib_pw_l2tp_ipv6_ts_sess_info {
    // Cookie size
    uint32 cookie_size = 1;
    // Cookie low value
    uint32 cookie_low_value = 2;
    // Cookie high value
    uint32 cookie_high_value = 3;
    // Secondary Cookie size
    uint32 secondary_cookie_size = 4;
    // Secondary Cookie low value
    uint32 secondary_cookie_low_value = 5;
    // Secondary Cookie high value
    uint32 secondary_cookie_high_value = 6;
    // L2TP session ID
    uint32 session_id = 7;
}

message l2fib_pw_l2tp_info {
    // Local session info
    l2fib_pw_l2tp_sess_info local = 1;
    // Remote session info
    l2fib_pw_l2tp_sess_info remote = 2;
    // TOS val
    uint32 tos_val = 3;
    // TTL
    uint32 ttl = 4;
    // Path MTU
    uint32 path_mtu = 5;
    // Number of sequence sent
    uint32 sequence_number_sent = 6;
    // Number of sequence expected
    uint32 sequence_number_expected = 7;
}

message l2fib_pw_l2tp_ipv6_ts_info {
    // Local session info
    l2fib_pw_l2tp_ipv6_ts_sess_info local = 1;
    // Remote session info
    l2fib_pw_l2tp_sess_info remote = 2;
    // TOS val
    uint32 tos_val = 3;
    // TTL
    uint32 ttl = 4;
    // Path MTU
    uint32 path_mtu = 5;
    // Number of sequence sent
    uint32 sequence_number_sent = 6;
    // Number of sequence expected
    uint32 sequence_number_expected = 7;
    // Local address
    string local_address = 8;
    // Remote address
    string remote_address = 9;
}

message l2fib_pw_l2tpv2_sess_info {
    // L2TPv2 session ID
    uint32 session_id = 1;
    // L2TPv2 tunnel ID
    uint32 tunnel_id = 2;
}

message l2fib_pw_l2tpv2_info {
    // Local session info
    l2fib_pw_l2tpv2_sess_info local = 1;
    // Remote session info
    l2fib_pw_l2tpv2_sess_info remote = 2;
    // L2TPv2 PW flags
    uint32 pw_flags = 3;
    // TOS val
    uint32 tos_val = 4;
    // TTL [Hops number]
    uint32 ttl = 5;
    // Path MTU [Bytes]
    uint32 path_mtu = 6;
    // Protocol [UDP RFC-768]
    uint32 protocol = 7;
    // Remote UDP Port
    uint32 rem_udp_port = 8;
    // Xconnect ID
    uint32 x_connect_id = 9;
    // Next Hop Address
    string next_hop_address = 10;
    // Source Address
    string source_address = 11;
}

// L2VPN bridge port info
message l2fib_bridge_port_info {
    // Base Information
    l2fib_base_info base = 1;
    // Bridge ID
    uint32 bridge_id = 2;
    // Split horizon group ID
    uint32 shg_id = 3;
    // MSTI Pointer
    uint32 msti_pointer = 4;
    // Segment type
    uint32 segment_type = 5;
    // MVRP Sequence Number
    uint32 mvrp_sequence_number = 6;
    // Operational information
    l2fib_oper_bridge_port_info oper = 7;
    // BP P2MP PW Information
    l2fib_bridge_port_p2mp_info p2_mp = 8;
    // Learn Key
    uint32 learn_key = 9;
}

// L2VPN FXS info
message l2fib_fxs_info {
    // Base Information
    l2fib_base_info base = 1;
    // FXS ID
    uint32 fxs_id = 2;
    // Segment type
    uint32 segment_type = 3;
}

message l2fib_pw_un {
    string data_type = 1;
    l2fib_pw_mpls_info mpls = 2;
    l2fib_pw_l2tp_info l2_tp = 3;
    l2fib_pw_l2tpv2_info l2_tpv2 = 4;
    l2fib_pw_l2tp_ipv6_ts_info l2_tp_ipv6_ts = 5;
}

message l2fib_backup_pw_info {
    // Backup Next Hop
    string backup_next_hop = 1;
    // Pseudowire ID type
    string backup_pseudo_wire_id_type = 2;
    // Backup Pseudowire ID
    uint32 backup_pseudo_wire_id = 3;
    l2fib_pw_mpls_info atom = 4;
    // Redundancy Role
    string redundancy_role = 5;
    // PW is active and forwarding
    bool active = 6;
    // Bound
    bool bound = 7;
    // Pseudowire flow label TX enabled
    bool pw_flow_label_tx = 8;
    // Grouping supported
    bool grouping_supported = 9;
    // PW Group Id
    uint32 group_id = 10;
    // Group State
    string group_state = 11;
}

message l2fib_pw_info {
    // Base Information
    l2fib_base_info base = 1;
    // Pseudowire ID
    uint64 pw_id = 2;
    // Sig Capability flags
    uint32 signal_capability_flags = 3;
    // Context
    uint32 context = 4;
    // Sequence Resync Threshold
    uint32 sequence_resync_threshold = 5;
    // Bound
    bool bound = 6;
    // IS Next Hop Valid
    bool next_hop_valid = 7;
    // Next Hop
    l2fib_nhop_info next_hop = 8;
    // Union of MPLS or L2TP
    l2fib_pw_un pseudo_wire_union = 9;
    // Backup Pseudowire Configured
    bool backup_configured = 10;
    // Backup Pseudowire
    l2fib_backup_pw_info backup_pseudo_wire = 11;
    // Redundancy Role
    string redundancy_role = 12;
    // PW is active and forwarding
    bool active = 13;
    // Pseudowire ID type
    string pseudo_wire_id_type = 14;
    // Type of load-balancing
    string pw_load_balance_type = 15;
    // Pseudowire flow label TX enabled
    bool pw_flow_label_tx = 16;
    // Grouping supported
    bool grouping_supported = 17;
    // PW Group Id
    uint32 group_id = 18;
    // Group State
    string group_state = 19;
    // Global Id
    uint32 global_id = 20;
    // Ac Id
    uint32 ac_id = 21;
    // Forward Class
    uint32 forward_class = 22;
}

message l2fib_seg1_un {
    string data_type = 1;
    l2fib_ac_info ac = 2;
    l2fib_pbb_info pbb = 3;
    l2fib_vni_info vni = 4;
    l2fib_evpn_info evpn = 5;
    l2fib_monitor_session_info monitor_session = 6;
    l2fib_pw_info pw = 7;
}

message l2fib_seg2_un {
    string data_type = 1;
    l2fib_ac_info ac = 2;
    l2fib_bridge_port_info bp = 3;
    l2fib_fxs_info fxs = 4;
    l2fib_pw_info pw = 5;
}

