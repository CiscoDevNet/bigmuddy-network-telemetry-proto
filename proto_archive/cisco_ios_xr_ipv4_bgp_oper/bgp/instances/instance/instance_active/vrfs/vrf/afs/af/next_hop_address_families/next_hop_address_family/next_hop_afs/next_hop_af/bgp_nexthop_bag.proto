// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_ipv4_bgp_oper.bgp.instances.instance.instance_active.vrfs.vrf.afs.af.next_hop_address_families.next_hop_address_family.next_hop_afs.next_hop_af;

// BGP Nexthop info
message bgp_nexthop_bag_KEYS {
    string instance_name = 1;
    string vrf_name = 2;
    string af_name = 3;
    string next_hop_af_name = 4;
    string next_hop_address = 5;
    string attribute_set = 6;
}

message bgp_nexthop_bag {
    // Address family identifier
    string af_name = 50;
    // Nexthop address
    bgp_addrtype nexthop_address = 51;
    // NH TE tunnel information
    bgp_te_tunnel nhte_tunnel = 52;
    // RIB Nexthop Id
    uint32 rib_nexthop_id = 53;
    // Nexthop registration is pending
    uint32 nexthop_pending_registration = 54;
    // Number of neighbors/prefixes referencing this nexthop
    uint32 nexthop_reference_count = 55;
    // Number of neighbors/prefixes referencing this nexthop (AFs)
    uint32 nh_reference_count_total = 56;
    // First-hop interface handle
    string nh_first_hop_if_handle = 57;
    // Gateway related info, includingOptimal Route Reflector Gateways
    repeated bgp_nexthop_gw_info_ nexthop_gateway_info = 58;
    // AIGP metrice of nexthop
    uint32 nexthop_aigp_metric = 59;
    // Internal nexthop info
    bgp_int_nh_ nexthop_internal_info = 60;
    // Neighbor Address List
    repeated bgp_addrtype neighbor_address_list = 61;
    // Is Gateway reachable ?
    bool nexthop_gateway_reachable = 62;
    // Is Gateway resolved through Connected route ?
    bool nexthop_gateway_prefix_connected = 63;
    // Gateway prefix length
    uint32 nexthop_gateway_prefix_length = 64;
}

// IPV4Tunnel Address type
message IPV4TunnelAddressType {
    string value = 1;
}

// IPV4MDT Address type
message IPV4MDTAddressType {
    string value = 1;
}

// IPV4 RTConstraint Address type
message RTConstraintAddressType {
    string value = 1;
}

// IPV6 Address type
message IPV6AddressType {
    string value = 1;
}

message bgp_l2vpn_addr_t {
    bytes l2vpn_address = 1;
}

// L2VPN EVPN Address type
message L2VPNEVPNAddressType {
    string value = 1;
}

message bgp_l2vpn_mspw_addr_t {
    bytes l2vpn_address = 1;
}

// IPV6 MVPN Address type
message IPV6MVPNAddressType {
    string value = 1;
}

// IPV4 MVPN Address type
message IPV4MVPNAddressType {
    string value = 1;
}

// LINKSTATE LINKSTATE Address type
message LS_LSAddressType {
    string value = 1;
}

// IPv4 Flowspec Address type
message IPv4FlowspecAddressType {
    string value = 1;
}

// IPv6 Flowspec Address type
message IPv6FlowspecAddressType {
    string value = 1;
}

message bgp_addrtype {
    string afi = 1;
    // IPv4 Addr
    string ipv4_address = 2;
    // IPv4 Mcast Addr
    string ipv4_mcast_address = 3;
    // IPv4 Label Addr
    string ipv4_label_address = 4;
    // IPv4 Tunnel
    IPV4TunnelAddressType ipv4_tunnel_address = 5;
    // IPv4 MDT Addr
    IPV4MDTAddressType ipv4_mdt_address = 6;
    // IPv4 VPN Addr
    string ipv4_vpn_address = 7;
    // IPv4 VPN Mcast Addr
    string ipv4_vpna_mcastddress = 8;
    // IPV6 Addr
    IPV6AddressType ipv6_address = 9;
    // IPV6 Mcast Addr
    IPV6AddressType ipv6_mcast_address = 10;
    // IPv6 Label Addr
    IPV6AddressType ipv6_label_address = 11;
    // IPv6 VPN Addr
    IPV6AddressType ipv6_vpn_address = 12;
    // IPv6 VPN Mcast Addr
    IPV6AddressType ipv6_vpn_mcast_address = 13;
    // L2VPN VPLS Addr
    bgp_l2vpn_addr_t l2_vpnvpls_address = 14;
    // RT Constrt Addr
    RTConstraintAddressType rt_constraint_address = 15;
    // MVPN addr
    IPV6MVPNAddressType ipv6_mvpn_address = 16;
    // MVPN4 addr
    IPV4MVPNAddressType ipv4_mvpn_address = 17;
    // L2VPN EVPN Addr
    L2VPNEVPNAddressType l2_vpn_evpn_address = 18;
    // LINKSTATE LINKSTATE Addr
    LS_LSAddressType ls_ls_address = 19;
    // L2VPN MSPW Addr
    bgp_l2vpn_mspw_addr_t l2_vpn_mspw_address = 20;
    // IPV4 Flowspec Addr
    IPv4FlowspecAddressType ipv4_flowspec_address = 21;
    // IPV6 Flowspec Addr
    IPv6FlowspecAddressType ipv6_flowspec_address = 22;
    // IPV4 VPN Flowspec Addr
    IPv4FlowspecAddressType ipv4_vpn_flowspec_address = 23;
    // IPV6 VPN Flowspec Addr
    IPv6FlowspecAddressType ipv6_vpn_flowspec_address = 24;
}

message bgp_te_tunnel {
    bytes tunnel_name = 1;
    // NH TE Tunnel info is present
    bool has_te_tunnel = 2;
    // Tunnel Up flag
    bool is_tunnel_up = 3;
    // Tunnel is stale
    bool is_tunnel_info_stale = 4;
    // Tunnel registered flag
    bool is_tunnel_registered = 5;
    // Tunnel need IPv6
    bool tunnel_v6_required = 6;
    // IPv6 enabled
    bool tunnel_v6_enabled = 7;
    // Binding label for the tunnel
    uint32 binding_label = 8;
    // Interface handle for the tunnel
    uint32 tunnel_if_handle = 9;
    // Time since the last rib update happened
    uint32 last_tunnel_update = 10;
}

message bgp_int_nh_gw_ {
    // Gateway flags
    uint32 gateway_flags = 1;
    // Nexthop registration type
    string registration_type = 2;
    // Time since registration
    uint32 registration_since = 3;
}

message bgp_int_nh_ {
    // Nexthop address
    bgp_addrtype nexthop_address = 1;
    // Comm librray ID
    uint32 nexthop_id = 2;
    // Table version
    uint32 nexthop_version = 3;
    // Nexthop flags
    uint32 nexthop_flags = 4;
    // Nexthop ifhandle
    uint32 nexthop_if_handle = 5;
    // Nexthop metrices
    repeated uint32 nexthop_metrices = 6;
    // Nexthop refcounts
    repeated uint32 nexthop_refcounts = 7;
    // Bitmask indicating the AFs which share the nexthop
    uint32 nexthop_af_user_bits = 8;
    // Nexthop label
    uint32 nexthop_label = 9;
    // Gateway flags
    uint32 gateway_flags = 10;
    // Internal nexthop Gateway info
    repeated bgp_int_nh_gw_ nexthop_gateway_internal_info = 11;
}

message bgp_nexthop_gw_info_ {
    // Route resolving the nethop
    bgp_addrtype nexthop_route = 1;
    // Prefix length of the route resolving the nexthop
    uint32 nexthop_route_prefix_length = 2;
    // Protocol that resolves the route to the nexthop
    string nexthop_route_protocol = 3;
    // Number of paths in the resolving route
    uint32 nexthop_route_path_count = 4;
    // Nexthops of the resolving route
    repeated bgp_addrtype nexthop_route_paths = 5;
    // Bitmask indicating the AFs which have been invalidated for the nexthop
    uint32 nexthop_af_invalid_bits = 6;
    // Nexthop status
    uint32 nexthop_status = 7;
    // Nexthop Table id
    uint64 nexthop_tableid = 8;
    // IGP metric for nexthop
    uint32 nexthop_metric = 9;
    // Last nexthop event type
    string last_event_type = 10;
    // Last nexthop update type
    string last_update_type = 11;
    // Number of critical events received from RIB
    uint32 critical_events = 12;
    // Number of non-critical events received from RIB
    uint32 non_critical_events = 13;
    // Time since the last event sent to or received from RIB
    uint32 last_event_since = 14;
    // Time since the last rib update happened
    uint32 last_rib_update = 15;
    // TRUE if MPLS is configured for IAS/CsC application
    bool nexthop_mpls_enabled = 16;
    // Number of interfaces on which MPLS is enabled
    uint32 nexthop_mpls_interfaces = 17;
    // Local label allocated for IAS/CsC application
    uint32 nexthop_mpls_label = 18;
}

