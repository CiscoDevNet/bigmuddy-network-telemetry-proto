// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_clns_isis_oper.isis.instances.instance.interfaces.interface;

// All the Information of an IS-IS interface
message isis_sh_if_KEYS {
    string instance_name = 1;
    string interface_name = 2;
}

message isis_sh_if {
    // Configured circuit type for the interface
    string configured_circuit_type = 50;
    // Configured interface status
    isis_sh_if_cfg_status configured_status = 51;
    // Interface mesh group
    uint32 mesh_group = 52;
    // IS-type of the router
    string is_type = 53;
    // Information about the interface status and its data
    isis_sh_if_status interface_status_and_data = 54;
    // ISIS NSR Interface
    bool nsr_intf = 55;
}

message isis_ipv6_address_type {
    string value = 1;
}

// IPv4 address and prefix length
message isis_ipv4_prefix_type {
    // prefix
    string prefix = 1;
    // prefix length
    uint32 prefix_length = 2;
}

// IPv4 address and prefix length
message isis_ipv6_prefix_type {
    // prefix
    string prefix = 1;
    // prefix length
    uint32 prefix_length = 2;
}

message isis_ip_addr_type {
    string af_name = 1;
    // IPV4 address type
    string ipv4 = 2;
    // IPV6 address type
    isis_ipv6_address_type ipv6 = 3;
}

message isis_ip_prefix_type {
    string af_name = 1;
    isis_ipv4_prefix_type ipv4 = 2;
    isis_ipv6_prefix_type ipv6 = 3;
}

// Identification of an IS-IS topology
message isis_topo_id_type {
    // AF name
    string af_name = 1;
    // Sub-AF name
    string saf_name = 2;
    // VRF Name
    string vrf_name = 3;
    // Topology Name
    string topology_name = 4;
}

// Disabled interface info
message isis_sh_if_disabled {
    // Reason why the interface is disabled
    string reason_code = 1;
}

// Interface info when adjacency formation is disabled
message isis_sh_if_adj_form_disabled {
    // Reason why the interface is not able to form adjacencies
    string reason_code = 1;
}

message isis_sh_if_adj_form_status {
    string status = 1;
    // Disabled info for the adjacency formation status
    isis_sh_if_adj_form_disabled disabled = 2;
}

// Interface info when prefix advertisement is disabled
message isis_sh_if_adv_prefix_disabled {
    // Reason why the interface is not able to advertise prefixes
    string reason_code = 1;
}

message isis_sh_if_adv_prefix_status {
    string status = 1;
    // Disabled info for the prefix advertisement status
    isis_sh_if_adv_prefix_disabled disabled = 2;
}

// Configured state of an interface
message isis_sh_if_cfg_status {
    // Configured adjacency formation status
    bool adjacency_form_status = 1;
    // Configured prefix advertisement status
    bool adv_prefix_status = 2;
}

// Interface info when CLNS is down
message isis_sh_if_clns_proto_down {
    // Reason why CLNS is down
    string reason_code = 1;
}

message isis_sh_if_clns_status {
    string status = 1;
    // State describing why CLNS is down
    isis_sh_if_clns_proto_down clns_down_info = 2;
}

// Interface info with invalid MTU
message isis_sh_if_clns_mtu_invalid {
    // Reason why the MTU is invalid
    string reason_code = 1;
}

message isis_sh_if_clns_mtu_status {
    string status = 1;
    // Information pertaining to the invalid CLNS MTU
    isis_sh_if_clns_mtu_invalid invalid = 2;
    // Valid MTU
    uint32 mtu = 3;
}

// Interface info with CLNS SNPA unknown
message isis_sh_if_clns_snpa_unknown {
    // Reason why the SNPA is unknown
    string reason_code = 1;
}

// CLNS SNPA info
message isis_sh_if_clns_snpa_known {
    // Valid SNPA
    string snpa = 1;
}

message isis_sh_if_clns_snpa_status {
    string status = 1;
    // Information pertaining to the unknown SNPA state
    isis_sh_if_clns_snpa_unknown unknown = 2;
    // Information pertaining to the known SNPA state
    isis_sh_if_clns_snpa_known known = 3;
}

// Invalid multicast info
message isis_sh_if_mcast_invalid {
    // Reason why the multicast status is invalid
    string reason_code = 1;
}

message isis_sh_if_mcast_status {
    string status = 1;
    // Information pertaining to the invalid multicast status
    isis_sh_if_mcast_invalid invalid = 2;
}

// Per interface per area CLNS state
message isis_sh_if_area_clns {
    // Level of the area
    string level = 1;
    // Multicast group membership status
    isis_sh_if_mcast_status multicast_status = 2;
}

// LAN specific CLNS state
message isis_sh_if_clns_lan {
    // Array of per area CLNS data
    repeated isis_sh_if_area_clns per_area_data = 1;
}

// Point-to-point over LAN specific CLNS state
message isis_sh_if_clns_p2p_over_lan {
    // Multicast group membership status
    isis_sh_if_mcast_status multicast_status = 1;
}

// Point-to-point CLNS state
message isis_sh_if_clns_p2p {
    // Point-to-point over LAN data
    isis_sh_if_clns_p2p_over_lan p2_p_over_lan_data = 1;
}

// Media Specific CLNS state
message isis_sh_if_clns_media_specific_status {
    string clns_media_type = 1;
    // LAN state
    isis_sh_if_clns_lan clns_lan_data = 2;
    // Point-to-point state
    isis_sh_if_clns_p2p clns_p2_p_data = 3;
}

// CLNS I/O data for an interface
message isis_sh_if_clns {
    // Is CLNS protcol up or if not, the reason why it is not up
    isis_sh_if_clns_status clns_status = 1;
    // A valid MTU or the reason for the MTU being invalid
    isis_sh_if_clns_mtu_status mtu_info = 2;
    // SNPA state
    isis_sh_if_clns_snpa_status snpa_state = 3;
    // Media Specific CLNS state
    isis_sh_if_clns_media_specific_status media_specific_state = 4;
    // Time until next LSP may be sent (ms)
    uint32 time_until_next_lsp = 5;
    // TRUE if an LSP transmission has been requested
    bool lsp_transmit_requested_flag = 6;
    // TRUE if an LSP transmission has been sent, indicates LastLSPLevelTransmitted and LastLSP_IDTransmitted valid
    bool lsp_transmitted_flag = 7;
    // Number of LSPs that can be sent back to back in the current window without exceeding the pacing limit
    uint32 lsp_txmitd_b2_b_limit = 8;
    // Time im msecs indicating the end of the window in which the 'back to back lsps to be sent' counter applies
    uint32 lsp_txmt_b2_b_msecs = 9;
    // Level of the Last LSP Transmitted
    string last_lsp_level_transmitted = 10;
    // Last LSP ID Transmitted
    string last_lsp_id_transmitted = 11;
}

// Per-interface, per-area data for active LAN interface
message isis_sh_if_area_active_lan {
    // Circuit LAN ID
    bytes circuit_lan_id = 1;
    // Time (ms) until next IIH
    uint32 time_until_next_iih = 2;
    // Interface's DIS-election priority
    uint32 interface_priority = 3;
    // Priority of current DIS on this LAN
    uint32 dis_priority = 4;
    // Flag indicating if this LAN circuit is the DIS
    bool are_we_dis = 5;
}

// Per-area data for an interface
message isis_sh_if_area_active {
    // Level of the area
    string level = 1;
    // Number of adjacencies
    uint32 adjacency_count = 2;
    // LSP pacing time period (ms)
    uint32 lsp_pacing_interval = 3;
    // No. of SNP entries queued to be transmitted
    uint32 psnp_transmit_queue_size = 4;
    // LAN data, NULL iff interface has non-LAN media type
    isis_sh_if_area_active_lan lan_data = 5;
}

// Topology info when adjacency formation is disabled
message isis_sh_if_topo_adj_form_disabled {
    // Reason why the adjacency formation status of a topology is disabled
    string reason_code = 1;
}

message isis_sh_if_topo_adj_form_status {
    string status = 1;
    // Disabled state for the adjacency formation status of a topology
    isis_sh_if_topo_adj_form_disabled disabled = 2;
}

// Topology info when prefix advertisement is disabled
message isis_sh_if_topo_adv_prefix_disabled {
    // Reason why the prefix advertisement status of a topology is disabled
    string reason_code = 1;
}

message isis_sh_if_topo_adv_prefix_status {
    string status = 1;
    // Disabled state for the prefix advertisement status of a topology
    isis_sh_if_topo_adv_prefix_disabled disabled = 2;
}

// Enabled topology info of an interface
message isis_sh_if_topo_enabled {
    // Adjacency formation status of a topology
    isis_sh_if_topo_adj_form_status adjacency_form_status = 1;
    // Prefix advertisement status of a topology
    isis_sh_if_topo_adv_prefix_status adv_prefix_status = 2;
    // L1 metric for this topology
    uint32 level1_metric = 3;
    // L2 metric for this topology
    uint32 level2_metric = 4;
    // L1 metric for this topology
    uint32 level1_weight = 5;
    // L2 metric for this topology
    uint32 level2_weight = 6;
    // MPLS maximum number of pri labels supported
    uint32 max_label_supported = 7;
    // MPLS maximum number of backup labels supported
    uint32 max_bkp_label_supported = 8;
    // MPLS maximum number of srte labels supported
    uint32 max_srte_label_supported = 9;
    // MPLS LDP sync enabled status for L1
    bool level1_ldp_sync_enabled = 10;
    // MPLS LDP sync enabled status for L2
    bool level2_ldp_sync_enabled = 11;
    // Status of MPLS LDP synchronization
    bool ldp_sync_status = 12;
    // Status of MPLS LDPv6 synchronization
    bool ld_pv6_sync_status = 13;
    // L1 metric-offset for this topology
    uint32 level1_offset_metric = 14;
    // L2 metric-offset for this topology
    uint32 level2_offset_metric = 15;
    // Link-Group configure status for L1
    bool level1_lkgp_configured = 16;
    // Link-Group configure status for L2
    bool level2_lkgp_configured = 17;
    // L1 PP-metric for this topology
    uint32 level1_pp_metric = 18;
    // L2 PP-metric for this topology
    uint32 level2_pp_metric = 19;
    // PP configure status for L1
    bool level1_pp_configured = 20;
    // PP configure status for L2
    bool level2_pp_configured = 21;
}

// Disabled topology info of an interface
message isis_sh_if_topo_disabled {
    // Reason why the topology is disabled
    string reason_code = 1;
}

message isis_sh_if_topo_status {
    string status = 1;
    // Disabled information of a topology
    isis_sh_if_topo_disabled disabled = 2;
    // Enabled information of a topology
    isis_sh_if_topo_enabled enabled = 3;
}

// Per topology info of an interface
message isis_sh_if_topo {
    // Topology identifier
    isis_topo_id_type topology_id = 1;
    // Status of the topology
    isis_sh_if_topo_status status = 2;
}

// Address prefix unknown info
message isis_sh_if_af_prefix_unknown {
    // Reason why the global prefix(es) is(are) unknown
    string reason_code = 1;
}

// Address prefix info
message isis_sh_if_af_prefix_data {
    // Array of global prefixes
    repeated isis_ip_prefix_type prefix = 1;
    // Is the interface unnumbered
    bool is_unnumbered = 2;
}

message isis_sh_if_af_prefix_status {
    string status = 1;
    // Unknown state for the global prefixes
    isis_sh_if_af_prefix_unknown unknown = 2;
    // Global prefix data for the Address Family
    isis_sh_if_af_prefix_data prefix_data = 3;
}

// Address-family forwarding address data
message isis_sh_if_af_fwd_addr_data {
    // Array of forwarding addresses
    repeated isis_ip_addr_type forwarding_address = 1;
    // If the interface is unnumbered, then its name, else NULL
    string unnumbered_interface_name = 2;
}

// Forwarding address unknown data
message isis_sh_if_af_fwd_addr_unknown {
    // Reason why the forwarding address(es) of an AF is(are) unknown
    string reason_code = 1;
}

message isis_sh_if_af_fwd_addr_status {
    string status = 1;
    // Unknown forwarding address data
    isis_sh_if_af_fwd_addr_unknown unknown = 2;
    // Known Forwarding address data
    isis_sh_if_af_fwd_addr_data forwarding_address_data = 3;
}

// Address family protocol down info
message isis_sh_if_af_proto_down {
    // Reason why the Address Family protocol status is down
    string reason_code = 1;
}

message isis_sh_if_af_proto_status {
    string status = 1;
    // Disabled state of the Address Family protocol
    isis_sh_if_af_proto_down disabled = 2;
}

// Address family disabled info
message isis_sh_if_af_disabled {
    // Reason why the Address Family is disabled
    string reason_code = 1;
}

// Enabled address-family info of an interface
message isis_sh_if_af_enabled {
    // Protocol status of the AF
    isis_sh_if_af_proto_status protocol_status = 1;
    // Forwarding status of the AF
    isis_sh_if_af_fwd_addr_status forwarding_address_status = 2;
    // Prefix status of the AF
    isis_sh_if_af_prefix_status prefix_status = 3;
}

message isis_sh_if_af_status {
    string status = 1;
    // Disabled info for the AF of an interface
    isis_sh_if_af_disabled disabled = 2;
    // Enabled data for the AF of an interface
    isis_sh_if_af_enabled af_data = 3;
}

// Per Address family info
message isis_sh_if_af {
    // Address Family Identifier of the interface
    string af_name = 1;
    // Address Family status of the interface
    isis_sh_if_af_status af_status = 2;
}

// Per-interface data
message isis_sh_if_active_p2p {
    // Time in ms before the next IIH can be sent
    uint32 time_until_next_iih = 1;
    // No. of LSPs queued to be retransmitted
    uint32 retransmit_lsp_queue_size = 2;
    // Time in ms until the next scheduled LSP is retransmitted
    uint32 retransmit_lsp_interval = 3;
    // Extended Circuit Number valid for a P2P interface
    uint32 extended_circuit_number = 4;
}

// Per-interface BFD data
message isis_sh_if_bfd_type {
    // IPv4 BFD enabled status
    bool enabled = 1;
    // IPv6 BFD enabled status
    bool ipv6_enabled = 2;
    // BFD hello minimum interval in milliseconds
    uint32 interval = 3;
    // BFD hello multiplier
    uint32 multiplier = 4;
}

// State of an enabled interface
message isis_sh_if_enabled {
    // Interface's Adjacency Formation status
    isis_sh_if_adj_form_status adjacency_form_status = 1;
    // Interface's Prefix Advertisement status
    isis_sh_if_adv_prefix_status adv_prefix_status = 2;
    // Media type of the interface
    string interface_media_type = 3;
    // Enabled Circuit type of the interface
    string enabled_circuit_type = 4;
    // Local Circuit Number of the interface
    uint32 local_circuit_number = 5;
    // Data for an active P2P interface, NULL if not active or P2P
    isis_sh_if_active_p2p p2_p_data = 6;
    // The BFD data for the given interface
    isis_sh_if_bfd_type bfd_data = 7;
    // Rsi Srlg Registered
    bool rsi_srlg_registered = 8;
    // Interface data specific to CLNS I/O services
    isis_sh_if_clns clns_data = 9;
    // Underlying interface list for bundle interfaces
    repeated string underlying_interface_list = 10;
    // Array of area information for an active interface
    repeated isis_sh_if_area_active per_area_data = 11;
    // Array of topology information
    repeated isis_sh_if_topo per_topology_data = 12;
    // Array of address family information
    repeated isis_sh_if_af per_address_family_data = 13;
}

message isis_sh_if_status {
    string status = 1;
    // The interface state if disabled
    isis_sh_if_disabled disabled = 2;
    // The interface state if enabled
    isis_sh_if_enabled enabled = 3;
}

