// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_clns_isis_oper.isis.instances.instance.topologies.topology.topology_levels.topology_level.spf_log;

// Log of IS-IS route calculations
message isis_sh_spf_log_struc_KEYS {
    string instance_name = 1;
    string af_name = 2;
    string saf_name = 3;
    string topology_name = 4;
    string level = 5;
}

message isis_sh_spf_log_struc {
    // SPF Log entries
    repeated isis_sh_spf_log_ent log_entry = 50;
}

message isis_system_id_type {
    string value = 1;
}

message isis_node_id_type {
    string value = 1;
}

// IPv4 address and prefix length
message isis_ipv4_prefix_type {
    // prefix
    string prefix = 1;
    // prefix length
    uint32 prefix_length = 2;
}

// IPv4 address and prefix length
message isis_ipv6_prefix_type {
    // prefix
    string prefix = 1;
    // prefix length
    uint32 prefix_length = 2;
}

message isis_ip_prefix_type {
    string af_name = 1;
    isis_ipv4_prefix_type ipv4 = 2;
    isis_ipv6_prefix_type ipv6 = 3;
}

message isis_lsp_id_type {
    string value = 1;
}

// Per-priority counts
message isis_per_priority_counts {
    // Critical priority
    uint32 critical = 1;
    // High priority
    uint32 high = 2;
    // Medium priority
    uint32 medium = 3;
    // Low priority
    uint32 low = 4;
}

// Duration of an event in real and CPU time
message isis_timings_type {
    // Real time duration in milliseconds
    uint32 real_duration = 1;
    // CPU time duration in milliseconds
    uint32 cpu_duration = 2;
}

// Per-priority timings
message isis_per_priority_timings {
    // Critical priority
    isis_timings_type critical = 1;
    // High priority
    isis_timings_type high = 2;
    // Medium priority
    isis_timings_type medium = 3;
    // Low priority
    isis_timings_type low = 4;
}

// Timestamp for an event
message isis_sh_timestamp_type {
    // Timestamp value (seconds)
    uint32 seconds = 1;
    // Timestamp value (nanoseconds)
    uint32 nano_seconds = 2;
}

// Generic portion of a log entry
message isis_sh_generic_log_ent {
    // Time in UTC relative to Jan 1st, 1970
    isis_sh_timestamp_type timestamp = 1;
}

// The reasons for running a calculation
message isis_sh_spf_log_triggers {
    // Triggers applying to this log entry
    repeated string triggers = 1;
    // Number of unique triggers on this run
    uint32 unique_trigger_count = 2;
    // ID of the first LSP to trigger the calculation, if any
    isis_lsp_id_type first_trigger_lsp_id = 3;
    // ID of a changed link in the first trigger LSP, if any
    isis_node_id_type trigger_link = 4;
    // ID of a changed prefix in the first trigger LSP, if any
    isis_ip_prefix_type trigger_prefix = 5;
    // ID of a changed next hop, if any
    isis_system_id_type trigger_next_hop_id = 6;
    // Is this SR micro loop calculation?
    bool is_sr_uloop_calculation = 7;
    // Is this SR micro loop calculation for link down?
    bool is_sr_uloop_link_down = 8;
}

// Node counts for the SPT calculation phase
message isis_sh_spf_log_spt_calc_node_counts {
    // Number of unreachable nodes in the database
    uint32 unreachable = 1;
    // Number of reachable nodes in the database
    uint32 reachable = 2;
    // Number of nodes added to the SPT
    uint32 added = 3;
    // Number of nodes deleted from the SPT
    uint32 deleted = 4;
    // Number of modified nodes (first hop and/or metric change)
    uint32 modified = 5;
    // Number of nodes touched whilst calculating the SPT
    uint32 touched = 6;
}

// Statistics for the SPT calculation phase
message isis_sh_spf_log_spt_calc {
    // Duration of the SPT calculation
    isis_timings_type duration = 1;
    // Node counts
    isis_sh_spf_log_spt_calc_node_counts node_counts = 2;
}

// Node counts for the route update phase
message isis_sh_spf_log_route_update_node_counts {
    // Per-priority count of nodes considered during route update
    isis_per_priority_counts per_priority_touched = 1;
    // Total number of nodes considered during route update
    uint32 total_touched = 2;
}

// Prefix item counts for the route update phase
message isis_sh_spf_log_route_update_prefix_counts {
    // Number of unreachable prefixes in the database
    isis_per_priority_counts unreachable = 1;
    // Number of reachable prefixes in the database
    isis_per_priority_counts reachable = 2;
    // Number of prefixes added during calculation
    isis_per_priority_counts added = 3;
    // Number of prefixes deleted during calculation
    isis_per_priority_counts deleted = 4;
    // Number of prefixes modified, i.e. a first hop and/or metric change
    isis_per_priority_counts modified = 5;
    // Number of prefixes considered whilst updating the routing table
    isis_per_priority_counts touched = 6;
}

// Breakdown of the time taken to perform the route update
message isis_sh_spf_log_route_update_timings_breakdown {
    // Time to update IS-IS's local RIB
    isis_per_priority_timings local_rib_update = 1;
    // Time to build the update to send to the global RIB
    isis_per_priority_timings global_rib_build = 2;
    // Time to send the update to the global RIB
    isis_per_priority_timings global_rib_send = 3;
}

// Statistics for the route update phase of the calculation
message isis_sh_spf_log_route_update {
    // Duration of the routing table update
    isis_timings_type duration = 1;
    // Breakdown of the time taken by the routing table update
    isis_sh_spf_log_route_update_timings_breakdown duration_breakdown = 2;
    // Node counts
    isis_sh_spf_log_route_update_node_counts node_counts = 3;
    // Prefix item counts
    isis_sh_spf_log_route_update_prefix_counts item_counts = 4;
    // Distinct prefix counts
    isis_sh_spf_log_route_update_prefix_counts route_counts = 5;
    // Number of RIB batches sent
    isis_per_priority_counts rib_batch_counts = 6;
}

// IS-IS route calculation log entry
message isis_sh_spf_log_ent {
    // Generic entry data.
    isis_sh_generic_log_ent generic_data = 1;
    // Type of calculation.
    string class = 2;
    // Trigger information
    isis_sh_spf_log_triggers triggers = 3;
    // Statistics for the SPT calculation phase
    isis_sh_spf_log_spt_calc spt_calculation_statistics = 4;
    // Statistics for the route update phase
    isis_sh_spf_log_route_update route_update_statistics = 5;
    // Time between the first trigger and the start of the route calculation, in milliseconds.
    uint32 wait_enforced = 6;
    // Minimum time from end of this route calculation until the start of the next, in milliseconds
    uint32 next_wait_interval = 7;
    // Number of LSPs which arrived during the route calculation
    uint32 updated_lsp_count = 8;
}

